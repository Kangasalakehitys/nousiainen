[
  {
    "objectID": "verotus.html",
    "href": "verotus.html",
    "title": "Verotus",
    "section": "",
    "text": "d3 = require(\"d3@7\")\n//import {Legend} from \"@d3/color-legend\"\n\nfolderKunnat24TopoJSON = \"./maps/Kunnat2024Topo.json\"\nkunnat2024topo = FileAttachmentDynamic(folderKunnat24TopoJSON).json()\nmapTopoJSON = topojson.feature(kunnat2024topo, kunnat2024topo.objects.Kunnat2024_geo).features\n\n\nfolderMaakunnat24TopoJSON = \"./maps/Maakunnat2024Topo.json\"\nmaakunnat_2024_topo =  FileAttachmentDynamic(folderMaakunnat24TopoJSON).json()\nFileAttachmentDynamic = function(filename) {\n  return new Function(\"FileAttachment\", `return FileAttachment(\"${filename}\")`)(FileAttachment)\n}\n\n// Vaihdetaan tekstin väri\ncolor = function(vari) {\n  if(vari &gt; 0){\n      return \"green\"\n    }else{\n      return \"red\"\n    }\n}\n// Pyöristys\npyoristys = function(n, places) {\n  if (!places) return Math.round(n);\n  const d = 10 ** places;\n  return Math.round(n * d) / d;\n}\n//Euromerkintä\neurot = function(number) {\n  return number.toLocaleString('fi-FI', { style: 'currency', currency: 'EUR',minimumFractionDigits: 0 });\n}\n// Euromuutoksen laskeminen kertoimella\nmuutoskerroin = function(x, y) {\n  return (1+x/100)*y;\n}\n// Muutosprosentti\nmuutosprosentti = function(x, y) {\n  return pyoristys(((x-y)/y)*100,1);\n}\n// Tuhatjakaja\ntuhatjakaja = function(x) {\n  return x/1000;\n}\n// Euromuutoksen laskeminen kertoimella\npalkkakerroin = function(x, y) {\n  return 100*((1+x/100)*(1+y/100)-1);\n}\n// Jako-osuuden asukaskerroin\nasukaskerroin = function(x, y) {\n  return (x/y);\n}\n// Jako-osuuden veroprosenttikerroin miinus1/miinus3 vuotta miinus 1 vuoden kerroin\nveroprosenttikerroin = function(x, y) {\n  return (x/y);\n}\n// Kunnan muok. kunnallisvero, alkuvuosi ja loppuvuosi \nkunnallisvero_muokkaus = function(kunnallisvero,asukaskerroin,veroprosentti) {\n  return kunnallisvero*asukaskerroin*veroprosentti;\n}\n\n//Tekstimuutokset\nfn_nousu_lasku_txt = function(arvo){\n  if(arvo &gt; 0) {\n  return \"kasvanut\" \n  }\n  else { \n  return \"laskenut\";\n  }\n}\n\n//TARVITAAN KARTOISSA\nserialize = {\n  const xmlns = \"http://www.w3.org/2000/xmlns/\";\n  const xlinkns = \"http://www.w3.org/1999/xlink\";\n  const svgns = \"http://www.w3.org/2000/svg\";\n  return function serialize(svg) {\n    svg = svg.cloneNode(true);\n    const fragment = window.location.href + \"#\";\n    const walker = document.createTreeWalker(svg, NodeFilter.SHOW_ELEMENT);\n    while (walker.nextNode()) {\n      for (const attr of walker.currentNode.attributes) {\n        if (attr.value.includes(fragment)) {\n          attr.value = attr.value.replace(fragment, \"#\");\n        }\n      }\n    }\n    svg.setAttributeNS(xmlns, \"xmlns\", svgns);\n    svg.setAttributeNS(xmlns, \"xmlns:xlink\", xlinkns);\n    const serializer = new window.XMLSerializer;\n    const string = serializer.serializeToString(svg);\n    return new Blob([string], {type: \"image/svg+xml\"});\n  };\n}\n\n\nfunction toSVG(chart) {\n  if (chart.nodeName !== \"FIGURE\") {\n    return chart;\n  }\n\n  // the chart needs to be in the body if we want to read values, positions, sizes…\n  document.body.appendChild(chart);\n  const [x0, y0, width, height] = getBounds([chart]);\n\n  const nodes = [];\n\n  for (const node of d3\n    .select(chart)\n    .selectChildren(\"h1,h2,h3,div,figcaption,svg\")) {\n    switch (node.nodeName.toLowerCase()) {\n      case \"div\":\n        {\n          const children = d3.select(node).selectChildren(\"div,span\");\n          const height = getBounds([node, ...children])[3] + 2;\n          const svg = d3\n            .select(chart)\n            .append(\"svg\")\n            .attr(\"width\", width)\n            .attr(\"height\", height);\n          nodes.push(svg.node());\n\n          const swatches = svg\n            .selectAll()\n            .data(\n              Array.from(children, (d) =&gt; {\n                const svg = d3.select(d).select(\"svg\").node();\n                const bbox = svg.getBBox();\n                return {\n                  style: window.getComputedStyle(d),\n                  svg,\n                  width: bbox.width,\n                  height: bbox.height,\n                  text: d.textContent,\n                  bounds: getBounds([d])\n                };\n              })\n            )\n            .join(\"g\")\n            .attr(\n              \"transform\",\n              (d) =&gt; `translate(${d.bounds[0] - x0},${10 + d.bounds[1] - y0})`\n            );\n\n          swatches\n            .append((d) =&gt; d.svg) // \"rect\")\n            .attr(\"width\", (d) =&gt; d.width)\n            .attr(\"height\", (d) =&gt; d.height)\n            .attr(\"y\", (d) =&gt; `${-parseFloat(d.height) / 2}px`);\n          swatches\n            .append(\"text\")\n            .text((d) =&gt; d.text)\n            .attr(\"x\", (d) =&gt; d.width)\n            .attr(\"dx\", 5)\n            .attr(\"dy\", \"0.38em\")\n            .attr(\"font-family\", (d) =&gt; d.style.fontFamily)\n            .attr(\"font-size\", (d) =&gt; d.style.fontSize)\n            .attr(\"fill\", (d) =&gt; d.style.color);\n        }\n        break;\n      case \"figcaption\":\n      case \"h1\":\n      case \"h2\":\n      case \"h3\":\n        {\n          const svg = d3\n            .select(chart)\n            .append(\"svg\")\n            .attr(\"width\", width)\n            .attr(\"overflow\", \"visible\");\n          nodes.push(svg.node());\n\n          const children = d3.select(node).selectChildren();\n\n          let h = 0;\n          for (const d of children.size() &gt; 0\n            ? children.selectChildren()\n            : [node]) {\n            const style = window.getComputedStyle(d);\n            const t = svg\n              .append(\"g\")\n              .attr(\"transform\", `translate(0,${h})`)\n              .append(() =&gt;\n                d3\n                  .select(\n                    Plot.text([d.textContent], {\n                      text: (d) =&gt; d,\n                      lineWidth:\n                        (1.06 * parseFloat(style.width)) /\n                        parseFloat(style.fontSize),\n                      lineHeight: 1.2,\n                      frameAnchor: \"top-left\"\n                    }).plot()\n                  )\n                  .select(\"text\")\n                  .attr(\"font-family\", style.fontFamily)\n                  .attr(\"font-size\", 1.08 * parseFloat(style.fontSize))\n                  .attr(\"font-weight\", style.fontWeight)\n                  .attr(\"fill\", style.color)\n                  .node()\n              );\n            h += getBounds([t.node()])[3] + 4;\n          }\n          svg.attr(\"height\", h);\n        }\n        break;\n      case \"svg\":\n        d3.select(chart).append(() =&gt; node);\n        nodes.push(node);\n        break;\n    }\n  }\n\n  return serializeAll(nodes)\n    .then((blob) =&gt; blob.text())\n    .then((c) =&gt; {\n      document.body.removeChild(chart);\n      return Object.assign(svg`${c}`, chart);\n    });\n}\n\n\n// Given an array of SVG elements, composites them into a single SVG element,\n// and then serializes the result to a blob.\nasync function serializeAll(elements, {padding = 10} = {}) {\n  const fragment = location.href + \"#\";\n  let root;\n  if (elements.length === 1) {\n    root = elements[0].cloneNode(true); // optimize common case\n  } else {\n    const [ox, oy, dx, dy] = getBounds(elements);\n    root = document.createElementNS(svgns, \"svg\");\n    root.setAttribute(\"width\", dx + 2 * padding);\n    root.setAttribute(\"height\", dy + 2 * padding);\n    root.setAttribute(\"viewBox\", [-padding, -padding, dx + 2 * padding, dy + 2 * padding]);\n    for (const element of elements) {\n      const svg = root.appendChild(element.cloneNode(true));\n      const { x, y, width, height } = element.getBoundingClientRect();\n      svg.setAttribute(\"x\", x - ox);\n      svg.setAttribute(\"y\", y - oy);\n      svg.setAttribute(\"width\", width);\n      svg.setAttribute(\"height\", height);\n    }\n  }\n  const walker = document.createTreeWalker(root, NodeFilter.SHOW_ELEMENT);\n  while (walker.nextNode()) {\n    const node = walker.currentNode;\n    for (const attr of node.attributes) {\n      if (attr.value.includes(fragment)) {\n        attr.value = attr.value.replace(fragment, \"#\");\n      }\n    }\n  }\n  root.setAttributeNS(xmlns, \"xmlns\", svgns);\n  root.setAttributeNS(xmlns, \"xmlns:xlink\", xlinkns);\n  const serializer = new XMLSerializer();\n  const string = serializer.serializeToString(root);\n  return new Blob([string], { type: \"image/svg+xml\" });\n}\n\n\nfunction getBounds(elements) {\n  let x1 = Infinity;\n  let y1 = x1;\n  let x2 = -x1;\n  let y2 = x2;\n  for (const element of elements) {\n    const { x, y, width, height } = element.getBoundingClientRect();\n    if (x &lt; x1) x1 = x;\n    if (x + width &gt; x2) x2 = x + width;\n    if (y &lt; y1) y1 = y;\n    if (y + height &gt; y2) y2 = y + height;\n  }\n  return [x1, y1, x2 - x1, y2 - y1];\n}\n\n// based on https://observablehq.com/@gka/cheap-fit-text-to-circle\nfunction lines(text, targetWidth) {\n  const CHAR_W = {\n    \"a\":7,\"B\":8,\"C\":8,\"c\":6,\"D\":9,\"f\":4,\"G\":9,\"H\":9,\"I\":3,\"i\":3,\"J\":5,\"j\":3,\"K\":8,\"k\":6,\n    \"l\":3,\"M\":11,\"m\":11,\"N\":9,\"O\":9,\"P\":8,\"Q\":9,\"R\":8,\"r\":4,\"S\":8,\"s\":6,\"t\":4,\"U\":9,\"v\":6,\n    \"W\":11,\"w\":9,\"x\":6,\"y\":6,\"z\":5,\".\":2,\",\":2,\":\":2,\";\":2\n  };\n  function measureWidth(text) { return  d3.sum(text, char =&gt; CHAR_W[char] || CHAR_W[\"a\"]) * 0.8; };\n\n  const words = text.split(\" \");\n  let line;\n  let lineWidth0 = Infinity;\n  const lines = [];\n  for (let i = 0, n = words.length; i &lt; n; ++i) {\n    let lineText1 = (line ? line.text + \" \" : \"\") + words[i];\n    let lineWidth1 = measureWidth(lineText1);\n    if ((lineWidth0 + lineWidth1) / 2 &lt; targetWidth) {\n      line.width = lineWidth0 = lineWidth1;\n      line.text = lineText1;\n    } else {\n      lineWidth0 = measureWidth(words[i]);\n      line = {width: lineWidth0, text: words[i]};\n      lines.push(line);\n    }\n  }\n  return lines;\n}\n\nxmlns = \"http://www.w3.org/2000/xmlns/\"\n\nxlinkns = \"http://www.w3.org/1999/xlink\"\n\nsvgns = \"http://www.w3.org/2000/svg\"\nfunction Legend(color, {\n  title,\n  tickSize = 6,\n  width = 320, \n  height = 44 + tickSize,\n  marginTop = 18,\n  marginRight = 0,\n  marginBottom = 16 + tickSize,\n  marginLeft = 0,\n  ticks = width / 64,\n  tickFormat,\n  tickValues\n} = {}) {\n\n  function ramp(color, n = 256) {\n    const canvas = document.createElement(\"canvas\");\n    canvas.width = n;\n    canvas.height = 1;\n    const context = canvas.getContext(\"2d\");\n    for (let i = 0; i &lt; n; ++i) {\n      context.fillStyle = color(i / (n - 1));\n      context.fillRect(i, 0, 1, 1);\n    }\n    return canvas;\n  }\n\n  const svg = d3.create(\"svg\")\n      .attr(\"width\", width)\n      .attr(\"height\", height)\n      .attr(\"viewBox\", [0, 0, width, height])\n      .style(\"overflow\", \"visible\")\n      .style(\"display\", \"block\");\n\n  let tickAdjust = g =&gt; g.selectAll(\".tick line\").attr(\"y1\", marginTop + marginBottom - height);\n  let x;\n\n  // Continuous\n  if (color.interpolate) {\n    const n = Math.min(color.domain().length, color.range().length);\n\n    x = color.copy().rangeRound(d3.quantize(d3.interpolate(marginLeft, width - marginRight), n));\n\n    svg.append(\"image\")\n        .attr(\"x\", marginLeft)\n        .attr(\"y\", marginTop)\n        .attr(\"width\", width - marginLeft - marginRight)\n        .attr(\"height\", height - marginTop - marginBottom)\n        .attr(\"preserveAspectRatio\", \"none\")\n        .attr(\"xlink:href\", ramp(color.copy().domain(d3.quantize(d3.interpolate(0, 1), n))).toDataURL());\n  }\n\n  // Sequential\n  else if (color.interpolator) {\n    x = Object.assign(color.copy()\n        .interpolator(d3.interpolateRound(marginLeft, width - marginRight)),\n        {range() { return [marginLeft, width - marginRight]; }});\n\n    svg.append(\"image\")\n        .attr(\"x\", marginLeft)\n        .attr(\"y\", marginTop)\n        .attr(\"width\", width - marginLeft - marginRight)\n        .attr(\"height\", height - marginTop - marginBottom)\n        .attr(\"preserveAspectRatio\", \"none\")\n        .attr(\"xlink:href\", ramp(color.interpolator()).toDataURL());\n\n    // scaleSequentialQuantile doesn’t implement ticks or tickFormat.\n    if (!x.ticks) {\n      if (tickValues === undefined) {\n        const n = Math.round(ticks + 1);\n        tickValues = d3.range(n).map(i =&gt; d3.quantile(color.domain(), i / (n - 1)));\n      }\n      if (typeof tickFormat !== \"function\") {\n        tickFormat = d3.format(tickFormat === undefined ? \",f\" : tickFormat);\n      }\n    }\n  }\n\n  // Threshold\n  else if (color.invertExtent) {\n    const thresholds\n        = color.thresholds ? color.thresholds() // scaleQuantize\n        : color.quantiles ? color.quantiles() // scaleQuantile\n        : color.domain(); // scaleThreshold\n\n    const thresholdFormat\n        = tickFormat === undefined ? d =&gt; d\n        : typeof tickFormat === \"string\" ? d3.format(tickFormat)\n        : tickFormat;\n\n    x = d3.scaleLinear()\n        .domain([-1, color.range().length - 1])\n        .rangeRound([marginLeft, width - marginRight]);\n\n    svg.append(\"g\")\n      .selectAll(\"rect\")\n      .data(color.range())\n      .join(\"rect\")\n        .attr(\"x\", (d, i) =&gt; x(i - 1))\n        .attr(\"y\", marginTop)\n        .attr(\"width\", (d, i) =&gt; x(i) - x(i - 1))\n        .attr(\"height\", height - marginTop - marginBottom)\n        .attr(\"fill\", d =&gt; d);\n\n    tickValues = d3.range(thresholds.length);\n    tickFormat = i =&gt; thresholdFormat(thresholds[i], i);\n  }\n\n  // Ordinal\n  else {\n    x = d3.scaleBand()\n        .domain(color.domain())\n        .rangeRound([marginLeft, width - marginRight]);\n\n    svg.append(\"g\")\n      .selectAll(\"rect\")\n      .data(color.domain())\n      .join(\"rect\")\n        .attr(\"x\", x)\n        .attr(\"y\", marginTop)\n        .attr(\"width\", Math.max(0, x.bandwidth() - 1))\n        .attr(\"height\", height - marginTop - marginBottom)\n        .attr(\"fill\", color);\n\n    tickAdjust = () =&gt; {};\n  }\n\n  svg.append(\"g\")\n      .attr(\"transform\", `translate(0,${height - marginBottom})`)\n      .call(d3.axisBottom(x)\n        .ticks(ticks, typeof tickFormat === \"string\" ? tickFormat : undefined)\n        .tickFormat(typeof tickFormat === \"function\" ? tickFormat : undefined)\n        .tickSize(tickSize)\n        .tickValues(tickValues))\n      .call(tickAdjust)\n      .call(g =&gt; g.select(\".domain\").remove())\n      .call(g =&gt; g.append(\"text\")\n        .attr(\"x\", marginLeft)\n        .attr(\"y\", marginTop + marginBottom - height - 6)\n        .attr(\"fill\", \"currentColor\")\n        .attr(\"text-anchor\", \"start\")\n        .attr(\"font-weight\", \"bold\")\n        .style(\"font-size\", \"12px\")\n        .attr(\"class\", \"title\")\n        .text(title));\n\n  return svg.node();\n}\n\n\nfunction legend({color, ...options}) {\n  return Legend(color, options);\n}\n\n\n// Copyright 2021, Observable Inc.\n// Released under the ISC license.\n// https://observablehq.com/@d3/color-legend\nfunction Swatches(color, {\n  columns = null,\n  format,\n  unknown: formatUnknown,\n  swatchSize = 15,\n  swatchWidth = swatchSize,\n  swatchHeight = swatchSize,\n  marginLeft = 0\n} = {}) {\n  const id = `-swatches-${Math.random().toString(16).slice(2)}`;\n  const unknown = formatUnknown == null ? undefined : color.unknown();\n  const unknowns = unknown == null || unknown === d3.scaleImplicit ? [] : [unknown];\n  const domain = color.domain().concat(unknowns);\n  if (format === undefined) format = x =&gt; x === unknown ? formatUnknown : x;\n\n  function entity(character) {\n    return `&#${character.charCodeAt(0).toString()};`;\n  }\n\n  if (columns !== null) return htl.html`&lt;div style=\"display: flex; align-items: center; margin-left: ${+marginLeft}px; min-height: 33px; font: 12px sans-serif;\"&gt;\n  &lt;style&gt;\n\n.${id}-item {\n  break-inside: avoid;\n  display: flex;\n  align-items: center;\n  padding-bottom: 1px;\n}\n\n.${id}-label {\n  white-space: nowrap;\n  overflow: hidden;\n  text-overflow: ellipsis;\n  max-width: calc(100% - ${+swatchWidth}px - 0.5em);\n}\n\n.${id}-swatch {\n  width: ${+swatchWidth}px;\n  height: ${+swatchHeight}px;\n  margin: 0 0.5em 0 0;\n}\n\n  &lt;/style&gt;\n  &lt;div style=${{width: \"100%\", columns}}&gt;${domain.map(value =&gt; {\n    const label = `${format(value)}`;\n    return htl.html`&lt;div class=${id}-item&gt;\n      &lt;div class=${id}-swatch style=${{background: color(value)}}&gt;&lt;/div&gt;\n      &lt;div class=${id}-label title=${label}&gt;${label}&lt;/div&gt;\n    &lt;/div&gt;`;\n  })}\n  &lt;/div&gt;\n&lt;/div&gt;`;\n\n  return htl.html`&lt;div style=\"display: flex; align-items: center; min-height: 33px; margin-left: ${+marginLeft}px; font: 12px sans-serif;\"&gt;\n  &lt;style&gt;\n\n.${id} {\n  display: inline-flex;\n  align-items: center;\n  margin-right: 1em;\n}\n\n.${id}::before {\n  content: \"\";\n  width: ${+swatchWidth}px;\n  height: ${+swatchHeight}px;\n  margin-right: 0.5em;\n  background: var(--color);\n}\n\n  &lt;/style&gt;\n  &lt;div&gt;${domain.map(value =&gt; htl.html`&lt;span class=\"${id}\" style=\"--color: ${color(value)}\"&gt;${format(value)}&lt;/span&gt;`)}&lt;/div&gt;`;\n}\n\nfunction swatches({color, ...options}) {\n  return Swatches(color, options);\n}\nchart_map_d3 = function(data, mapTopoJSON, color, colorBorder, txtTitle, chart_width, chart_height) {\n\n  const projection = d3.geoMercator()\n  .scale(1200)\n  //.center([40, 67.5])\n  .center([40, 67.3])\n  .translate([400, 220])\n  const path = d3.geoPath().projection(projection);\n  const format = d =&gt; `${d}%`;\n  \n  //Määritellään tähän muuttujat CSV:stä!!!!!!\n  const valuemap = new Map(data.map(d =&gt; [d.id, d.muutos]));\n  \n  //Määritellään maakunnat\n  const maakuntamesh = topojson.mesh(maakunnat_2024_topo, maakunnat_2024_topo.objects.maakunnat_2024, (a, b) =&gt; a !== b);\n  \n  const zoom = d3.zoom()\n      .scaleExtent([1, 8])\n      .on(\"zoom\", zoomed);\n\n  const svg = d3.create(\"svg\")\n      .attr(\"width\", 900)\n      .attr(\"height\", 650)\n      .attr(\"viewBox\", [0, 0, 900, 650])\n      .on(\"click\", reset);\n      \n  const g = svg.append(\"g\")\n      .attr(\"transform\", \"translate(20,35)\")\n      .append(() =&gt; Legend(color, {title: txtTitle, width: 260}));\n\n  g.append(\"g\")\n    .selectAll(\"path\")\n    .data(mapTopoJSON)\n    .join(\"path\")\n      .attr(\"fill\", d =&gt; color(valuemap.get(d.properties.kunta))) \n      .attr(\"d\", path)\n    .append(\"title\")\n      .text(d =&gt; `${d.properties.name},\\n(${d.properties.nimi_2}),\\n${valuemap.get(d.properties.kunta)}`);\n      \n  g.append(\"path\")\n      .datum(maakuntamesh)\n      .attr(\"fill\", \"none\")\n      .attr(\"stroke\", colorBorder)\n      .attr(\"stroke-linejoin\", \"round\")\n      .attr(\"d\", path);\n      \n   svg.call(zoom);\n   \n\n  function reset() {\n    // states.transition().style(\"fill\", null);\n    svg.transition().duration(750).call(\n      zoom.transform,\n      d3.zoomIdentity,\n      d3.zoomTransform(svg.node()).invert([chart_width / 2, chart_height / 2])\n    );\n  }\n\n  function zoomed(event) {\n    const {transform} = event;\n    g.attr(\"transform\", transform);\n    g.attr(\"stroke-width\", 1 / transform.k);\n  }     \n      \n  return svg.node();\n}\nchart_chord_d3 = function(data, title_txt_chord, chart_width, chart_height) {\n\n  var sum_target;\n  var sum_source;\n  let vari;\n  var sum_yht;\n  \n  const margin = ({top: 20, right: 20, bottom: 0, left: 50});\n  const width = 300;\n  const height = width;\n  const innerRadius = Math.min(width, height) * .3 - 40;\n  const outerRadius = innerRadius + 15;\n  \n  \n  const chord = d3.chordDirected()\n    .padAngle(0.5 / innerRadius)\n    .sortSubgroups(d3.ascending)\n    .sortChords(d3.ascending);\n    \n  const ribbon = d3.ribbon()\n    .radius(innerRadius - 1)\n    .padAngle(0.5 / innerRadius);\n    \n  const rename = name =&gt; name.substring(name.indexOf(\".\") + 1, name.lastIndexOf(\".\"))\n  const names = Array.from(new Set(data.flatMap(d =&gt; [d.source, d.target]))).sort(d3.ascending);\n  \n  function matriisi(names) {\n    const index = new Map(names.map((name, i) =&gt; [name, i]));\n    const matrix = Array.from(index, () =&gt; new Array(names.length).fill(0));\n    for (const {source, target, value} of data) matrix[index.get(source)][index.get(target)] += value;\n    return matrix;\n  }\n\n const matrix = matriisi(names)\n  \n const arc = d3.arc()\n    .innerRadius(innerRadius)\n    .outerRadius(outerRadius)\n\n  //TÄSTÄ ALKAA PIIRROS\n  \n  const zoom = d3.zoom()\n      .scaleExtent([1, 8])\n      .on(\"zoom\", zoomed);\n  \n  const svg = d3.create(\"svg\")\n      .attr(\"viewBox\", [-width / 2, -height / 2.5, width, height]);\n\n  const chords = chord(matrix);\n  \n  const group = svg.append(\"g\")\n      .attr(\"font-size\", 3)\n      .attr(\"font-family\", \"Century Gothic\")\n    .selectAll(\"g\")\n    .data(chords.groups)\n    .join(\"g\");\n\n  group.append(\"path\")\n      .attr(\"fill\", d =&gt; {\n           sum_target = d3.sum(chords, c =&gt; (c.target.index === d.index) * c.target.value);\n           sum_source = d3.sum(chords, c =&gt; (c.source.index === d.index) * c.source.value);\n           sum_yht = sum_target-sum_source;\n            if (sum_yht &gt; 0) { \n              vari = \"#009651\"\n              return vari \n            }\n            else if (sum_yht == 0) { \n              vari = \"#28336C\"\n              return vari \n            }\n            else    { \n              vari = \"#DE232F\" \n              return vari \n            }\n        })\n      .attr(\"d\", arc);\n\n  group.append(\"text\")\n      .each(d =&gt; (d.angle = (d.startAngle + d.endAngle) / 2))\n      .attr(\"dy\", \"0.35em\")\n      .attr(\"transform\", d =&gt; `\n        rotate(${(d.angle * 180 / Math.PI - 90)})\n        translate(${outerRadius + 6})\n        ${d.angle &gt; Math.PI ? \"rotate(180)\" : \"\"}\n      `)\n      .attr(\"text-anchor\", d =&gt; d.angle &gt; Math.PI ? \"end\" : null)\n      //.text(d =&gt; names[d.index])\n      .text(d =&gt; (d.index &gt;= 3) ? names[d.index] : \"\")\n      .attr(\"fill\", d =&gt; {\n           sum_target = d3.sum(chords, c =&gt; (c.target.index === d.index) * c.target.value);\n           sum_source = d3.sum(chords, c =&gt; (c.source.index === d.index) * c.source.value);\n           sum_yht = sum_target-sum_source;\n            if (sum_yht &gt; 0) { \n              vari = \"#009651\"\n              return vari\n            }\n            else if (sum_yht == 0) { \n              vari = \"#28336C\"\n              return vari \n            }\n            else    { \n              vari = \"#DE232F\" \n              return vari \n            }\n        });\n\n  group.append(\"title\")\n      .text(d =&gt; `${names[d.index]} \n\n${d3.sum(chords, c =&gt; (c.source.index === d.index) * c.source.value)} lähtee →\n${d3.sum(chords, c =&gt; (c.target.index === d.index) * c.source.value)} tulee ←\n${d3.sum(chords, c =&gt; (c.target.index === d.index) * c.target.value)- d3.sum(chords, c =&gt; (c.source.index === d.index) * c.source.value)} netto =`);  \n\n  svg.append(\"g\")\n      .attr(\"fill-opacity\", 0.75)\n    .selectAll(\"path\")\n    .data(chords)\n    .join(\"path\")\n      .style(\"mix-blend-mode\", \"multiply\")\n          .attr(\"fill\", d =&gt; {\n           sum_target = d3.sum(chords, c =&gt; (c.target.index === d.index) * c.target.value);\n           sum_source = d3.sum(chords, c =&gt; (c.source.index === d.index) * c.source.value);\n           sum_yht = sum_target-sum_source;\n            if (sum_yht &gt; 0) { \n              vari = \"#009651\"\n              return vari \n            }\n            else if (sum_yht == 0) { \n              vari = \"#28336C\"\n              return vari \n            }\n            else    { \n              vari = \"#DE232F\" \n              return vari \n            }\n        })\n      .attr(\"d\", ribbon)\n    .append(\"title\")\n      .text(d =&gt; `${names[d.source.index]} --&gt; ${names[d.target.index]} ${d.source.value}`);\n      \n      \n  svg.call(zoom);\n   \n\n  function reset() {\n    // states.transition().style(\"fill\", null);\n    svg.transition().duration(750).call(\n      zoom.transform,\n      d3.zoomIdentity,\n      d3.zoomTransform(svg.node()).invert([chart_width / 2, chart_height / 2])\n    );\n  }\n\n  function zoomed(event) {\n    const {transform} = event;\n    svg.attr(\"transform\", transform);\n    svg.attr(\"stroke-width\", 1 / transform.k);\n  }    \n\n  return svg.node();\n\n\n}"
  },
  {
    "objectID": "verotus.html#väestönmuutokset---väestöennakko-kolme-ikäluokkaa",
    "href": "verotus.html#väestönmuutokset---väestöennakko-kolme-ikäluokkaa",
    "title": "Verotus",
    "section": "Väestönmuutokset - Väestöennakko, kolme ikäluokkaa",
    "text": "Väestönmuutokset - Väestöennakko, kolme ikäluokkaa\nKuntaliitto käyttää kunnallisveron perustana kolmea ikäluokkaa. Ikäluokittelu huomioi palkansaajat ja eläkeläiset.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nVuosi\nYhteensä\n0-18\n0-18 %\n19-64\n19-64 %\n65+\n65+ %\n\n\n\n\n2000\n4189\n1168\n27.88\n2451\n58.51\n570\n13.61\n\n\n2001\n4203\n1160\n27.60\n2469\n58.74\n574\n13.66\n\n\n2002\n4269\n1165\n27.29\n2532\n59.31\n572\n13.40\n\n\n2003\n4333\n1180\n27.23\n2562\n59.13\n591\n13.64\n\n\n2004\n4425\n1202\n27.16\n2617\n59.14\n606\n13.69\n\n\n2005\n4518\n1239\n27.42\n2669\n59.07\n610\n13.50\n\n\n2006\n4633\n1282\n27.67\n2712\n58.54\n639\n13.79\n\n\n2007\n4763\n1330\n27.92\n2788\n58.53\n645\n13.54\n\n\n2008\n4809\n1340\n27.86\n2809\n58.41\n660\n13.72\n\n\n2009\n4824\n1334\n27.65\n2819\n58.44\n671\n13.91\n\n\n2010\n4865\n1328\n27.30\n2854\n58.66\n683\n14.04\n\n\n2011\n4814\n1292\n26.84\n2808\n58.33\n714\n14.83\n\n\n2012\n4846\n1289\n26.60\n2822\n58.23\n735\n15.17\n\n\n2013\n4872\n1302\n26.72\n2807\n57.61\n763\n15.66\n\n\n2014\n4844\n1282\n26.47\n2772\n57.23\n790\n16.31\n\n\n2015\n4859\n1290\n26.55\n2751\n56.62\n818\n16.83\n\n\n2016\n4815\n1245\n25.86\n2730\n56.70\n840\n17.45\n\n\n2017\n4813\n1240\n25.76\n2679\n55.66\n894\n18.57\n\n\n2018\n4733\n1188\n25.10\n2628\n55.53\n917\n19.37\n\n\n2019\n4715\n1167\n24.75\n2594\n55.02\n954\n20.23\n\n\n2020\n4693\n1141\n24.31\n2583\n55.04\n969\n20.65\n\n\n2021\n4689\n1150\n24.53\n2558\n54.55\n981\n20.92\n\n\n2022\n4644\n1127\n24.27\n2534\n54.57\n983\n21.17\n\n\n2023\n4695\n1130\n24.07\n2567\n54.68\n998\n21.26\n\n\n2024M08*\n4664\n1091\n23.39\n2557\n54.82\n1016\n21.78\n\n\n\n\n\n\n\n\nVäestökehityksen muutos - kolme ikäluokkaa\n\n0-18-vuotiaat\nIkäluokkien kehitystä aikaisempiin vuosiin vertailtaessa 0-18-vuotiaiden %-osuus oli 2024M08* yhteensä 23.39. Jos verrataan lukemaa kahteen edellisvuoteen 2022 ja 2023, muutosta on tullut -0.88 (2022) ja -0.68 (2023)\n\n\n19-64-vuotiaat\n19-64-vuotiaiden palkansaajien %-osuus oli 2024M08* yhteensä 54.82. Edellisvuosiin 2022 ja 2023 verrattuna, muutosta on tullut 0.25 (2022) ja 0.14 (2023)\n\n\n65+-vuotiaat\n65+-vuotiaiden eläkeläisten prosenttiosuus kokonaisuudesta oli 2024M08* yhteensä 21.78. Edellisvuosiin 2022 ja 2023 verrattuna, muutosta on tullut 0.61 (2022) ja 0.52 (2023 )"
  },
  {
    "objectID": "verotus.html#ansiotulot",
    "href": "verotus.html#ansiotulot",
    "title": "Verotus",
    "section": "Ansiotulot",
    "text": "Ansiotulot\nTilasto sisältää tuloverotuksen valmistumisen mukaiset tiedot kaikista henkilöasiakkaista. Tilastossa ei huomioida muutosverotuksen tietoja. Lähde: (Vero.fi 2024a)\n\n\n\n\n\n\n\n\nVuosi\nPalkkatulot\nPM %\nEläketulot\nEM %\nTyottomyysturva\nTM %\nMuut sos.turva\nMM %\nMaa- ja metsätalous\nMTM %\nElinkeinotoiminta\nELM %\nAnsiotulot\nAM %\n\n\n\n\n2014\n71,000\nNA\n19,235\nNA\n3,057\nNA\n2,603\nNA\n1,812\nNA\n6,146\nNA\n103,854\nNA\n\n\n2015\n70,779\n-0.31\n20,293\n5.50\n3,209\n4.97\n2,683\n3.07\n1,500\n-17.22\n5,955\n-3.11\n104,422\n0.55\n\n\n2016\n72,467\n2.38\n21,169\n4.32\n3,114\n-2.96\n2,160\n-19.49\n1,647\n9.80\n6,338\n6.43\n106,898\n2.37\n\n\n2017\n73,823\n1.87\n22,147\n4.62\n2,516\n-19.20\n2,167\n0.32\n1,806\n9.65\n6,127\n-3.33\n108,587\n1.58\n\n\n2018\n76,482\n3.60\n22,782\n2.87\n1,895\n-24.68\n2,122\n-2.08\n1,402\n-22.37\n5,841\n-4.67\n110,526\n1.79\n\n\n2019\n78,327\n2.41\n23,763\n4.31\n1,626\n-14.20\n2,038\n-3.96\n1,446\n3.14\n5,760\n-1.39\n112,963\n2.20\n\n\n2020\n77,965\n-0.46\n24,665\n3.80\n2,621\n61.19\n2,161\n6.04\n1,468\n1.52\n5,974\n3.72\n114,856\n1.68\n\n\n2021\n80,100\n2.74\n25,083\n1.69\n2,275\n-13.20\n2,750\n27.26\n1,241\n-15.46\n5,838\n-2.28\n117,289\n2.12\n\n\n2022\n83,988\n4.85\n26,002\n3.66\n1,704\n-25.10\n2,717\n-1.20\n1,838\n48.11\n5,958\n2.06\n122,209\n4.19\n\n\n\n\n\n\n\n\nAnsiotulojen kehitys\nPalkkatulot olivat vuonna 2022 yhteensä 83,988. Muutos edelliseen 2021 vuoteen oli 4.85. Eläketulojen osalta muutos oli 3.66 (3.66)"
  },
  {
    "objectID": "verotus.html#vähennykset",
    "href": "verotus.html#vähennykset",
    "title": "Verotus",
    "section": "Vähennykset",
    "text": "Vähennykset\nTilaston vähennyseristä yleisesti: Jos verovelvolliselle ei ole määrätty verotettavasta tulosta veroja tai niiden määrä on pienempi kuin verosta myönnetty vähennys, myönnettyä vähennystä ei ole voitu vähentää kokonaisuudessaan. Tällaisissa tilanteissa verotuksessa vähennetty määrä on pienempi kuin myönnetty määrä. Sama periaate pätee myös tuloista tehtävien vähennysten osalta.\n*Lyhenteet:\n\nPV % = Palkansaajan vakuutusmaksujen %-osuus palkoista\n\nE % = Eläketulovähennyksen %-osuus eläkkeistä\n\nA % = Vuosittainen muutos ansiotulot-vähennykset*\nLähde: (Vero.fi 2024a)\n\n\n\n\n\n\n\n\nVuosi\nPalkansaajan vak.maksut\nPV %\nVähennetyt matkakustan.\nMuut tulonhankk.vähenn.\nEläketulovähennys\nE %\nAnsiotulovähennys\nPerusvähennys\nMuut vähennykset\nVähennykset yht.\nVäh.aste\nAnsiotulot-vähennykset\nA %\n\n\n\n\n2014\n32,996\n7.02\n10,515\n14,740\n29,894\n20.78\n34,333\n13,521\n1,159\n137,158\n20.01\n548,401\nNA\n\n\n2015\n34,527\n7.20\n9,663\n15,031\n31,569\n21.34\n33,811\n14,496\n1,209\n140,305\n20.08\n558,317\n1.81\n\n\n2016\n37,558\n7.62\n9,287\n15,269\n31,180\n20.49\n33,660\n14,817\n1,096\n142,869\n19.94\n573,608\n2.74\n\n\n2017\n46,674\n9.22\n9,407\n17,463\n32,019\n20.25\n34,672\n15,623\n1,059\n156,917\n21.42\n575,774\n0.38\n\n\n2018\n51,373\n9.63\n10,193\n17,864\n31,643\n19.43\n35,250\n16,020\n1,076\n163,418\n21.46\n598,104\n3.88\n\n\n2019\n53,812\n9.62\n10,487\n18,326\n31,213\n18.49\n35,593\n17,848\n1,071\n168,349\n21.25\n624,002\n4.33\n\n\n2020\n52,738\n9.44\n9,383\n18,754\n31,925\n18.16\n34,895\n20,412\n1,174\n169,282\n21.00\n636,792\n2.05\n\n\n2021\n57,807\n9.72\n9,954\n19,457\n32,234\n17.85\n35,216\n21,438\n1,109\n177,215\n20.92\n669,775\n5.18\n\n\n2022\n61,446\n9.61\n12,921\n19,888\n34,528\n18.46\n36,330\n22,239\n1,101\n188,453\n21.02\n708,271\n5.75"
  },
  {
    "objectID": "verotus.html#kiinteistövero",
    "href": "verotus.html#kiinteistövero",
    "title": "Verotus",
    "section": "Kiinteistövero",
    "text": "Kiinteistövero\nKunnan alueella sijaitsevista kiinteistöistä maksuunpantu kiinteistövero tilitetään kokonaisuudessaan kyseiselle kunnalle. Tilaston avulla voi arvioida kunnan kiinteistöverotuottojen suuruutta. Tilastoluvut eivät kuitenkaan kerro aivan tarkasti kunnille todellisuudessa tilitetyistä kiinteistöverotuotoista, koska maksuunpannun kiinteistöveron määrä voi muuttua muutosverotuksen myötä ja nämä muutokset eivät päivity tilastolukuihin. Lisäksi maksuunpantua kiinteistöveroa ei välttämättä saada kokonaisuudessaan kerättyä. Lähde: (Vero.fi 2024b)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nVuosi\nYhteensä\nLukumäärä\nMuutos %\n\n\n\n\n2014\n805,185\n3144\nNA\n\n\n2015\n870,606\n3166\n8.12\n\n\n2016\n881,949\n3178\n1.30\n\n\n2017\n864,175\n3201\n-2.02\n\n\n2018\n864,697\n3204\n0.06\n\n\n2019\n878,977\n3202\n1.65\n\n\n2020\n877,334\n3221\n-0.19\n\n\n2021\n866,283\n3229\n-1.26\n\n\n2022\n913,407\n3248\n5.44\n\n\n2023\n966,866\n3249\n5.85\n\n\n2024 (ennakkotieto)\n1,156,687\n3256\n19.63\n\n\n\n\n\n\n\n\nKiinteistöverojen kehitys\nKiinteistöverojen määrä oli vuonna 2024 (ennakkotieto) yhteensä 1,156,687. Muutos edelliseen vuoteen 2023 oli 19.63."
  },
  {
    "objectID": "tyollisyys.html",
    "href": "tyollisyys.html",
    "title": "Työllisyys",
    "section": "",
    "text": "d3 = require(\"d3@7\")\n//import {Legend} from \"@d3/color-legend\"\n\nfolderKunnat24TopoJSON = \"./maps/Kunnat2024Topo.json\"\nkunnat2024topo = FileAttachmentDynamic(folderKunnat24TopoJSON).json()\nmapTopoJSON = topojson.feature(kunnat2024topo, kunnat2024topo.objects.Kunnat2024_geo).features\n\n\nfolderMaakunnat24TopoJSON = \"./maps/Maakunnat2024Topo.json\"\nmaakunnat_2024_topo =  FileAttachmentDynamic(folderMaakunnat24TopoJSON).json()\nFileAttachmentDynamic = function(filename) {\n  return new Function(\"FileAttachment\", `return FileAttachment(\"${filename}\")`)(FileAttachment)\n}\n\n// Vaihdetaan tekstin väri\ncolor = function(vari) {\n  if(vari &gt; 0){\n      return \"green\"\n    }else{\n      return \"red\"\n    }\n}\n// Pyöristys\npyoristys = function(n, places) {\n  if (!places) return Math.round(n);\n  const d = 10 ** places;\n  return Math.round(n * d) / d;\n}\n//Euromerkintä\neurot = function(number) {\n  return number.toLocaleString('fi-FI', { style: 'currency', currency: 'EUR',minimumFractionDigits: 0 });\n}\n// Euromuutoksen laskeminen kertoimella\nmuutoskerroin = function(x, y) {\n  return (1+x/100)*y;\n}\n// Muutosprosentti\nmuutosprosentti = function(x, y) {\n  return pyoristys(((x-y)/y)*100,1);\n}\n// Tuhatjakaja\ntuhatjakaja = function(x) {\n  return x/1000;\n}\n// Euromuutoksen laskeminen kertoimella\npalkkakerroin = function(x, y) {\n  return 100*((1+x/100)*(1+y/100)-1);\n}\n// Jako-osuuden asukaskerroin\nasukaskerroin = function(x, y) {\n  return (x/y);\n}\n// Jako-osuuden veroprosenttikerroin miinus1/miinus3 vuotta miinus 1 vuoden kerroin\nveroprosenttikerroin = function(x, y) {\n  return (x/y);\n}\n// Kunnan muok. kunnallisvero, alkuvuosi ja loppuvuosi \nkunnallisvero_muokkaus = function(kunnallisvero,asukaskerroin,veroprosentti) {\n  return kunnallisvero*asukaskerroin*veroprosentti;\n}\n\n//Tekstimuutokset\nfn_nousu_lasku_txt = function(arvo){\n  if(arvo &gt; 0) {\n  return \"kasvanut\" \n  }\n  else { \n  return \"laskenut\";\n  }\n}\n\n//TARVITAAN KARTOISSA\nserialize = {\n  const xmlns = \"http://www.w3.org/2000/xmlns/\";\n  const xlinkns = \"http://www.w3.org/1999/xlink\";\n  const svgns = \"http://www.w3.org/2000/svg\";\n  return function serialize(svg) {\n    svg = svg.cloneNode(true);\n    const fragment = window.location.href + \"#\";\n    const walker = document.createTreeWalker(svg, NodeFilter.SHOW_ELEMENT);\n    while (walker.nextNode()) {\n      for (const attr of walker.currentNode.attributes) {\n        if (attr.value.includes(fragment)) {\n          attr.value = attr.value.replace(fragment, \"#\");\n        }\n      }\n    }\n    svg.setAttributeNS(xmlns, \"xmlns\", svgns);\n    svg.setAttributeNS(xmlns, \"xmlns:xlink\", xlinkns);\n    const serializer = new window.XMLSerializer;\n    const string = serializer.serializeToString(svg);\n    return new Blob([string], {type: \"image/svg+xml\"});\n  };\n}\n\n\nfunction toSVG(chart) {\n  if (chart.nodeName !== \"FIGURE\") {\n    return chart;\n  }\n\n  // the chart needs to be in the body if we want to read values, positions, sizes…\n  document.body.appendChild(chart);\n  const [x0, y0, width, height] = getBounds([chart]);\n\n  const nodes = [];\n\n  for (const node of d3\n    .select(chart)\n    .selectChildren(\"h1,h2,h3,div,figcaption,svg\")) {\n    switch (node.nodeName.toLowerCase()) {\n      case \"div\":\n        {\n          const children = d3.select(node).selectChildren(\"div,span\");\n          const height = getBounds([node, ...children])[3] + 2;\n          const svg = d3\n            .select(chart)\n            .append(\"svg\")\n            .attr(\"width\", width)\n            .attr(\"height\", height);\n          nodes.push(svg.node());\n\n          const swatches = svg\n            .selectAll()\n            .data(\n              Array.from(children, (d) =&gt; {\n                const svg = d3.select(d).select(\"svg\").node();\n                const bbox = svg.getBBox();\n                return {\n                  style: window.getComputedStyle(d),\n                  svg,\n                  width: bbox.width,\n                  height: bbox.height,\n                  text: d.textContent,\n                  bounds: getBounds([d])\n                };\n              })\n            )\n            .join(\"g\")\n            .attr(\n              \"transform\",\n              (d) =&gt; `translate(${d.bounds[0] - x0},${10 + d.bounds[1] - y0})`\n            );\n\n          swatches\n            .append((d) =&gt; d.svg) // \"rect\")\n            .attr(\"width\", (d) =&gt; d.width)\n            .attr(\"height\", (d) =&gt; d.height)\n            .attr(\"y\", (d) =&gt; `${-parseFloat(d.height) / 2}px`);\n          swatches\n            .append(\"text\")\n            .text((d) =&gt; d.text)\n            .attr(\"x\", (d) =&gt; d.width)\n            .attr(\"dx\", 5)\n            .attr(\"dy\", \"0.38em\")\n            .attr(\"font-family\", (d) =&gt; d.style.fontFamily)\n            .attr(\"font-size\", (d) =&gt; d.style.fontSize)\n            .attr(\"fill\", (d) =&gt; d.style.color);\n        }\n        break;\n      case \"figcaption\":\n      case \"h1\":\n      case \"h2\":\n      case \"h3\":\n        {\n          const svg = d3\n            .select(chart)\n            .append(\"svg\")\n            .attr(\"width\", width)\n            .attr(\"overflow\", \"visible\");\n          nodes.push(svg.node());\n\n          const children = d3.select(node).selectChildren();\n\n          let h = 0;\n          for (const d of children.size() &gt; 0\n            ? children.selectChildren()\n            : [node]) {\n            const style = window.getComputedStyle(d);\n            const t = svg\n              .append(\"g\")\n              .attr(\"transform\", `translate(0,${h})`)\n              .append(() =&gt;\n                d3\n                  .select(\n                    Plot.text([d.textContent], {\n                      text: (d) =&gt; d,\n                      lineWidth:\n                        (1.06 * parseFloat(style.width)) /\n                        parseFloat(style.fontSize),\n                      lineHeight: 1.2,\n                      frameAnchor: \"top-left\"\n                    }).plot()\n                  )\n                  .select(\"text\")\n                  .attr(\"font-family\", style.fontFamily)\n                  .attr(\"font-size\", 1.08 * parseFloat(style.fontSize))\n                  .attr(\"font-weight\", style.fontWeight)\n                  .attr(\"fill\", style.color)\n                  .node()\n              );\n            h += getBounds([t.node()])[3] + 4;\n          }\n          svg.attr(\"height\", h);\n        }\n        break;\n      case \"svg\":\n        d3.select(chart).append(() =&gt; node);\n        nodes.push(node);\n        break;\n    }\n  }\n\n  return serializeAll(nodes)\n    .then((blob) =&gt; blob.text())\n    .then((c) =&gt; {\n      document.body.removeChild(chart);\n      return Object.assign(svg`${c}`, chart);\n    });\n}\n\n\n// Given an array of SVG elements, composites them into a single SVG element,\n// and then serializes the result to a blob.\nasync function serializeAll(elements, {padding = 10} = {}) {\n  const fragment = location.href + \"#\";\n  let root;\n  if (elements.length === 1) {\n    root = elements[0].cloneNode(true); // optimize common case\n  } else {\n    const [ox, oy, dx, dy] = getBounds(elements);\n    root = document.createElementNS(svgns, \"svg\");\n    root.setAttribute(\"width\", dx + 2 * padding);\n    root.setAttribute(\"height\", dy + 2 * padding);\n    root.setAttribute(\"viewBox\", [-padding, -padding, dx + 2 * padding, dy + 2 * padding]);\n    for (const element of elements) {\n      const svg = root.appendChild(element.cloneNode(true));\n      const { x, y, width, height } = element.getBoundingClientRect();\n      svg.setAttribute(\"x\", x - ox);\n      svg.setAttribute(\"y\", y - oy);\n      svg.setAttribute(\"width\", width);\n      svg.setAttribute(\"height\", height);\n    }\n  }\n  const walker = document.createTreeWalker(root, NodeFilter.SHOW_ELEMENT);\n  while (walker.nextNode()) {\n    const node = walker.currentNode;\n    for (const attr of node.attributes) {\n      if (attr.value.includes(fragment)) {\n        attr.value = attr.value.replace(fragment, \"#\");\n      }\n    }\n  }\n  root.setAttributeNS(xmlns, \"xmlns\", svgns);\n  root.setAttributeNS(xmlns, \"xmlns:xlink\", xlinkns);\n  const serializer = new XMLSerializer();\n  const string = serializer.serializeToString(root);\n  return new Blob([string], { type: \"image/svg+xml\" });\n}\n\n\nfunction getBounds(elements) {\n  let x1 = Infinity;\n  let y1 = x1;\n  let x2 = -x1;\n  let y2 = x2;\n  for (const element of elements) {\n    const { x, y, width, height } = element.getBoundingClientRect();\n    if (x &lt; x1) x1 = x;\n    if (x + width &gt; x2) x2 = x + width;\n    if (y &lt; y1) y1 = y;\n    if (y + height &gt; y2) y2 = y + height;\n  }\n  return [x1, y1, x2 - x1, y2 - y1];\n}\n\n// based on https://observablehq.com/@gka/cheap-fit-text-to-circle\nfunction lines(text, targetWidth) {\n  const CHAR_W = {\n    \"a\":7,\"B\":8,\"C\":8,\"c\":6,\"D\":9,\"f\":4,\"G\":9,\"H\":9,\"I\":3,\"i\":3,\"J\":5,\"j\":3,\"K\":8,\"k\":6,\n    \"l\":3,\"M\":11,\"m\":11,\"N\":9,\"O\":9,\"P\":8,\"Q\":9,\"R\":8,\"r\":4,\"S\":8,\"s\":6,\"t\":4,\"U\":9,\"v\":6,\n    \"W\":11,\"w\":9,\"x\":6,\"y\":6,\"z\":5,\".\":2,\",\":2,\":\":2,\";\":2\n  };\n  function measureWidth(text) { return  d3.sum(text, char =&gt; CHAR_W[char] || CHAR_W[\"a\"]) * 0.8; };\n\n  const words = text.split(\" \");\n  let line;\n  let lineWidth0 = Infinity;\n  const lines = [];\n  for (let i = 0, n = words.length; i &lt; n; ++i) {\n    let lineText1 = (line ? line.text + \" \" : \"\") + words[i];\n    let lineWidth1 = measureWidth(lineText1);\n    if ((lineWidth0 + lineWidth1) / 2 &lt; targetWidth) {\n      line.width = lineWidth0 = lineWidth1;\n      line.text = lineText1;\n    } else {\n      lineWidth0 = measureWidth(words[i]);\n      line = {width: lineWidth0, text: words[i]};\n      lines.push(line);\n    }\n  }\n  return lines;\n}\n\nxmlns = \"http://www.w3.org/2000/xmlns/\"\n\nxlinkns = \"http://www.w3.org/1999/xlink\"\n\nsvgns = \"http://www.w3.org/2000/svg\"\nfunction Legend(color, {\n  title,\n  tickSize = 6,\n  width = 320, \n  height = 44 + tickSize,\n  marginTop = 18,\n  marginRight = 0,\n  marginBottom = 16 + tickSize,\n  marginLeft = 0,\n  ticks = width / 64,\n  tickFormat,\n  tickValues\n} = {}) {\n\n  function ramp(color, n = 256) {\n    const canvas = document.createElement(\"canvas\");\n    canvas.width = n;\n    canvas.height = 1;\n    const context = canvas.getContext(\"2d\");\n    for (let i = 0; i &lt; n; ++i) {\n      context.fillStyle = color(i / (n - 1));\n      context.fillRect(i, 0, 1, 1);\n    }\n    return canvas;\n  }\n\n  const svg = d3.create(\"svg\")\n      .attr(\"width\", width)\n      .attr(\"height\", height)\n      .attr(\"viewBox\", [0, 0, width, height])\n      .style(\"overflow\", \"visible\")\n      .style(\"display\", \"block\");\n\n  let tickAdjust = g =&gt; g.selectAll(\".tick line\").attr(\"y1\", marginTop + marginBottom - height);\n  let x;\n\n  // Continuous\n  if (color.interpolate) {\n    const n = Math.min(color.domain().length, color.range().length);\n\n    x = color.copy().rangeRound(d3.quantize(d3.interpolate(marginLeft, width - marginRight), n));\n\n    svg.append(\"image\")\n        .attr(\"x\", marginLeft)\n        .attr(\"y\", marginTop)\n        .attr(\"width\", width - marginLeft - marginRight)\n        .attr(\"height\", height - marginTop - marginBottom)\n        .attr(\"preserveAspectRatio\", \"none\")\n        .attr(\"xlink:href\", ramp(color.copy().domain(d3.quantize(d3.interpolate(0, 1), n))).toDataURL());\n  }\n\n  // Sequential\n  else if (color.interpolator) {\n    x = Object.assign(color.copy()\n        .interpolator(d3.interpolateRound(marginLeft, width - marginRight)),\n        {range() { return [marginLeft, width - marginRight]; }});\n\n    svg.append(\"image\")\n        .attr(\"x\", marginLeft)\n        .attr(\"y\", marginTop)\n        .attr(\"width\", width - marginLeft - marginRight)\n        .attr(\"height\", height - marginTop - marginBottom)\n        .attr(\"preserveAspectRatio\", \"none\")\n        .attr(\"xlink:href\", ramp(color.interpolator()).toDataURL());\n\n    // scaleSequentialQuantile doesn’t implement ticks or tickFormat.\n    if (!x.ticks) {\n      if (tickValues === undefined) {\n        const n = Math.round(ticks + 1);\n        tickValues = d3.range(n).map(i =&gt; d3.quantile(color.domain(), i / (n - 1)));\n      }\n      if (typeof tickFormat !== \"function\") {\n        tickFormat = d3.format(tickFormat === undefined ? \",f\" : tickFormat);\n      }\n    }\n  }\n\n  // Threshold\n  else if (color.invertExtent) {\n    const thresholds\n        = color.thresholds ? color.thresholds() // scaleQuantize\n        : color.quantiles ? color.quantiles() // scaleQuantile\n        : color.domain(); // scaleThreshold\n\n    const thresholdFormat\n        = tickFormat === undefined ? d =&gt; d\n        : typeof tickFormat === \"string\" ? d3.format(tickFormat)\n        : tickFormat;\n\n    x = d3.scaleLinear()\n        .domain([-1, color.range().length - 1])\n        .rangeRound([marginLeft, width - marginRight]);\n\n    svg.append(\"g\")\n      .selectAll(\"rect\")\n      .data(color.range())\n      .join(\"rect\")\n        .attr(\"x\", (d, i) =&gt; x(i - 1))\n        .attr(\"y\", marginTop)\n        .attr(\"width\", (d, i) =&gt; x(i) - x(i - 1))\n        .attr(\"height\", height - marginTop - marginBottom)\n        .attr(\"fill\", d =&gt; d);\n\n    tickValues = d3.range(thresholds.length);\n    tickFormat = i =&gt; thresholdFormat(thresholds[i], i);\n  }\n\n  // Ordinal\n  else {\n    x = d3.scaleBand()\n        .domain(color.domain())\n        .rangeRound([marginLeft, width - marginRight]);\n\n    svg.append(\"g\")\n      .selectAll(\"rect\")\n      .data(color.domain())\n      .join(\"rect\")\n        .attr(\"x\", x)\n        .attr(\"y\", marginTop)\n        .attr(\"width\", Math.max(0, x.bandwidth() - 1))\n        .attr(\"height\", height - marginTop - marginBottom)\n        .attr(\"fill\", color);\n\n    tickAdjust = () =&gt; {};\n  }\n\n  svg.append(\"g\")\n      .attr(\"transform\", `translate(0,${height - marginBottom})`)\n      .call(d3.axisBottom(x)\n        .ticks(ticks, typeof tickFormat === \"string\" ? tickFormat : undefined)\n        .tickFormat(typeof tickFormat === \"function\" ? tickFormat : undefined)\n        .tickSize(tickSize)\n        .tickValues(tickValues))\n      .call(tickAdjust)\n      .call(g =&gt; g.select(\".domain\").remove())\n      .call(g =&gt; g.append(\"text\")\n        .attr(\"x\", marginLeft)\n        .attr(\"y\", marginTop + marginBottom - height - 6)\n        .attr(\"fill\", \"currentColor\")\n        .attr(\"text-anchor\", \"start\")\n        .attr(\"font-weight\", \"bold\")\n        .style(\"font-size\", \"12px\")\n        .attr(\"class\", \"title\")\n        .text(title));\n\n  return svg.node();\n}\n\n\nfunction legend({color, ...options}) {\n  return Legend(color, options);\n}\n\n\n// Copyright 2021, Observable Inc.\n// Released under the ISC license.\n// https://observablehq.com/@d3/color-legend\nfunction Swatches(color, {\n  columns = null,\n  format,\n  unknown: formatUnknown,\n  swatchSize = 15,\n  swatchWidth = swatchSize,\n  swatchHeight = swatchSize,\n  marginLeft = 0\n} = {}) {\n  const id = `-swatches-${Math.random().toString(16).slice(2)}`;\n  const unknown = formatUnknown == null ? undefined : color.unknown();\n  const unknowns = unknown == null || unknown === d3.scaleImplicit ? [] : [unknown];\n  const domain = color.domain().concat(unknowns);\n  if (format === undefined) format = x =&gt; x === unknown ? formatUnknown : x;\n\n  function entity(character) {\n    return `&#${character.charCodeAt(0).toString()};`;\n  }\n\n  if (columns !== null) return htl.html`&lt;div style=\"display: flex; align-items: center; margin-left: ${+marginLeft}px; min-height: 33px; font: 12px sans-serif;\"&gt;\n  &lt;style&gt;\n\n.${id}-item {\n  break-inside: avoid;\n  display: flex;\n  align-items: center;\n  padding-bottom: 1px;\n}\n\n.${id}-label {\n  white-space: nowrap;\n  overflow: hidden;\n  text-overflow: ellipsis;\n  max-width: calc(100% - ${+swatchWidth}px - 0.5em);\n}\n\n.${id}-swatch {\n  width: ${+swatchWidth}px;\n  height: ${+swatchHeight}px;\n  margin: 0 0.5em 0 0;\n}\n\n  &lt;/style&gt;\n  &lt;div style=${{width: \"100%\", columns}}&gt;${domain.map(value =&gt; {\n    const label = `${format(value)}`;\n    return htl.html`&lt;div class=${id}-item&gt;\n      &lt;div class=${id}-swatch style=${{background: color(value)}}&gt;&lt;/div&gt;\n      &lt;div class=${id}-label title=${label}&gt;${label}&lt;/div&gt;\n    &lt;/div&gt;`;\n  })}\n  &lt;/div&gt;\n&lt;/div&gt;`;\n\n  return htl.html`&lt;div style=\"display: flex; align-items: center; min-height: 33px; margin-left: ${+marginLeft}px; font: 12px sans-serif;\"&gt;\n  &lt;style&gt;\n\n.${id} {\n  display: inline-flex;\n  align-items: center;\n  margin-right: 1em;\n}\n\n.${id}::before {\n  content: \"\";\n  width: ${+swatchWidth}px;\n  height: ${+swatchHeight}px;\n  margin-right: 0.5em;\n  background: var(--color);\n}\n\n  &lt;/style&gt;\n  &lt;div&gt;${domain.map(value =&gt; htl.html`&lt;span class=\"${id}\" style=\"--color: ${color(value)}\"&gt;${format(value)}&lt;/span&gt;`)}&lt;/div&gt;`;\n}\n\nfunction swatches({color, ...options}) {\n  return Swatches(color, options);\n}\nchart_map_d3 = function(data, mapTopoJSON, color, colorBorder, txtTitle, chart_width, chart_height) {\n\n  const projection = d3.geoMercator()\n  .scale(1200)\n  //.center([40, 67.5])\n  .center([40, 67.3])\n  .translate([400, 220])\n  const path = d3.geoPath().projection(projection);\n  const format = d =&gt; `${d}%`;\n  \n  //Määritellään tähän muuttujat CSV:stä!!!!!!\n  const valuemap = new Map(data.map(d =&gt; [d.id, d.muutos]));\n  \n  //Määritellään maakunnat\n  const maakuntamesh = topojson.mesh(maakunnat_2024_topo, maakunnat_2024_topo.objects.maakunnat_2024, (a, b) =&gt; a !== b);\n  \n  const zoom = d3.zoom()\n      .scaleExtent([1, 8])\n      .on(\"zoom\", zoomed);\n\n  const svg = d3.create(\"svg\")\n      .attr(\"width\", 900)\n      .attr(\"height\", 650)\n      .attr(\"viewBox\", [0, 0, 900, 650])\n      .on(\"click\", reset);\n      \n  const g = svg.append(\"g\")\n      .attr(\"transform\", \"translate(20,35)\")\n      .append(() =&gt; Legend(color, {title: txtTitle, width: 260}));\n\n  g.append(\"g\")\n    .selectAll(\"path\")\n    .data(mapTopoJSON)\n    .join(\"path\")\n      .attr(\"fill\", d =&gt; color(valuemap.get(d.properties.kunta))) \n      .attr(\"d\", path)\n    .append(\"title\")\n      .text(d =&gt; `${d.properties.name},\\n(${d.properties.nimi_2}),\\n${valuemap.get(d.properties.kunta)}`);\n      \n  g.append(\"path\")\n      .datum(maakuntamesh)\n      .attr(\"fill\", \"none\")\n      .attr(\"stroke\", colorBorder)\n      .attr(\"stroke-linejoin\", \"round\")\n      .attr(\"d\", path);\n      \n   svg.call(zoom);\n   \n\n  function reset() {\n    // states.transition().style(\"fill\", null);\n    svg.transition().duration(750).call(\n      zoom.transform,\n      d3.zoomIdentity,\n      d3.zoomTransform(svg.node()).invert([chart_width / 2, chart_height / 2])\n    );\n  }\n\n  function zoomed(event) {\n    const {transform} = event;\n    g.attr(\"transform\", transform);\n    g.attr(\"stroke-width\", 1 / transform.k);\n  }     \n      \n  return svg.node();\n}\nchart_chord_d3 = function(data, title_txt_chord, chart_width, chart_height) {\n\n  var sum_target;\n  var sum_source;\n  let vari;\n  var sum_yht;\n  \n  const margin = ({top: 20, right: 20, bottom: 0, left: 50});\n  const width = 300;\n  const height = width;\n  const innerRadius = Math.min(width, height) * .3 - 40;\n  const outerRadius = innerRadius + 15;\n  \n  \n  const chord = d3.chordDirected()\n    .padAngle(0.5 / innerRadius)\n    .sortSubgroups(d3.ascending)\n    .sortChords(d3.ascending);\n    \n  const ribbon = d3.ribbon()\n    .radius(innerRadius - 1)\n    .padAngle(0.5 / innerRadius);\n    \n  const rename = name =&gt; name.substring(name.indexOf(\".\") + 1, name.lastIndexOf(\".\"))\n  const names = Array.from(new Set(data.flatMap(d =&gt; [d.source, d.target]))).sort(d3.ascending);\n  \n  function matriisi(names) {\n    const index = new Map(names.map((name, i) =&gt; [name, i]));\n    const matrix = Array.from(index, () =&gt; new Array(names.length).fill(0));\n    for (const {source, target, value} of data) matrix[index.get(source)][index.get(target)] += value;\n    return matrix;\n  }\n\n const matrix = matriisi(names)\n  \n const arc = d3.arc()\n    .innerRadius(innerRadius)\n    .outerRadius(outerRadius)\n\n  //TÄSTÄ ALKAA PIIRROS\n  \n  const zoom = d3.zoom()\n      .scaleExtent([1, 8])\n      .on(\"zoom\", zoomed);\n  \n  const svg = d3.create(\"svg\")\n      .attr(\"viewBox\", [-width / 2, -height / 2.5, width, height]);\n\n  const chords = chord(matrix);\n  \n  const group = svg.append(\"g\")\n      .attr(\"font-size\", 3)\n      .attr(\"font-family\", \"Century Gothic\")\n    .selectAll(\"g\")\n    .data(chords.groups)\n    .join(\"g\");\n\n  group.append(\"path\")\n      .attr(\"fill\", d =&gt; {\n           sum_target = d3.sum(chords, c =&gt; (c.target.index === d.index) * c.target.value);\n           sum_source = d3.sum(chords, c =&gt; (c.source.index === d.index) * c.source.value);\n           sum_yht = sum_target-sum_source;\n            if (sum_yht &gt; 0) { \n              vari = \"#009651\"\n              return vari \n            }\n            else if (sum_yht == 0) { \n              vari = \"#28336C\"\n              return vari \n            }\n            else    { \n              vari = \"#DE232F\" \n              return vari \n            }\n        })\n      .attr(\"d\", arc);\n\n  group.append(\"text\")\n      .each(d =&gt; (d.angle = (d.startAngle + d.endAngle) / 2))\n      .attr(\"dy\", \"0.35em\")\n      .attr(\"transform\", d =&gt; `\n        rotate(${(d.angle * 180 / Math.PI - 90)})\n        translate(${outerRadius + 6})\n        ${d.angle &gt; Math.PI ? \"rotate(180)\" : \"\"}\n      `)\n      .attr(\"text-anchor\", d =&gt; d.angle &gt; Math.PI ? \"end\" : null)\n      //.text(d =&gt; names[d.index])\n      .text(d =&gt; (d.index &gt;= 3) ? names[d.index] : \"\")\n      .attr(\"fill\", d =&gt; {\n           sum_target = d3.sum(chords, c =&gt; (c.target.index === d.index) * c.target.value);\n           sum_source = d3.sum(chords, c =&gt; (c.source.index === d.index) * c.source.value);\n           sum_yht = sum_target-sum_source;\n            if (sum_yht &gt; 0) { \n              vari = \"#009651\"\n              return vari\n            }\n            else if (sum_yht == 0) { \n              vari = \"#28336C\"\n              return vari \n            }\n            else    { \n              vari = \"#DE232F\" \n              return vari \n            }\n        });\n\n  group.append(\"title\")\n      .text(d =&gt; `${names[d.index]} \n\n${d3.sum(chords, c =&gt; (c.source.index === d.index) * c.source.value)} lähtee →\n${d3.sum(chords, c =&gt; (c.target.index === d.index) * c.source.value)} tulee ←\n${d3.sum(chords, c =&gt; (c.target.index === d.index) * c.target.value)- d3.sum(chords, c =&gt; (c.source.index === d.index) * c.source.value)} netto =`);  \n\n  svg.append(\"g\")\n      .attr(\"fill-opacity\", 0.75)\n    .selectAll(\"path\")\n    .data(chords)\n    .join(\"path\")\n      .style(\"mix-blend-mode\", \"multiply\")\n          .attr(\"fill\", d =&gt; {\n           sum_target = d3.sum(chords, c =&gt; (c.target.index === d.index) * c.target.value);\n           sum_source = d3.sum(chords, c =&gt; (c.source.index === d.index) * c.source.value);\n           sum_yht = sum_target-sum_source;\n            if (sum_yht &gt; 0) { \n              vari = \"#009651\"\n              return vari \n            }\n            else if (sum_yht == 0) { \n              vari = \"#28336C\"\n              return vari \n            }\n            else    { \n              vari = \"#DE232F\" \n              return vari \n            }\n        })\n      .attr(\"d\", ribbon)\n    .append(\"title\")\n      .text(d =&gt; `${names[d.source.index]} --&gt; ${names[d.target.index]} ${d.source.value}`);\n      \n      \n  svg.call(zoom);\n   \n\n  function reset() {\n    // states.transition().style(\"fill\", null);\n    svg.transition().duration(750).call(\n      zoom.transform,\n      d3.zoomIdentity,\n      d3.zoomTransform(svg.node()).invert([chart_width / 2, chart_height / 2])\n    );\n  }\n\n  function zoomed(event) {\n    const {transform} = event;\n    svg.attr(\"transform\", transform);\n    svg.attr(\"stroke-width\", 1 / transform.k);\n  }    \n\n  return svg.node();\n\n\n}"
  },
  {
    "objectID": "tyollisyys.html#työttömien-työnhakijoiden--osuus-työvoimasta-koko-maassa-1",
    "href": "tyollisyys.html#työttömien-työnhakijoiden--osuus-työvoimasta-koko-maassa-1",
    "title": "Työllisyys",
    "section": "Työttömien työnhakijoiden %-osuus työvoimasta koko maassa",
    "text": "Työttömien työnhakijoiden %-osuus työvoimasta koko maassa\n\n\n\n\n\n\n\n\nSija\nMaakunta\nKunta\n2024M08\n\n\n\n\n1\nAhvenanmaa\nJomala\n2.6\n\n\n2\nAhvenanmaa\nLemland\n2.6\n\n\n3\nPohjanmaa\nLuoto\n3.4\n\n\n4\nAhvenanmaa\nSaltvik\n3.5\n\n\n5\nAhvenanmaa\nBrändö\n3.6\n\n\n6\nPohjanmaa\nNärpiö\n3.7\n\n\n7\nPohjanmaa\nPedersören kunta\n3.7\n\n\n8\nAhvenanmaa\nSund\n3.7\n\n\n9\nAhvenanmaa\nFöglö\n4.1\n\n\n10\nAhvenanmaa\nHammarland\n4.3\n\n\n11\nAhvenanmaa\nKumlinge\n4.3\n\n\n12\nAhvenanmaa\nVårdö\n4.3\n\n\n13\nAhvenanmaa\nFinström\n4.4\n\n\n14\nEtelä-Pohjanmaa\nEvijärvi\n4.7\n\n\n15\nEtelä-Pohjanmaa\nKuortane\n4.8\n\n\n16\nVarsinais-Suomi\nRusko\n4.8\n\n\n17\nPohjanmaa\nMaalahti\n5.1\n\n\n18\nPohjanmaa\nMustasaari\n5.1\n\n\n19\nPohjanmaa\nKruunupyy\n5.6\n\n\n20\nAhvenanmaa\nGeta\n5.7\n\n\n21\nUusimaa\nInkoo\n5.7\n\n\n22\nAhvenanmaa\nKökar\n5.8\n\n\n23\nEtelä-Pohjanmaa\nLappajärvi\n5.8\n\n\n24\nVarsinais-Suomi\nMasku\n5.9\n\n\n25\nPohjois-Pohjanmaa\nReisjärvi\n5.9\n\n\n26\nPohjanmaa\nVöyri\n5.9\n\n\n27\nAhvenanmaa\nEckerö\n6.0\n\n\n28\nPirkanmaa\nPälkäne\n6.0\n\n\n29\nEtelä-Pohjanmaa\nIsojoki\n6.1\n\n\n30\nPirkanmaa\nJuupajoki\n6.2\n\n\n31\nPohjanmaa\nKorsnäs\n6.2\n\n\n32\nEtelä-Pohjanmaa\nLapua\n6.2\n\n\n33\nKanta-Häme\nLoppi\n6.3\n\n\n34\nVarsinais-Suomi\nPaimio\n6.3\n\n\n35\nVarsinais-Suomi\nParainen\n6.3\n\n\n36\nEtelä-Pohjanmaa\nSoini\n6.3\n\n\n37\nPohjanmaa\nUusikaarlepyy\n6.3\n\n\n38\nEtelä-Pohjanmaa\nVimpeli\n6.3\n\n\n39\nPohjanmaa\nLaihia\n6.4\n\n\n40\nUusimaa\nSiuntio\n6.4\n\n\n41\nKanta-Häme\nHattula\n6.5\n\n\n42\nSatakunta\nJämijärvi\n6.5\n\n\n43\nAhvenanmaa\nMaarianhamina - Mariehamn\n6.5\n\n\n44\nEtelä-Pohjanmaa\nIlmajoki\n6.6\n\n\n45\nPohjanmaa\nKristiinankaupunki\n6.6\n\n\n46\nEtelä-Pohjanmaa\nIsokyrö\n6.8\n\n\n47\nEtelä-Pohjanmaa\nKauhava\n6.8\n\n\n48\nKeski-Pohjanmaa\nKaustinen\n6.8\n\n\n49\nVarsinais-Suomi\nLieto\n6.8\n\n\n50\nPirkanmaa\nPunkalaidun\n6.8\n\n\n\n\n\n\n\n\nVertailu koko maan ja maakunnan osalta\nNousiainen on sijalla 54, tarkasteltaessa työttömien työnhakijoiden %-osuutta työvoimasta. Viimeisin ennakkotietolukema on 7. Maakuntavertailussa (Varsinais-Suomi) Nousiainen on sijalla 8."
  },
  {
    "objectID": "tyollisyys.html#työttömät-työnhakijat",
    "href": "tyollisyys.html#työttömät-työnhakijat",
    "title": "Työllisyys",
    "section": "Työttömät työnhakijat",
    "text": "Työttömät työnhakijat\n\nTyöttömät työnhakijat laskentapäivänä\n\n\n\n\n\n\nTilastokeskuksen työssäkäyntitilaston mukaan työttömiä työnhakijoita oli 2024M08 yhteensä 123 (lukema 2024M07: 158).\n\n\n\n\n\n\n\n\nKuukausi\nTyöttömät työnhakijat laskentapäivänä (lkm.)\n\n\n\n\n2022M09\n111\n\n\n2022M10\n112\n\n\n2022M11\n106\n\n\n2022M12\n115\n\n\n2023M01\n113\n\n\n2023M02\n111\n\n\n2023M03\n109\n\n\n2023M04\n106\n\n\n2023M05\n97\n\n\n2023M06\n119\n\n\n2023M07\n137\n\n\n2023M08\n105\n\n\n2023M09\n107\n\n\n2023M10\n117\n\n\n2023M11\n122\n\n\n2023M12\n144\n\n\n2024M01\n129\n\n\n2024M02\n140\n\n\n2024M03\n134\n\n\n2024M04\n116\n\n\n2024M05\n109\n\n\n2024M06\n138\n\n\n2024M07\n158\n\n\n2024M08\n123"
  },
  {
    "objectID": "tyollisyys.html#alle-25-v.-työttömät-työnhakijat",
    "href": "tyollisyys.html#alle-25-v.-työttömät-työnhakijat",
    "title": "Työllisyys",
    "section": "Alle 25-v. työttömät työnhakijat",
    "text": "Alle 25-v. työttömät työnhakijat\n\n\n\n\n\n\n:::\n\nAlle 25-v. työttömät työnhakijat (lkm.)\nAlle 25-vuotiaita työttömiä oli 2024M08 yhteensä 10 (lukema 2024M07: 12).\n\n\n\n\n\n\n\n\nKuukausi\nAlle 25-v. työttömät työnhakijat (lkm.)\n\n\n\n\n2022M09\n17\n\n\n2022M10\n16\n\n\n2022M11\n12\n\n\n2022M12\n12\n\n\n2023M01\n17\n\n\n2023M02\n16\n\n\n2023M03\n12\n\n\n2023M04\n16\n\n\n2023M05\n11\n\n\n2023M06\n11\n\n\n2023M07\n13\n\n\n2023M08\n10\n\n\n2023M09\n10\n\n\n2023M10\n9\n\n\n2023M11\n10\n\n\n2023M12\n11\n\n\n2024M01\n5\n\n\n2024M02\n8\n\n\n2024M03\n6\n\n\n2024M04\nNA\n\n\n2024M05\nNA\n\n\n2024M06\n9\n\n\n2024M07\n12\n\n\n2024M08\n10"
  },
  {
    "objectID": "muuttoliike.html",
    "href": "muuttoliike.html",
    "title": "Muuttoliike",
    "section": "",
    "text": "d3 = require(\"d3@7\")\n//import {Legend} from \"@d3/color-legend\"\n\nfolderKunnat24TopoJSON = \"./maps/Kunnat2024Topo.json\"\nkunnat2024topo = FileAttachmentDynamic(folderKunnat24TopoJSON).json()\nmapTopoJSON = topojson.feature(kunnat2024topo, kunnat2024topo.objects.Kunnat2024_geo).features\n\n\nfolderMaakunnat24TopoJSON = \"./maps/Maakunnat2024Topo.json\"\nmaakunnat_2024_topo =  FileAttachmentDynamic(folderMaakunnat24TopoJSON).json()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFileAttachmentDynamic = function(filename) {\n  return new Function(\"FileAttachment\", `return FileAttachment(\"${filename}\")`)(FileAttachment)\n}\n\n// Vaihdetaan tekstin väri\ncolor = function(vari) {\n  if(vari &gt; 0){\n      return \"green\"\n    }else{\n      return \"red\"\n    }\n}\n// Pyöristys\npyoristys = function(n, places) {\n  if (!places) return Math.round(n);\n  const d = 10 ** places;\n  return Math.round(n * d) / d;\n}\n//Euromerkintä\neurot = function(number) {\n  return number.toLocaleString('fi-FI', { style: 'currency', currency: 'EUR',minimumFractionDigits: 0 });\n}\n// Euromuutoksen laskeminen kertoimella\nmuutoskerroin = function(x, y) {\n  return (1+x/100)*y;\n}\n// Muutosprosentti\nmuutosprosentti = function(x, y) {\n  return pyoristys(((x-y)/y)*100,1);\n}\n// Tuhatjakaja\ntuhatjakaja = function(x) {\n  return x/1000;\n}\n// Euromuutoksen laskeminen kertoimella\npalkkakerroin = function(x, y) {\n  return 100*((1+x/100)*(1+y/100)-1);\n}\n// Jako-osuuden asukaskerroin\nasukaskerroin = function(x, y) {\n  return (x/y);\n}\n// Jako-osuuden veroprosenttikerroin miinus1/miinus3 vuotta miinus 1 vuoden kerroin\nveroprosenttikerroin = function(x, y) {\n  return (x/y);\n}\n// Kunnan muok. kunnallisvero, alkuvuosi ja loppuvuosi \nkunnallisvero_muokkaus = function(kunnallisvero,asukaskerroin,veroprosentti) {\n  return kunnallisvero*asukaskerroin*veroprosentti;\n}\n\n//Tekstimuutokset\nfn_nousu_lasku_txt = function(arvo){\n  if(arvo &gt; 0) {\n  return \"kasvanut\" \n  }\n  else { \n  return \"laskenut\";\n  }\n}\n\n//TARVITAAN KARTOISSA\nserialize = {\n  const xmlns = \"http://www.w3.org/2000/xmlns/\";\n  const xlinkns = \"http://www.w3.org/1999/xlink\";\n  const svgns = \"http://www.w3.org/2000/svg\";\n  return function serialize(svg) {\n    svg = svg.cloneNode(true);\n    const fragment = window.location.href + \"#\";\n    const walker = document.createTreeWalker(svg, NodeFilter.SHOW_ELEMENT);\n    while (walker.nextNode()) {\n      for (const attr of walker.currentNode.attributes) {\n        if (attr.value.includes(fragment)) {\n          attr.value = attr.value.replace(fragment, \"#\");\n        }\n      }\n    }\n    svg.setAttributeNS(xmlns, \"xmlns\", svgns);\n    svg.setAttributeNS(xmlns, \"xmlns:xlink\", xlinkns);\n    const serializer = new window.XMLSerializer;\n    const string = serializer.serializeToString(svg);\n    return new Blob([string], {type: \"image/svg+xml\"});\n  };\n}\n\n\nfunction toSVG(chart) {\n  if (chart.nodeName !== \"FIGURE\") {\n    return chart;\n  }\n\n  // the chart needs to be in the body if we want to read values, positions, sizes…\n  document.body.appendChild(chart);\n  const [x0, y0, width, height] = getBounds([chart]);\n\n  const nodes = [];\n\n  for (const node of d3\n    .select(chart)\n    .selectChildren(\"h1,h2,h3,div,figcaption,svg\")) {\n    switch (node.nodeName.toLowerCase()) {\n      case \"div\":\n        {\n          const children = d3.select(node).selectChildren(\"div,span\");\n          const height = getBounds([node, ...children])[3] + 2;\n          const svg = d3\n            .select(chart)\n            .append(\"svg\")\n            .attr(\"width\", width)\n            .attr(\"height\", height);\n          nodes.push(svg.node());\n\n          const swatches = svg\n            .selectAll()\n            .data(\n              Array.from(children, (d) =&gt; {\n                const svg = d3.select(d).select(\"svg\").node();\n                const bbox = svg.getBBox();\n                return {\n                  style: window.getComputedStyle(d),\n                  svg,\n                  width: bbox.width,\n                  height: bbox.height,\n                  text: d.textContent,\n                  bounds: getBounds([d])\n                };\n              })\n            )\n            .join(\"g\")\n            .attr(\n              \"transform\",\n              (d) =&gt; `translate(${d.bounds[0] - x0},${10 + d.bounds[1] - y0})`\n            );\n\n          swatches\n            .append((d) =&gt; d.svg) // \"rect\")\n            .attr(\"width\", (d) =&gt; d.width)\n            .attr(\"height\", (d) =&gt; d.height)\n            .attr(\"y\", (d) =&gt; `${-parseFloat(d.height) / 2}px`);\n          swatches\n            .append(\"text\")\n            .text((d) =&gt; d.text)\n            .attr(\"x\", (d) =&gt; d.width)\n            .attr(\"dx\", 5)\n            .attr(\"dy\", \"0.38em\")\n            .attr(\"font-family\", (d) =&gt; d.style.fontFamily)\n            .attr(\"font-size\", (d) =&gt; d.style.fontSize)\n            .attr(\"fill\", (d) =&gt; d.style.color);\n        }\n        break;\n      case \"figcaption\":\n      case \"h1\":\n      case \"h2\":\n      case \"h3\":\n        {\n          const svg = d3\n            .select(chart)\n            .append(\"svg\")\n            .attr(\"width\", width)\n            .attr(\"overflow\", \"visible\");\n          nodes.push(svg.node());\n\n          const children = d3.select(node).selectChildren();\n\n          let h = 0;\n          for (const d of children.size() &gt; 0\n            ? children.selectChildren()\n            : [node]) {\n            const style = window.getComputedStyle(d);\n            const t = svg\n              .append(\"g\")\n              .attr(\"transform\", `translate(0,${h})`)\n              .append(() =&gt;\n                d3\n                  .select(\n                    Plot.text([d.textContent], {\n                      text: (d) =&gt; d,\n                      lineWidth:\n                        (1.06 * parseFloat(style.width)) /\n                        parseFloat(style.fontSize),\n                      lineHeight: 1.2,\n                      frameAnchor: \"top-left\"\n                    }).plot()\n                  )\n                  .select(\"text\")\n                  .attr(\"font-family\", style.fontFamily)\n                  .attr(\"font-size\", 1.08 * parseFloat(style.fontSize))\n                  .attr(\"font-weight\", style.fontWeight)\n                  .attr(\"fill\", style.color)\n                  .node()\n              );\n            h += getBounds([t.node()])[3] + 4;\n          }\n          svg.attr(\"height\", h);\n        }\n        break;\n      case \"svg\":\n        d3.select(chart).append(() =&gt; node);\n        nodes.push(node);\n        break;\n    }\n  }\n\n  return serializeAll(nodes)\n    .then((blob) =&gt; blob.text())\n    .then((c) =&gt; {\n      document.body.removeChild(chart);\n      return Object.assign(svg`${c}`, chart);\n    });\n}\n\n\n// Given an array of SVG elements, composites them into a single SVG element,\n// and then serializes the result to a blob.\nasync function serializeAll(elements, {padding = 10} = {}) {\n  const fragment = location.href + \"#\";\n  let root;\n  if (elements.length === 1) {\n    root = elements[0].cloneNode(true); // optimize common case\n  } else {\n    const [ox, oy, dx, dy] = getBounds(elements);\n    root = document.createElementNS(svgns, \"svg\");\n    root.setAttribute(\"width\", dx + 2 * padding);\n    root.setAttribute(\"height\", dy + 2 * padding);\n    root.setAttribute(\"viewBox\", [-padding, -padding, dx + 2 * padding, dy + 2 * padding]);\n    for (const element of elements) {\n      const svg = root.appendChild(element.cloneNode(true));\n      const { x, y, width, height } = element.getBoundingClientRect();\n      svg.setAttribute(\"x\", x - ox);\n      svg.setAttribute(\"y\", y - oy);\n      svg.setAttribute(\"width\", width);\n      svg.setAttribute(\"height\", height);\n    }\n  }\n  const walker = document.createTreeWalker(root, NodeFilter.SHOW_ELEMENT);\n  while (walker.nextNode()) {\n    const node = walker.currentNode;\n    for (const attr of node.attributes) {\n      if (attr.value.includes(fragment)) {\n        attr.value = attr.value.replace(fragment, \"#\");\n      }\n    }\n  }\n  root.setAttributeNS(xmlns, \"xmlns\", svgns);\n  root.setAttributeNS(xmlns, \"xmlns:xlink\", xlinkns);\n  const serializer = new XMLSerializer();\n  const string = serializer.serializeToString(root);\n  return new Blob([string], { type: \"image/svg+xml\" });\n}\n\n\nfunction getBounds(elements) {\n  let x1 = Infinity;\n  let y1 = x1;\n  let x2 = -x1;\n  let y2 = x2;\n  for (const element of elements) {\n    const { x, y, width, height } = element.getBoundingClientRect();\n    if (x &lt; x1) x1 = x;\n    if (x + width &gt; x2) x2 = x + width;\n    if (y &lt; y1) y1 = y;\n    if (y + height &gt; y2) y2 = y + height;\n  }\n  return [x1, y1, x2 - x1, y2 - y1];\n}\n\n// based on https://observablehq.com/@gka/cheap-fit-text-to-circle\nfunction lines(text, targetWidth) {\n  const CHAR_W = {\n    \"a\":7,\"B\":8,\"C\":8,\"c\":6,\"D\":9,\"f\":4,\"G\":9,\"H\":9,\"I\":3,\"i\":3,\"J\":5,\"j\":3,\"K\":8,\"k\":6,\n    \"l\":3,\"M\":11,\"m\":11,\"N\":9,\"O\":9,\"P\":8,\"Q\":9,\"R\":8,\"r\":4,\"S\":8,\"s\":6,\"t\":4,\"U\":9,\"v\":6,\n    \"W\":11,\"w\":9,\"x\":6,\"y\":6,\"z\":5,\".\":2,\",\":2,\":\":2,\";\":2\n  };\n  function measureWidth(text) { return  d3.sum(text, char =&gt; CHAR_W[char] || CHAR_W[\"a\"]) * 0.8; };\n\n  const words = text.split(\" \");\n  let line;\n  let lineWidth0 = Infinity;\n  const lines = [];\n  for (let i = 0, n = words.length; i &lt; n; ++i) {\n    let lineText1 = (line ? line.text + \" \" : \"\") + words[i];\n    let lineWidth1 = measureWidth(lineText1);\n    if ((lineWidth0 + lineWidth1) / 2 &lt; targetWidth) {\n      line.width = lineWidth0 = lineWidth1;\n      line.text = lineText1;\n    } else {\n      lineWidth0 = measureWidth(words[i]);\n      line = {width: lineWidth0, text: words[i]};\n      lines.push(line);\n    }\n  }\n  return lines;\n}\n\nxmlns = \"http://www.w3.org/2000/xmlns/\"\n\nxlinkns = \"http://www.w3.org/1999/xlink\"\n\nsvgns = \"http://www.w3.org/2000/svg\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction Legend(color, {\n  title,\n  tickSize = 6,\n  width = 320, \n  height = 44 + tickSize,\n  marginTop = 18,\n  marginRight = 0,\n  marginBottom = 16 + tickSize,\n  marginLeft = 0,\n  ticks = width / 64,\n  tickFormat,\n  tickValues\n} = {}) {\n\n  function ramp(color, n = 256) {\n    const canvas = document.createElement(\"canvas\");\n    canvas.width = n;\n    canvas.height = 1;\n    const context = canvas.getContext(\"2d\");\n    for (let i = 0; i &lt; n; ++i) {\n      context.fillStyle = color(i / (n - 1));\n      context.fillRect(i, 0, 1, 1);\n    }\n    return canvas;\n  }\n\n  const svg = d3.create(\"svg\")\n      .attr(\"width\", width)\n      .attr(\"height\", height)\n      .attr(\"viewBox\", [0, 0, width, height])\n      .style(\"overflow\", \"visible\")\n      .style(\"display\", \"block\");\n\n  let tickAdjust = g =&gt; g.selectAll(\".tick line\").attr(\"y1\", marginTop + marginBottom - height);\n  let x;\n\n  // Continuous\n  if (color.interpolate) {\n    const n = Math.min(color.domain().length, color.range().length);\n\n    x = color.copy().rangeRound(d3.quantize(d3.interpolate(marginLeft, width - marginRight), n));\n\n    svg.append(\"image\")\n        .attr(\"x\", marginLeft)\n        .attr(\"y\", marginTop)\n        .attr(\"width\", width - marginLeft - marginRight)\n        .attr(\"height\", height - marginTop - marginBottom)\n        .attr(\"preserveAspectRatio\", \"none\")\n        .attr(\"xlink:href\", ramp(color.copy().domain(d3.quantize(d3.interpolate(0, 1), n))).toDataURL());\n  }\n\n  // Sequential\n  else if (color.interpolator) {\n    x = Object.assign(color.copy()\n        .interpolator(d3.interpolateRound(marginLeft, width - marginRight)),\n        {range() { return [marginLeft, width - marginRight]; }});\n\n    svg.append(\"image\")\n        .attr(\"x\", marginLeft)\n        .attr(\"y\", marginTop)\n        .attr(\"width\", width - marginLeft - marginRight)\n        .attr(\"height\", height - marginTop - marginBottom)\n        .attr(\"preserveAspectRatio\", \"none\")\n        .attr(\"xlink:href\", ramp(color.interpolator()).toDataURL());\n\n    // scaleSequentialQuantile doesn’t implement ticks or tickFormat.\n    if (!x.ticks) {\n      if (tickValues === undefined) {\n        const n = Math.round(ticks + 1);\n        tickValues = d3.range(n).map(i =&gt; d3.quantile(color.domain(), i / (n - 1)));\n      }\n      if (typeof tickFormat !== \"function\") {\n        tickFormat = d3.format(tickFormat === undefined ? \",f\" : tickFormat);\n      }\n    }\n  }\n\n  // Threshold\n  else if (color.invertExtent) {\n    const thresholds\n        = color.thresholds ? color.thresholds() // scaleQuantize\n        : color.quantiles ? color.quantiles() // scaleQuantile\n        : color.domain(); // scaleThreshold\n\n    const thresholdFormat\n        = tickFormat === undefined ? d =&gt; d\n        : typeof tickFormat === \"string\" ? d3.format(tickFormat)\n        : tickFormat;\n\n    x = d3.scaleLinear()\n        .domain([-1, color.range().length - 1])\n        .rangeRound([marginLeft, width - marginRight]);\n\n    svg.append(\"g\")\n      .selectAll(\"rect\")\n      .data(color.range())\n      .join(\"rect\")\n        .attr(\"x\", (d, i) =&gt; x(i - 1))\n        .attr(\"y\", marginTop)\n        .attr(\"width\", (d, i) =&gt; x(i) - x(i - 1))\n        .attr(\"height\", height - marginTop - marginBottom)\n        .attr(\"fill\", d =&gt; d);\n\n    tickValues = d3.range(thresholds.length);\n    tickFormat = i =&gt; thresholdFormat(thresholds[i], i);\n  }\n\n  // Ordinal\n  else {\n    x = d3.scaleBand()\n        .domain(color.domain())\n        .rangeRound([marginLeft, width - marginRight]);\n\n    svg.append(\"g\")\n      .selectAll(\"rect\")\n      .data(color.domain())\n      .join(\"rect\")\n        .attr(\"x\", x)\n        .attr(\"y\", marginTop)\n        .attr(\"width\", Math.max(0, x.bandwidth() - 1))\n        .attr(\"height\", height - marginTop - marginBottom)\n        .attr(\"fill\", color);\n\n    tickAdjust = () =&gt; {};\n  }\n\n  svg.append(\"g\")\n      .attr(\"transform\", `translate(0,${height - marginBottom})`)\n      .call(d3.axisBottom(x)\n        .ticks(ticks, typeof tickFormat === \"string\" ? tickFormat : undefined)\n        .tickFormat(typeof tickFormat === \"function\" ? tickFormat : undefined)\n        .tickSize(tickSize)\n        .tickValues(tickValues))\n      .call(tickAdjust)\n      .call(g =&gt; g.select(\".domain\").remove())\n      .call(g =&gt; g.append(\"text\")\n        .attr(\"x\", marginLeft)\n        .attr(\"y\", marginTop + marginBottom - height - 6)\n        .attr(\"fill\", \"currentColor\")\n        .attr(\"text-anchor\", \"start\")\n        .attr(\"font-weight\", \"bold\")\n        .style(\"font-size\", \"12px\")\n        .attr(\"class\", \"title\")\n        .text(title));\n\n  return svg.node();\n}\n\n\nfunction legend({color, ...options}) {\n  return Legend(color, options);\n}\n\n\n// Copyright 2021, Observable Inc.\n// Released under the ISC license.\n// https://observablehq.com/@d3/color-legend\nfunction Swatches(color, {\n  columns = null,\n  format,\n  unknown: formatUnknown,\n  swatchSize = 15,\n  swatchWidth = swatchSize,\n  swatchHeight = swatchSize,\n  marginLeft = 0\n} = {}) {\n  const id = `-swatches-${Math.random().toString(16).slice(2)}`;\n  const unknown = formatUnknown == null ? undefined : color.unknown();\n  const unknowns = unknown == null || unknown === d3.scaleImplicit ? [] : [unknown];\n  const domain = color.domain().concat(unknowns);\n  if (format === undefined) format = x =&gt; x === unknown ? formatUnknown : x;\n\n  function entity(character) {\n    return `&#${character.charCodeAt(0).toString()};`;\n  }\n\n  if (columns !== null) return htl.html`&lt;div style=\"display: flex; align-items: center; margin-left: ${+marginLeft}px; min-height: 33px; font: 12px sans-serif;\"&gt;\n  &lt;style&gt;\n\n.${id}-item {\n  break-inside: avoid;\n  display: flex;\n  align-items: center;\n  padding-bottom: 1px;\n}\n\n.${id}-label {\n  white-space: nowrap;\n  overflow: hidden;\n  text-overflow: ellipsis;\n  max-width: calc(100% - ${+swatchWidth}px - 0.5em);\n}\n\n.${id}-swatch {\n  width: ${+swatchWidth}px;\n  height: ${+swatchHeight}px;\n  margin: 0 0.5em 0 0;\n}\n\n  &lt;/style&gt;\n  &lt;div style=${{width: \"100%\", columns}}&gt;${domain.map(value =&gt; {\n    const label = `${format(value)}`;\n    return htl.html`&lt;div class=${id}-item&gt;\n      &lt;div class=${id}-swatch style=${{background: color(value)}}&gt;&lt;/div&gt;\n      &lt;div class=${id}-label title=${label}&gt;${label}&lt;/div&gt;\n    &lt;/div&gt;`;\n  })}\n  &lt;/div&gt;\n&lt;/div&gt;`;\n\n  return htl.html`&lt;div style=\"display: flex; align-items: center; min-height: 33px; margin-left: ${+marginLeft}px; font: 12px sans-serif;\"&gt;\n  &lt;style&gt;\n\n.${id} {\n  display: inline-flex;\n  align-items: center;\n  margin-right: 1em;\n}\n\n.${id}::before {\n  content: \"\";\n  width: ${+swatchWidth}px;\n  height: ${+swatchHeight}px;\n  margin-right: 0.5em;\n  background: var(--color);\n}\n\n  &lt;/style&gt;\n  &lt;div&gt;${domain.map(value =&gt; htl.html`&lt;span class=\"${id}\" style=\"--color: ${color(value)}\"&gt;${format(value)}&lt;/span&gt;`)}&lt;/div&gt;`;\n}\n\nfunction swatches({color, ...options}) {\n  return Swatches(color, options);\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nchart_map_d3 = function(data, mapTopoJSON, color, colorBorder, txtTitle, chart_width, chart_height) {\n\n  const projection = d3.geoMercator()\n  .scale(1200)\n  //.center([40, 67.5])\n  .center([40, 67.3])\n  .translate([400, 220])\n  const path = d3.geoPath().projection(projection);\n  const format = d =&gt; `${d}%`;\n  \n  //Määritellään tähän muuttujat CSV:stä!!!!!!\n  const valuemap = new Map(data.map(d =&gt; [d.id, d.muutos]));\n  \n  //Määritellään maakunnat\n  const maakuntamesh = topojson.mesh(maakunnat_2024_topo, maakunnat_2024_topo.objects.maakunnat_2024, (a, b) =&gt; a !== b);\n  \n  const zoom = d3.zoom()\n      .scaleExtent([1, 8])\n      .on(\"zoom\", zoomed);\n\n  const svg = d3.create(\"svg\")\n      .attr(\"width\", 900)\n      .attr(\"height\", 650)\n      .attr(\"viewBox\", [0, 0, 900, 650])\n      .on(\"click\", reset);\n      \n  const g = svg.append(\"g\")\n      .attr(\"transform\", \"translate(20,35)\")\n      .append(() =&gt; Legend(color, {title: txtTitle, width: 260}));\n\n  g.append(\"g\")\n    .selectAll(\"path\")\n    .data(mapTopoJSON)\n    .join(\"path\")\n      .attr(\"fill\", d =&gt; color(valuemap.get(d.properties.kunta))) \n      .attr(\"d\", path)\n    .append(\"title\")\n      .text(d =&gt; `${d.properties.name},\\n(${d.properties.nimi_2}),\\n${valuemap.get(d.properties.kunta)}`);\n      \n  g.append(\"path\")\n      .datum(maakuntamesh)\n      .attr(\"fill\", \"none\")\n      .attr(\"stroke\", colorBorder)\n      .attr(\"stroke-linejoin\", \"round\")\n      .attr(\"d\", path);\n      \n   svg.call(zoom);\n   \n\n  function reset() {\n    // states.transition().style(\"fill\", null);\n    svg.transition().duration(750).call(\n      zoom.transform,\n      d3.zoomIdentity,\n      d3.zoomTransform(svg.node()).invert([chart_width / 2, chart_height / 2])\n    );\n  }\n\n  function zoomed(event) {\n    const {transform} = event;\n    g.attr(\"transform\", transform);\n    g.attr(\"stroke-width\", 1 / transform.k);\n  }     \n      \n  return svg.node();\n}\n\n\n\n\n\n\n\nchart_chord_d3 = function(data, title_txt_chord, chart_width, chart_height) {\n\n  var sum_target;\n  var sum_source;\n  let vari;\n  var sum_yht;\n  \n  const margin = ({top: 20, right: 20, bottom: 0, left: 50});\n  const width = 300;\n  const height = width;\n  const innerRadius = Math.min(width, height) * .3 - 40;\n  const outerRadius = innerRadius + 15;\n  \n  \n  const chord = d3.chordDirected()\n    .padAngle(0.5 / innerRadius)\n    .sortSubgroups(d3.ascending)\n    .sortChords(d3.ascending);\n    \n  const ribbon = d3.ribbon()\n    .radius(innerRadius - 1)\n    .padAngle(0.5 / innerRadius);\n    \n  const rename = name =&gt; name.substring(name.indexOf(\".\") + 1, name.lastIndexOf(\".\"))\n  const names = Array.from(new Set(data.flatMap(d =&gt; [d.source, d.target]))).sort(d3.ascending);\n  \n  function matriisi(names) {\n    const index = new Map(names.map((name, i) =&gt; [name, i]));\n    const matrix = Array.from(index, () =&gt; new Array(names.length).fill(0));\n    for (const {source, target, value} of data) matrix[index.get(source)][index.get(target)] += value;\n    return matrix;\n  }\n\n const matrix = matriisi(names)\n  \n const arc = d3.arc()\n    .innerRadius(innerRadius)\n    .outerRadius(outerRadius)\n\n  //TÄSTÄ ALKAA PIIRROS\n  \n  const zoom = d3.zoom()\n      .scaleExtent([1, 8])\n      .on(\"zoom\", zoomed);\n  \n  const svg = d3.create(\"svg\")\n      .attr(\"viewBox\", [-width / 2, -height / 2.5, width, height]);\n\n  const chords = chord(matrix);\n  \n  const group = svg.append(\"g\")\n      .attr(\"font-size\", 3)\n      .attr(\"font-family\", \"Century Gothic\")\n    .selectAll(\"g\")\n    .data(chords.groups)\n    .join(\"g\");\n\n  group.append(\"path\")\n      .attr(\"fill\", d =&gt; {\n           sum_target = d3.sum(chords, c =&gt; (c.target.index === d.index) * c.target.value);\n           sum_source = d3.sum(chords, c =&gt; (c.source.index === d.index) * c.source.value);\n           sum_yht = sum_target-sum_source;\n            if (sum_yht &gt; 0) { \n              vari = \"#009651\"\n              return vari \n            }\n            else if (sum_yht == 0) { \n              vari = \"#28336C\"\n              return vari \n            }\n            else    { \n              vari = \"#DE232F\" \n              return vari \n            }\n        })\n      .attr(\"d\", arc);\n\n  group.append(\"text\")\n      .each(d =&gt; (d.angle = (d.startAngle + d.endAngle) / 2))\n      .attr(\"dy\", \"0.35em\")\n      .attr(\"transform\", d =&gt; `\n        rotate(${(d.angle * 180 / Math.PI - 90)})\n        translate(${outerRadius + 6})\n        ${d.angle &gt; Math.PI ? \"rotate(180)\" : \"\"}\n      `)\n      .attr(\"text-anchor\", d =&gt; d.angle &gt; Math.PI ? \"end\" : null)\n      //.text(d =&gt; names[d.index])\n      .text(d =&gt; (d.index &gt;= 3) ? names[d.index] : \"\")\n      .attr(\"fill\", d =&gt; {\n           sum_target = d3.sum(chords, c =&gt; (c.target.index === d.index) * c.target.value);\n           sum_source = d3.sum(chords, c =&gt; (c.source.index === d.index) * c.source.value);\n           sum_yht = sum_target-sum_source;\n            if (sum_yht &gt; 0) { \n              vari = \"#009651\"\n              return vari\n            }\n            else if (sum_yht == 0) { \n              vari = \"#28336C\"\n              return vari \n            }\n            else    { \n              vari = \"#DE232F\" \n              return vari \n            }\n        });\n\n  group.append(\"title\")\n      .text(d =&gt; `${names[d.index]} \n\n${d3.sum(chords, c =&gt; (c.source.index === d.index) * c.source.value)} lähtee →\n${d3.sum(chords, c =&gt; (c.target.index === d.index) * c.source.value)} tulee ←\n${d3.sum(chords, c =&gt; (c.target.index === d.index) * c.target.value)- d3.sum(chords, c =&gt; (c.source.index === d.index) * c.source.value)} netto =`);  \n\n  svg.append(\"g\")\n      .attr(\"fill-opacity\", 0.75)\n    .selectAll(\"path\")\n    .data(chords)\n    .join(\"path\")\n      .style(\"mix-blend-mode\", \"multiply\")\n          .attr(\"fill\", d =&gt; {\n           sum_target = d3.sum(chords, c =&gt; (c.target.index === d.index) * c.target.value);\n           sum_source = d3.sum(chords, c =&gt; (c.source.index === d.index) * c.source.value);\n           sum_yht = sum_target-sum_source;\n            if (sum_yht &gt; 0) { \n              vari = \"#009651\"\n              return vari \n            }\n            else if (sum_yht == 0) { \n              vari = \"#28336C\"\n              return vari \n            }\n            else    { \n              vari = \"#DE232F\" \n              return vari \n            }\n        })\n      .attr(\"d\", ribbon)\n    .append(\"title\")\n      .text(d =&gt; `${names[d.source.index]} --&gt; ${names[d.target.index]} ${d.source.value}`);\n      \n      \n  svg.call(zoom);\n   \n\n  function reset() {\n    // states.transition().style(\"fill\", null);\n    svg.transition().duration(750).call(\n      zoom.transform,\n      d3.zoomIdentity,\n      d3.zoomTransform(svg.node()).invert([chart_width / 2, chart_height / 2])\n    );\n  }\n\n  function zoomed(event) {\n    const {transform} = event;\n    svg.attr(\"transform\", transform);\n    svg.attr(\"stroke-width\", 1 / transform.k);\n  }    \n\n  return svg.node();\n\n\n}\n\n\n\n\n\n\n\nMuuttoliike\n\n\nKuntien välinen muuttoliike\nYmpyrä kuvaa kuntien välistä muuttoliikettä. Vihreällä olevat kunnat ovat muuttovoittajien ja punaisella olevat häviäjiä. Siniset viivat ympyrän keskellä kuvaavat muuttovirtojen suuruutta. Voit zoomata ympyrää hiiren rullalla. Laittamalla hiiren osoitin kuvan päälle näet muuttojen suuruudet ja liikesuunnat.\n\ndata = (await FileAttachmentDynamic(migrationChordCSV).csv());\n\n\nchart_chord_d3(data, title_txt_chord,chart_width,chart_height)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nDOM.download(() =&gt; serialize(chart_chord_d3(data, title_txt_chord,chart_width,chart_height)), title_txt_chord, \"Save as SVG\")"
  },
  {
    "objectID": "liikenne.html",
    "href": "liikenne.html",
    "title": "Liikenne",
    "section": "",
    "text": "d3 = require(\"d3@7\")\n//import {Legend} from \"@d3/color-legend\"\n\nfolderKunnat24TopoJSON = \"./maps/Kunnat2024Topo.json\"\nkunnat2024topo = FileAttachmentDynamic(folderKunnat24TopoJSON).json()\nmapTopoJSON = topojson.feature(kunnat2024topo, kunnat2024topo.objects.Kunnat2024_geo).features\n\n\nfolderMaakunnat24TopoJSON = \"./maps/Maakunnat2024Topo.json\"\nmaakunnat_2024_topo =  FileAttachmentDynamic(folderMaakunnat24TopoJSON).json()\nFileAttachmentDynamic = function(filename) {\n  return new Function(\"FileAttachment\", `return FileAttachment(\"${filename}\")`)(FileAttachment)\n}\n\n// Vaihdetaan tekstin väri\ncolor = function(vari) {\n  if(vari &gt; 0){\n      return \"green\"\n    }else{\n      return \"red\"\n    }\n}\n// Pyöristys\npyoristys = function(n, places) {\n  if (!places) return Math.round(n);\n  const d = 10 ** places;\n  return Math.round(n * d) / d;\n}\n//Euromerkintä\neurot = function(number) {\n  return number.toLocaleString('fi-FI', { style: 'currency', currency: 'EUR',minimumFractionDigits: 0 });\n}\n// Euromuutoksen laskeminen kertoimella\nmuutoskerroin = function(x, y) {\n  return (1+x/100)*y;\n}\n// Muutosprosentti\nmuutosprosentti = function(x, y) {\n  return pyoristys(((x-y)/y)*100,1);\n}\n// Tuhatjakaja\ntuhatjakaja = function(x) {\n  return x/1000;\n}\n// Euromuutoksen laskeminen kertoimella\npalkkakerroin = function(x, y) {\n  return 100*((1+x/100)*(1+y/100)-1);\n}\n// Jako-osuuden asukaskerroin\nasukaskerroin = function(x, y) {\n  return (x/y);\n}\n// Jako-osuuden veroprosenttikerroin miinus1/miinus3 vuotta miinus 1 vuoden kerroin\nveroprosenttikerroin = function(x, y) {\n  return (x/y);\n}\n// Kunnan muok. kunnallisvero, alkuvuosi ja loppuvuosi \nkunnallisvero_muokkaus = function(kunnallisvero,asukaskerroin,veroprosentti) {\n  return kunnallisvero*asukaskerroin*veroprosentti;\n}\n\n//Tekstimuutokset\nfn_nousu_lasku_txt = function(arvo){\n  if(arvo &gt; 0) {\n  return \"kasvanut\" \n  }\n  else { \n  return \"laskenut\";\n  }\n}\n\n//TARVITAAN KARTOISSA\nserialize = {\n  const xmlns = \"http://www.w3.org/2000/xmlns/\";\n  const xlinkns = \"http://www.w3.org/1999/xlink\";\n  const svgns = \"http://www.w3.org/2000/svg\";\n  return function serialize(svg) {\n    svg = svg.cloneNode(true);\n    const fragment = window.location.href + \"#\";\n    const walker = document.createTreeWalker(svg, NodeFilter.SHOW_ELEMENT);\n    while (walker.nextNode()) {\n      for (const attr of walker.currentNode.attributes) {\n        if (attr.value.includes(fragment)) {\n          attr.value = attr.value.replace(fragment, \"#\");\n        }\n      }\n    }\n    svg.setAttributeNS(xmlns, \"xmlns\", svgns);\n    svg.setAttributeNS(xmlns, \"xmlns:xlink\", xlinkns);\n    const serializer = new window.XMLSerializer;\n    const string = serializer.serializeToString(svg);\n    return new Blob([string], {type: \"image/svg+xml\"});\n  };\n}\n\n\nfunction toSVG(chart) {\n  if (chart.nodeName !== \"FIGURE\") {\n    return chart;\n  }\n\n  // the chart needs to be in the body if we want to read values, positions, sizes…\n  document.body.appendChild(chart);\n  const [x0, y0, width, height] = getBounds([chart]);\n\n  const nodes = [];\n\n  for (const node of d3\n    .select(chart)\n    .selectChildren(\"h1,h2,h3,div,figcaption,svg\")) {\n    switch (node.nodeName.toLowerCase()) {\n      case \"div\":\n        {\n          const children = d3.select(node).selectChildren(\"div,span\");\n          const height = getBounds([node, ...children])[3] + 2;\n          const svg = d3\n            .select(chart)\n            .append(\"svg\")\n            .attr(\"width\", width)\n            .attr(\"height\", height);\n          nodes.push(svg.node());\n\n          const swatches = svg\n            .selectAll()\n            .data(\n              Array.from(children, (d) =&gt; {\n                const svg = d3.select(d).select(\"svg\").node();\n                const bbox = svg.getBBox();\n                return {\n                  style: window.getComputedStyle(d),\n                  svg,\n                  width: bbox.width,\n                  height: bbox.height,\n                  text: d.textContent,\n                  bounds: getBounds([d])\n                };\n              })\n            )\n            .join(\"g\")\n            .attr(\n              \"transform\",\n              (d) =&gt; `translate(${d.bounds[0] - x0},${10 + d.bounds[1] - y0})`\n            );\n\n          swatches\n            .append((d) =&gt; d.svg) // \"rect\")\n            .attr(\"width\", (d) =&gt; d.width)\n            .attr(\"height\", (d) =&gt; d.height)\n            .attr(\"y\", (d) =&gt; `${-parseFloat(d.height) / 2}px`);\n          swatches\n            .append(\"text\")\n            .text((d) =&gt; d.text)\n            .attr(\"x\", (d) =&gt; d.width)\n            .attr(\"dx\", 5)\n            .attr(\"dy\", \"0.38em\")\n            .attr(\"font-family\", (d) =&gt; d.style.fontFamily)\n            .attr(\"font-size\", (d) =&gt; d.style.fontSize)\n            .attr(\"fill\", (d) =&gt; d.style.color);\n        }\n        break;\n      case \"figcaption\":\n      case \"h1\":\n      case \"h2\":\n      case \"h3\":\n        {\n          const svg = d3\n            .select(chart)\n            .append(\"svg\")\n            .attr(\"width\", width)\n            .attr(\"overflow\", \"visible\");\n          nodes.push(svg.node());\n\n          const children = d3.select(node).selectChildren();\n\n          let h = 0;\n          for (const d of children.size() &gt; 0\n            ? children.selectChildren()\n            : [node]) {\n            const style = window.getComputedStyle(d);\n            const t = svg\n              .append(\"g\")\n              .attr(\"transform\", `translate(0,${h})`)\n              .append(() =&gt;\n                d3\n                  .select(\n                    Plot.text([d.textContent], {\n                      text: (d) =&gt; d,\n                      lineWidth:\n                        (1.06 * parseFloat(style.width)) /\n                        parseFloat(style.fontSize),\n                      lineHeight: 1.2,\n                      frameAnchor: \"top-left\"\n                    }).plot()\n                  )\n                  .select(\"text\")\n                  .attr(\"font-family\", style.fontFamily)\n                  .attr(\"font-size\", 1.08 * parseFloat(style.fontSize))\n                  .attr(\"font-weight\", style.fontWeight)\n                  .attr(\"fill\", style.color)\n                  .node()\n              );\n            h += getBounds([t.node()])[3] + 4;\n          }\n          svg.attr(\"height\", h);\n        }\n        break;\n      case \"svg\":\n        d3.select(chart).append(() =&gt; node);\n        nodes.push(node);\n        break;\n    }\n  }\n\n  return serializeAll(nodes)\n    .then((blob) =&gt; blob.text())\n    .then((c) =&gt; {\n      document.body.removeChild(chart);\n      return Object.assign(svg`${c}`, chart);\n    });\n}\n\n\n// Given an array of SVG elements, composites them into a single SVG element,\n// and then serializes the result to a blob.\nasync function serializeAll(elements, {padding = 10} = {}) {\n  const fragment = location.href + \"#\";\n  let root;\n  if (elements.length === 1) {\n    root = elements[0].cloneNode(true); // optimize common case\n  } else {\n    const [ox, oy, dx, dy] = getBounds(elements);\n    root = document.createElementNS(svgns, \"svg\");\n    root.setAttribute(\"width\", dx + 2 * padding);\n    root.setAttribute(\"height\", dy + 2 * padding);\n    root.setAttribute(\"viewBox\", [-padding, -padding, dx + 2 * padding, dy + 2 * padding]);\n    for (const element of elements) {\n      const svg = root.appendChild(element.cloneNode(true));\n      const { x, y, width, height } = element.getBoundingClientRect();\n      svg.setAttribute(\"x\", x - ox);\n      svg.setAttribute(\"y\", y - oy);\n      svg.setAttribute(\"width\", width);\n      svg.setAttribute(\"height\", height);\n    }\n  }\n  const walker = document.createTreeWalker(root, NodeFilter.SHOW_ELEMENT);\n  while (walker.nextNode()) {\n    const node = walker.currentNode;\n    for (const attr of node.attributes) {\n      if (attr.value.includes(fragment)) {\n        attr.value = attr.value.replace(fragment, \"#\");\n      }\n    }\n  }\n  root.setAttributeNS(xmlns, \"xmlns\", svgns);\n  root.setAttributeNS(xmlns, \"xmlns:xlink\", xlinkns);\n  const serializer = new XMLSerializer();\n  const string = serializer.serializeToString(root);\n  return new Blob([string], { type: \"image/svg+xml\" });\n}\n\n\nfunction getBounds(elements) {\n  let x1 = Infinity;\n  let y1 = x1;\n  let x2 = -x1;\n  let y2 = x2;\n  for (const element of elements) {\n    const { x, y, width, height } = element.getBoundingClientRect();\n    if (x &lt; x1) x1 = x;\n    if (x + width &gt; x2) x2 = x + width;\n    if (y &lt; y1) y1 = y;\n    if (y + height &gt; y2) y2 = y + height;\n  }\n  return [x1, y1, x2 - x1, y2 - y1];\n}\n\n// based on https://observablehq.com/@gka/cheap-fit-text-to-circle\nfunction lines(text, targetWidth) {\n  const CHAR_W = {\n    \"a\":7,\"B\":8,\"C\":8,\"c\":6,\"D\":9,\"f\":4,\"G\":9,\"H\":9,\"I\":3,\"i\":3,\"J\":5,\"j\":3,\"K\":8,\"k\":6,\n    \"l\":3,\"M\":11,\"m\":11,\"N\":9,\"O\":9,\"P\":8,\"Q\":9,\"R\":8,\"r\":4,\"S\":8,\"s\":6,\"t\":4,\"U\":9,\"v\":6,\n    \"W\":11,\"w\":9,\"x\":6,\"y\":6,\"z\":5,\".\":2,\",\":2,\":\":2,\";\":2\n  };\n  function measureWidth(text) { return  d3.sum(text, char =&gt; CHAR_W[char] || CHAR_W[\"a\"]) * 0.8; };\n\n  const words = text.split(\" \");\n  let line;\n  let lineWidth0 = Infinity;\n  const lines = [];\n  for (let i = 0, n = words.length; i &lt; n; ++i) {\n    let lineText1 = (line ? line.text + \" \" : \"\") + words[i];\n    let lineWidth1 = measureWidth(lineText1);\n    if ((lineWidth0 + lineWidth1) / 2 &lt; targetWidth) {\n      line.width = lineWidth0 = lineWidth1;\n      line.text = lineText1;\n    } else {\n      lineWidth0 = measureWidth(words[i]);\n      line = {width: lineWidth0, text: words[i]};\n      lines.push(line);\n    }\n  }\n  return lines;\n}\n\nxmlns = \"http://www.w3.org/2000/xmlns/\"\n\nxlinkns = \"http://www.w3.org/1999/xlink\"\n\nsvgns = \"http://www.w3.org/2000/svg\"\nfunction Legend(color, {\n  title,\n  tickSize = 6,\n  width = 320, \n  height = 44 + tickSize,\n  marginTop = 18,\n  marginRight = 0,\n  marginBottom = 16 + tickSize,\n  marginLeft = 0,\n  ticks = width / 64,\n  tickFormat,\n  tickValues\n} = {}) {\n\n  function ramp(color, n = 256) {\n    const canvas = document.createElement(\"canvas\");\n    canvas.width = n;\n    canvas.height = 1;\n    const context = canvas.getContext(\"2d\");\n    for (let i = 0; i &lt; n; ++i) {\n      context.fillStyle = color(i / (n - 1));\n      context.fillRect(i, 0, 1, 1);\n    }\n    return canvas;\n  }\n\n  const svg = d3.create(\"svg\")\n      .attr(\"width\", width)\n      .attr(\"height\", height)\n      .attr(\"viewBox\", [0, 0, width, height])\n      .style(\"overflow\", \"visible\")\n      .style(\"display\", \"block\");\n\n  let tickAdjust = g =&gt; g.selectAll(\".tick line\").attr(\"y1\", marginTop + marginBottom - height);\n  let x;\n\n  // Continuous\n  if (color.interpolate) {\n    const n = Math.min(color.domain().length, color.range().length);\n\n    x = color.copy().rangeRound(d3.quantize(d3.interpolate(marginLeft, width - marginRight), n));\n\n    svg.append(\"image\")\n        .attr(\"x\", marginLeft)\n        .attr(\"y\", marginTop)\n        .attr(\"width\", width - marginLeft - marginRight)\n        .attr(\"height\", height - marginTop - marginBottom)\n        .attr(\"preserveAspectRatio\", \"none\")\n        .attr(\"xlink:href\", ramp(color.copy().domain(d3.quantize(d3.interpolate(0, 1), n))).toDataURL());\n  }\n\n  // Sequential\n  else if (color.interpolator) {\n    x = Object.assign(color.copy()\n        .interpolator(d3.interpolateRound(marginLeft, width - marginRight)),\n        {range() { return [marginLeft, width - marginRight]; }});\n\n    svg.append(\"image\")\n        .attr(\"x\", marginLeft)\n        .attr(\"y\", marginTop)\n        .attr(\"width\", width - marginLeft - marginRight)\n        .attr(\"height\", height - marginTop - marginBottom)\n        .attr(\"preserveAspectRatio\", \"none\")\n        .attr(\"xlink:href\", ramp(color.interpolator()).toDataURL());\n\n    // scaleSequentialQuantile doesn’t implement ticks or tickFormat.\n    if (!x.ticks) {\n      if (tickValues === undefined) {\n        const n = Math.round(ticks + 1);\n        tickValues = d3.range(n).map(i =&gt; d3.quantile(color.domain(), i / (n - 1)));\n      }\n      if (typeof tickFormat !== \"function\") {\n        tickFormat = d3.format(tickFormat === undefined ? \",f\" : tickFormat);\n      }\n    }\n  }\n\n  // Threshold\n  else if (color.invertExtent) {\n    const thresholds\n        = color.thresholds ? color.thresholds() // scaleQuantize\n        : color.quantiles ? color.quantiles() // scaleQuantile\n        : color.domain(); // scaleThreshold\n\n    const thresholdFormat\n        = tickFormat === undefined ? d =&gt; d\n        : typeof tickFormat === \"string\" ? d3.format(tickFormat)\n        : tickFormat;\n\n    x = d3.scaleLinear()\n        .domain([-1, color.range().length - 1])\n        .rangeRound([marginLeft, width - marginRight]);\n\n    svg.append(\"g\")\n      .selectAll(\"rect\")\n      .data(color.range())\n      .join(\"rect\")\n        .attr(\"x\", (d, i) =&gt; x(i - 1))\n        .attr(\"y\", marginTop)\n        .attr(\"width\", (d, i) =&gt; x(i) - x(i - 1))\n        .attr(\"height\", height - marginTop - marginBottom)\n        .attr(\"fill\", d =&gt; d);\n\n    tickValues = d3.range(thresholds.length);\n    tickFormat = i =&gt; thresholdFormat(thresholds[i], i);\n  }\n\n  // Ordinal\n  else {\n    x = d3.scaleBand()\n        .domain(color.domain())\n        .rangeRound([marginLeft, width - marginRight]);\n\n    svg.append(\"g\")\n      .selectAll(\"rect\")\n      .data(color.domain())\n      .join(\"rect\")\n        .attr(\"x\", x)\n        .attr(\"y\", marginTop)\n        .attr(\"width\", Math.max(0, x.bandwidth() - 1))\n        .attr(\"height\", height - marginTop - marginBottom)\n        .attr(\"fill\", color);\n\n    tickAdjust = () =&gt; {};\n  }\n\n  svg.append(\"g\")\n      .attr(\"transform\", `translate(0,${height - marginBottom})`)\n      .call(d3.axisBottom(x)\n        .ticks(ticks, typeof tickFormat === \"string\" ? tickFormat : undefined)\n        .tickFormat(typeof tickFormat === \"function\" ? tickFormat : undefined)\n        .tickSize(tickSize)\n        .tickValues(tickValues))\n      .call(tickAdjust)\n      .call(g =&gt; g.select(\".domain\").remove())\n      .call(g =&gt; g.append(\"text\")\n        .attr(\"x\", marginLeft)\n        .attr(\"y\", marginTop + marginBottom - height - 6)\n        .attr(\"fill\", \"currentColor\")\n        .attr(\"text-anchor\", \"start\")\n        .attr(\"font-weight\", \"bold\")\n        .style(\"font-size\", \"12px\")\n        .attr(\"class\", \"title\")\n        .text(title));\n\n  return svg.node();\n}\n\n\nfunction legend({color, ...options}) {\n  return Legend(color, options);\n}\n\n\n// Copyright 2021, Observable Inc.\n// Released under the ISC license.\n// https://observablehq.com/@d3/color-legend\nfunction Swatches(color, {\n  columns = null,\n  format,\n  unknown: formatUnknown,\n  swatchSize = 15,\n  swatchWidth = swatchSize,\n  swatchHeight = swatchSize,\n  marginLeft = 0\n} = {}) {\n  const id = `-swatches-${Math.random().toString(16).slice(2)}`;\n  const unknown = formatUnknown == null ? undefined : color.unknown();\n  const unknowns = unknown == null || unknown === d3.scaleImplicit ? [] : [unknown];\n  const domain = color.domain().concat(unknowns);\n  if (format === undefined) format = x =&gt; x === unknown ? formatUnknown : x;\n\n  function entity(character) {\n    return `&#${character.charCodeAt(0).toString()};`;\n  }\n\n  if (columns !== null) return htl.html`&lt;div style=\"display: flex; align-items: center; margin-left: ${+marginLeft}px; min-height: 33px; font: 12px sans-serif;\"&gt;\n  &lt;style&gt;\n\n.${id}-item {\n  break-inside: avoid;\n  display: flex;\n  align-items: center;\n  padding-bottom: 1px;\n}\n\n.${id}-label {\n  white-space: nowrap;\n  overflow: hidden;\n  text-overflow: ellipsis;\n  max-width: calc(100% - ${+swatchWidth}px - 0.5em);\n}\n\n.${id}-swatch {\n  width: ${+swatchWidth}px;\n  height: ${+swatchHeight}px;\n  margin: 0 0.5em 0 0;\n}\n\n  &lt;/style&gt;\n  &lt;div style=${{width: \"100%\", columns}}&gt;${domain.map(value =&gt; {\n    const label = `${format(value)}`;\n    return htl.html`&lt;div class=${id}-item&gt;\n      &lt;div class=${id}-swatch style=${{background: color(value)}}&gt;&lt;/div&gt;\n      &lt;div class=${id}-label title=${label}&gt;${label}&lt;/div&gt;\n    &lt;/div&gt;`;\n  })}\n  &lt;/div&gt;\n&lt;/div&gt;`;\n\n  return htl.html`&lt;div style=\"display: flex; align-items: center; min-height: 33px; margin-left: ${+marginLeft}px; font: 12px sans-serif;\"&gt;\n  &lt;style&gt;\n\n.${id} {\n  display: inline-flex;\n  align-items: center;\n  margin-right: 1em;\n}\n\n.${id}::before {\n  content: \"\";\n  width: ${+swatchWidth}px;\n  height: ${+swatchHeight}px;\n  margin-right: 0.5em;\n  background: var(--color);\n}\n\n  &lt;/style&gt;\n  &lt;div&gt;${domain.map(value =&gt; htl.html`&lt;span class=\"${id}\" style=\"--color: ${color(value)}\"&gt;${format(value)}&lt;/span&gt;`)}&lt;/div&gt;`;\n}\n\nfunction swatches({color, ...options}) {\n  return Swatches(color, options);\n}\nchart_map_d3 = function(data, mapTopoJSON, color, colorBorder, txtTitle, chart_width, chart_height) {\n\n  const projection = d3.geoMercator()\n  .scale(1200)\n  //.center([40, 67.5])\n  .center([40, 67.3])\n  .translate([400, 220])\n  const path = d3.geoPath().projection(projection);\n  const format = d =&gt; `${d}%`;\n  \n  //Määritellään tähän muuttujat CSV:stä!!!!!!\n  const valuemap = new Map(data.map(d =&gt; [d.id, d.muutos]));\n  \n  //Määritellään maakunnat\n  const maakuntamesh = topojson.mesh(maakunnat_2024_topo, maakunnat_2024_topo.objects.maakunnat_2024, (a, b) =&gt; a !== b);\n  \n  const zoom = d3.zoom()\n      .scaleExtent([1, 8])\n      .on(\"zoom\", zoomed);\n\n  const svg = d3.create(\"svg\")\n      .attr(\"width\", 900)\n      .attr(\"height\", 650)\n      .attr(\"viewBox\", [0, 0, 900, 650])\n      .on(\"click\", reset);\n      \n  const g = svg.append(\"g\")\n      .attr(\"transform\", \"translate(20,35)\")\n      .append(() =&gt; Legend(color, {title: txtTitle, width: 260}));\n\n  g.append(\"g\")\n    .selectAll(\"path\")\n    .data(mapTopoJSON)\n    .join(\"path\")\n      .attr(\"fill\", d =&gt; color(valuemap.get(d.properties.kunta))) \n      .attr(\"d\", path)\n    .append(\"title\")\n      .text(d =&gt; `${d.properties.name},\\n(${d.properties.nimi_2}),\\n${valuemap.get(d.properties.kunta)}`);\n      \n  g.append(\"path\")\n      .datum(maakuntamesh)\n      .attr(\"fill\", \"none\")\n      .attr(\"stroke\", colorBorder)\n      .attr(\"stroke-linejoin\", \"round\")\n      .attr(\"d\", path);\n      \n   svg.call(zoom);\n   \n\n  function reset() {\n    // states.transition().style(\"fill\", null);\n    svg.transition().duration(750).call(\n      zoom.transform,\n      d3.zoomIdentity,\n      d3.zoomTransform(svg.node()).invert([chart_width / 2, chart_height / 2])\n    );\n  }\n\n  function zoomed(event) {\n    const {transform} = event;\n    g.attr(\"transform\", transform);\n    g.attr(\"stroke-width\", 1 / transform.k);\n  }     \n      \n  return svg.node();\n}\nchart_chord_d3 = function(data, title_txt_chord, chart_width, chart_height) {\n\n  var sum_target;\n  var sum_source;\n  let vari;\n  var sum_yht;\n  \n  const margin = ({top: 20, right: 20, bottom: 0, left: 50});\n  const width = 300;\n  const height = width;\n  const innerRadius = Math.min(width, height) * .3 - 40;\n  const outerRadius = innerRadius + 15;\n  \n  \n  const chord = d3.chordDirected()\n    .padAngle(0.5 / innerRadius)\n    .sortSubgroups(d3.ascending)\n    .sortChords(d3.ascending);\n    \n  const ribbon = d3.ribbon()\n    .radius(innerRadius - 1)\n    .padAngle(0.5 / innerRadius);\n    \n  const rename = name =&gt; name.substring(name.indexOf(\".\") + 1, name.lastIndexOf(\".\"))\n  const names = Array.from(new Set(data.flatMap(d =&gt; [d.source, d.target]))).sort(d3.ascending);\n  \n  function matriisi(names) {\n    const index = new Map(names.map((name, i) =&gt; [name, i]));\n    const matrix = Array.from(index, () =&gt; new Array(names.length).fill(0));\n    for (const {source, target, value} of data) matrix[index.get(source)][index.get(target)] += value;\n    return matrix;\n  }\n\n const matrix = matriisi(names)\n  \n const arc = d3.arc()\n    .innerRadius(innerRadius)\n    .outerRadius(outerRadius)\n\n  //TÄSTÄ ALKAA PIIRROS\n  \n  const zoom = d3.zoom()\n      .scaleExtent([1, 8])\n      .on(\"zoom\", zoomed);\n  \n  const svg = d3.create(\"svg\")\n      .attr(\"viewBox\", [-width / 2, -height / 2.5, width, height]);\n\n  const chords = chord(matrix);\n  \n  const group = svg.append(\"g\")\n      .attr(\"font-size\", 3)\n      .attr(\"font-family\", \"Century Gothic\")\n    .selectAll(\"g\")\n    .data(chords.groups)\n    .join(\"g\");\n\n  group.append(\"path\")\n      .attr(\"fill\", d =&gt; {\n           sum_target = d3.sum(chords, c =&gt; (c.target.index === d.index) * c.target.value);\n           sum_source = d3.sum(chords, c =&gt; (c.source.index === d.index) * c.source.value);\n           sum_yht = sum_target-sum_source;\n            if (sum_yht &gt; 0) { \n              vari = \"#009651\"\n              return vari \n            }\n            else if (sum_yht == 0) { \n              vari = \"#28336C\"\n              return vari \n            }\n            else    { \n              vari = \"#DE232F\" \n              return vari \n            }\n        })\n      .attr(\"d\", arc);\n\n  group.append(\"text\")\n      .each(d =&gt; (d.angle = (d.startAngle + d.endAngle) / 2))\n      .attr(\"dy\", \"0.35em\")\n      .attr(\"transform\", d =&gt; `\n        rotate(${(d.angle * 180 / Math.PI - 90)})\n        translate(${outerRadius + 6})\n        ${d.angle &gt; Math.PI ? \"rotate(180)\" : \"\"}\n      `)\n      .attr(\"text-anchor\", d =&gt; d.angle &gt; Math.PI ? \"end\" : null)\n      //.text(d =&gt; names[d.index])\n      .text(d =&gt; (d.index &gt;= 3) ? names[d.index] : \"\")\n      .attr(\"fill\", d =&gt; {\n           sum_target = d3.sum(chords, c =&gt; (c.target.index === d.index) * c.target.value);\n           sum_source = d3.sum(chords, c =&gt; (c.source.index === d.index) * c.source.value);\n           sum_yht = sum_target-sum_source;\n            if (sum_yht &gt; 0) { \n              vari = \"#009651\"\n              return vari\n            }\n            else if (sum_yht == 0) { \n              vari = \"#28336C\"\n              return vari \n            }\n            else    { \n              vari = \"#DE232F\" \n              return vari \n            }\n        });\n\n  group.append(\"title\")\n      .text(d =&gt; `${names[d.index]} \n\n${d3.sum(chords, c =&gt; (c.source.index === d.index) * c.source.value)} lähtee →\n${d3.sum(chords, c =&gt; (c.target.index === d.index) * c.source.value)} tulee ←\n${d3.sum(chords, c =&gt; (c.target.index === d.index) * c.target.value)- d3.sum(chords, c =&gt; (c.source.index === d.index) * c.source.value)} netto =`);  \n\n  svg.append(\"g\")\n      .attr(\"fill-opacity\", 0.75)\n    .selectAll(\"path\")\n    .data(chords)\n    .join(\"path\")\n      .style(\"mix-blend-mode\", \"multiply\")\n          .attr(\"fill\", d =&gt; {\n           sum_target = d3.sum(chords, c =&gt; (c.target.index === d.index) * c.target.value);\n           sum_source = d3.sum(chords, c =&gt; (c.source.index === d.index) * c.source.value);\n           sum_yht = sum_target-sum_source;\n            if (sum_yht &gt; 0) { \n              vari = \"#009651\"\n              return vari \n            }\n            else if (sum_yht == 0) { \n              vari = \"#28336C\"\n              return vari \n            }\n            else    { \n              vari = \"#DE232F\" \n              return vari \n            }\n        })\n      .attr(\"d\", ribbon)\n    .append(\"title\")\n      .text(d =&gt; `${names[d.source.index]} --&gt; ${names[d.target.index]} ${d.source.value}`);\n      \n      \n  svg.call(zoom);\n   \n\n  function reset() {\n    // states.transition().style(\"fill\", null);\n    svg.transition().duration(750).call(\n      zoom.transform,\n      d3.zoomIdentity,\n      d3.zoomTransform(svg.node()).invert([chart_width / 2, chart_height / 2])\n    );\n  }\n\n  function zoomed(event) {\n    const {transform} = event;\n    svg.attr(\"transform\", transform);\n    svg.attr(\"stroke-width\", 1 / transform.k);\n  }    \n\n  return svg.node();\n\n\n}"
  },
  {
    "objectID": "liikenne.html#liikennemäärät",
    "href": "liikenne.html#liikennemäärät",
    "title": "Liikenne",
    "section": "Liikennemäärät",
    "text": "Liikennemäärät\n\nKartta LAM-antureista\nFintraffic kerää tietoa tieliikenteestä liikenteen automaattisten mittausasemien (LAM) avulla. Klikkaamalla kartan nuppineulaa saat auki lähimpien LAM-anturien tiedot alueellasi. Mittausajankohtia verrataan neljän vuoden ajalta samaan päivämäärään (2024-09-21) Lähde: (Fintraffic.fi 2024)\n\n\n\n\n\n\n\n\nLiikennemäärä yhteensä\nLiikennettä oli ajanjaksolla 2024-09-21 suunnassa vt8 Masku -&gt; Vaasa yhteensä 9637. Vastaavasti suunnassa vt8 Masku -&gt; Vaasa yhteensä 7167.\n\n\n\n\n\n\n\n\nHenkilö- tai pakettiauto\nHenkilö- tai pakettiautoliikennettä oli suunnassa vt8 Masku -&gt; Vaasa yhteensä 8913. Suunnan vt8 Masku -&gt; Vaasa liikennemäärä oli yhteensä 6924.\n\n\n\n\n\n\n\n\nKuorma-autot\nKuorma-autojen liikennemäärä oli suunnassa vt8 Masku -&gt; Vaasa yhteensä 596. Suunnan vt8 Masku -&gt; Vaasa kuorma-automäärä oli yhteensä 167.\n\n\n\n\n\n\n\n\nLinja-autot\nLinja-autoja liikkui suunnassa vt8 Masku -&gt; Vaasa yhteensä 25. Vastaavasti suunnassa vt8 Masku -&gt; Vaasa linja-autoja oli yhteensä 19.\n\n\n\n\n\n\n\n\nHenkilöauto ja asuntovaunu\nAsuntovaunujen kanssa liikkuvia henkilöautoja oli suunnassa vt8 Masku -&gt; Vaasa yhteensä 24 ja suunnassa vt8 Masku -&gt; Vaasa yhteensä 22.\n\n\n\n\n\n\n\n\nMoottoripyörät ja mopot\n\n\n\n\n\n\n\n\nHCT (High Capacity Truck)\nLyhenne HCT tulee sanoista High Capacity Transport. Lyhenne on kansainvälisesti vakiintunut termi sallittua pidemmille tai raskaammille yhdistelmille tieliikenteessä, joita ei kuitenkaan pidetä erikoiskuljetuksina."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Alkusanat",
    "section": "",
    "text": "Alkusanat\nKuukausiraportti tarjoaa tietoa väestöstä, työmarkkinoista, asumisesta, rakentamisesta ja taloudesta kuukausi tai neljännesvuositasolla. Tietolähteinä käytetään esimerkiksi Tilastokeskuksen ja Verohallinon tilastoaineistoa. Kuukausiraporttia kehitetään yhteistyössä kuntien kanssa.\nRaportti on ajettu syyskuussa, 2024\nRaportti on julkaistu (GNU.org 2024) lisenssin alla. Kuukausiraportti on html-muodossa. Malleja kuntakohtaisesta raporteista löytyy osoitteista:\n\nKangasala: https://kangasalakehitys.github.io/kuukausiraportti/\nAkaa: https://kangasalakehitys.github.io/akaa/\nJuupajoki: https://kangasalakehitys.github.io/juupajoki/\nKuhmoinen: https://kangasalakehitys.github.io/kuhmoinen/\nMasku: https://kangasalakehitys.github.io/masku/\nNousinen: https://kangasalakehitys.github.io/nousiainen/\nPälkäne: https://kangasalakehitys.github.io/palkane/\nParkano: https://kangasalakehitys.github.io/parkano/\nUrjala: https://kangasalakehitys.github.io/urjala/\nYlöjärvi: https://kangasalakehitys.github.io/ylojarvi/\n\n\n\n\n\n\nLähteet\n\nGNU.org. 2024. LGPL 2.1 lisenssi. GNU.org. https://www.gnu.org/licenses/old-licenses/lgpl-2.1.en.html."
  },
  {
    "objectID": "asuminen.html",
    "href": "asuminen.html",
    "title": "Asuminen",
    "section": "",
    "text": "d3 = require(\"d3@7\")\n//import {Legend} from \"@d3/color-legend\"\n\nfolderKunnat24TopoJSON = \"./maps/Kunnat2024Topo.json\"\nkunnat2024topo = FileAttachmentDynamic(folderKunnat24TopoJSON).json()\nmapTopoJSON = topojson.feature(kunnat2024topo, kunnat2024topo.objects.Kunnat2024_geo).features\n\n\nfolderMaakunnat24TopoJSON = \"./maps/Maakunnat2024Topo.json\"\nmaakunnat_2024_topo =  FileAttachmentDynamic(folderMaakunnat24TopoJSON).json()\nFileAttachmentDynamic = function(filename) {\n  return new Function(\"FileAttachment\", `return FileAttachment(\"${filename}\")`)(FileAttachment)\n}\n\n// Vaihdetaan tekstin väri\ncolor = function(vari) {\n  if(vari &gt; 0){\n      return \"green\"\n    }else{\n      return \"red\"\n    }\n}\n// Pyöristys\npyoristys = function(n, places) {\n  if (!places) return Math.round(n);\n  const d = 10 ** places;\n  return Math.round(n * d) / d;\n}\n//Euromerkintä\neurot = function(number) {\n  return number.toLocaleString('fi-FI', { style: 'currency', currency: 'EUR',minimumFractionDigits: 0 });\n}\n// Euromuutoksen laskeminen kertoimella\nmuutoskerroin = function(x, y) {\n  return (1+x/100)*y;\n}\n// Muutosprosentti\nmuutosprosentti = function(x, y) {\n  return pyoristys(((x-y)/y)*100,1);\n}\n// Tuhatjakaja\ntuhatjakaja = function(x) {\n  return x/1000;\n}\n// Euromuutoksen laskeminen kertoimella\npalkkakerroin = function(x, y) {\n  return 100*((1+x/100)*(1+y/100)-1);\n}\n// Jako-osuuden asukaskerroin\nasukaskerroin = function(x, y) {\n  return (x/y);\n}\n// Jako-osuuden veroprosenttikerroin miinus1/miinus3 vuotta miinus 1 vuoden kerroin\nveroprosenttikerroin = function(x, y) {\n  return (x/y);\n}\n// Kunnan muok. kunnallisvero, alkuvuosi ja loppuvuosi \nkunnallisvero_muokkaus = function(kunnallisvero,asukaskerroin,veroprosentti) {\n  return kunnallisvero*asukaskerroin*veroprosentti;\n}\n\n//Tekstimuutokset\nfn_nousu_lasku_txt = function(arvo){\n  if(arvo &gt; 0) {\n  return \"kasvanut\" \n  }\n  else { \n  return \"laskenut\";\n  }\n}\n\n//TARVITAAN KARTOISSA\nserialize = {\n  const xmlns = \"http://www.w3.org/2000/xmlns/\";\n  const xlinkns = \"http://www.w3.org/1999/xlink\";\n  const svgns = \"http://www.w3.org/2000/svg\";\n  return function serialize(svg) {\n    svg = svg.cloneNode(true);\n    const fragment = window.location.href + \"#\";\n    const walker = document.createTreeWalker(svg, NodeFilter.SHOW_ELEMENT);\n    while (walker.nextNode()) {\n      for (const attr of walker.currentNode.attributes) {\n        if (attr.value.includes(fragment)) {\n          attr.value = attr.value.replace(fragment, \"#\");\n        }\n      }\n    }\n    svg.setAttributeNS(xmlns, \"xmlns\", svgns);\n    svg.setAttributeNS(xmlns, \"xmlns:xlink\", xlinkns);\n    const serializer = new window.XMLSerializer;\n    const string = serializer.serializeToString(svg);\n    return new Blob([string], {type: \"image/svg+xml\"});\n  };\n}\n\n\nfunction toSVG(chart) {\n  if (chart.nodeName !== \"FIGURE\") {\n    return chart;\n  }\n\n  // the chart needs to be in the body if we want to read values, positions, sizes…\n  document.body.appendChild(chart);\n  const [x0, y0, width, height] = getBounds([chart]);\n\n  const nodes = [];\n\n  for (const node of d3\n    .select(chart)\n    .selectChildren(\"h1,h2,h3,div,figcaption,svg\")) {\n    switch (node.nodeName.toLowerCase()) {\n      case \"div\":\n        {\n          const children = d3.select(node).selectChildren(\"div,span\");\n          const height = getBounds([node, ...children])[3] + 2;\n          const svg = d3\n            .select(chart)\n            .append(\"svg\")\n            .attr(\"width\", width)\n            .attr(\"height\", height);\n          nodes.push(svg.node());\n\n          const swatches = svg\n            .selectAll()\n            .data(\n              Array.from(children, (d) =&gt; {\n                const svg = d3.select(d).select(\"svg\").node();\n                const bbox = svg.getBBox();\n                return {\n                  style: window.getComputedStyle(d),\n                  svg,\n                  width: bbox.width,\n                  height: bbox.height,\n                  text: d.textContent,\n                  bounds: getBounds([d])\n                };\n              })\n            )\n            .join(\"g\")\n            .attr(\n              \"transform\",\n              (d) =&gt; `translate(${d.bounds[0] - x0},${10 + d.bounds[1] - y0})`\n            );\n\n          swatches\n            .append((d) =&gt; d.svg) // \"rect\")\n            .attr(\"width\", (d) =&gt; d.width)\n            .attr(\"height\", (d) =&gt; d.height)\n            .attr(\"y\", (d) =&gt; `${-parseFloat(d.height) / 2}px`);\n          swatches\n            .append(\"text\")\n            .text((d) =&gt; d.text)\n            .attr(\"x\", (d) =&gt; d.width)\n            .attr(\"dx\", 5)\n            .attr(\"dy\", \"0.38em\")\n            .attr(\"font-family\", (d) =&gt; d.style.fontFamily)\n            .attr(\"font-size\", (d) =&gt; d.style.fontSize)\n            .attr(\"fill\", (d) =&gt; d.style.color);\n        }\n        break;\n      case \"figcaption\":\n      case \"h1\":\n      case \"h2\":\n      case \"h3\":\n        {\n          const svg = d3\n            .select(chart)\n            .append(\"svg\")\n            .attr(\"width\", width)\n            .attr(\"overflow\", \"visible\");\n          nodes.push(svg.node());\n\n          const children = d3.select(node).selectChildren();\n\n          let h = 0;\n          for (const d of children.size() &gt; 0\n            ? children.selectChildren()\n            : [node]) {\n            const style = window.getComputedStyle(d);\n            const t = svg\n              .append(\"g\")\n              .attr(\"transform\", `translate(0,${h})`)\n              .append(() =&gt;\n                d3\n                  .select(\n                    Plot.text([d.textContent], {\n                      text: (d) =&gt; d,\n                      lineWidth:\n                        (1.06 * parseFloat(style.width)) /\n                        parseFloat(style.fontSize),\n                      lineHeight: 1.2,\n                      frameAnchor: \"top-left\"\n                    }).plot()\n                  )\n                  .select(\"text\")\n                  .attr(\"font-family\", style.fontFamily)\n                  .attr(\"font-size\", 1.08 * parseFloat(style.fontSize))\n                  .attr(\"font-weight\", style.fontWeight)\n                  .attr(\"fill\", style.color)\n                  .node()\n              );\n            h += getBounds([t.node()])[3] + 4;\n          }\n          svg.attr(\"height\", h);\n        }\n        break;\n      case \"svg\":\n        d3.select(chart).append(() =&gt; node);\n        nodes.push(node);\n        break;\n    }\n  }\n\n  return serializeAll(nodes)\n    .then((blob) =&gt; blob.text())\n    .then((c) =&gt; {\n      document.body.removeChild(chart);\n      return Object.assign(svg`${c}`, chart);\n    });\n}\n\n\n// Given an array of SVG elements, composites them into a single SVG element,\n// and then serializes the result to a blob.\nasync function serializeAll(elements, {padding = 10} = {}) {\n  const fragment = location.href + \"#\";\n  let root;\n  if (elements.length === 1) {\n    root = elements[0].cloneNode(true); // optimize common case\n  } else {\n    const [ox, oy, dx, dy] = getBounds(elements);\n    root = document.createElementNS(svgns, \"svg\");\n    root.setAttribute(\"width\", dx + 2 * padding);\n    root.setAttribute(\"height\", dy + 2 * padding);\n    root.setAttribute(\"viewBox\", [-padding, -padding, dx + 2 * padding, dy + 2 * padding]);\n    for (const element of elements) {\n      const svg = root.appendChild(element.cloneNode(true));\n      const { x, y, width, height } = element.getBoundingClientRect();\n      svg.setAttribute(\"x\", x - ox);\n      svg.setAttribute(\"y\", y - oy);\n      svg.setAttribute(\"width\", width);\n      svg.setAttribute(\"height\", height);\n    }\n  }\n  const walker = document.createTreeWalker(root, NodeFilter.SHOW_ELEMENT);\n  while (walker.nextNode()) {\n    const node = walker.currentNode;\n    for (const attr of node.attributes) {\n      if (attr.value.includes(fragment)) {\n        attr.value = attr.value.replace(fragment, \"#\");\n      }\n    }\n  }\n  root.setAttributeNS(xmlns, \"xmlns\", svgns);\n  root.setAttributeNS(xmlns, \"xmlns:xlink\", xlinkns);\n  const serializer = new XMLSerializer();\n  const string = serializer.serializeToString(root);\n  return new Blob([string], { type: \"image/svg+xml\" });\n}\n\n\nfunction getBounds(elements) {\n  let x1 = Infinity;\n  let y1 = x1;\n  let x2 = -x1;\n  let y2 = x2;\n  for (const element of elements) {\n    const { x, y, width, height } = element.getBoundingClientRect();\n    if (x &lt; x1) x1 = x;\n    if (x + width &gt; x2) x2 = x + width;\n    if (y &lt; y1) y1 = y;\n    if (y + height &gt; y2) y2 = y + height;\n  }\n  return [x1, y1, x2 - x1, y2 - y1];\n}\n\n// based on https://observablehq.com/@gka/cheap-fit-text-to-circle\nfunction lines(text, targetWidth) {\n  const CHAR_W = {\n    \"a\":7,\"B\":8,\"C\":8,\"c\":6,\"D\":9,\"f\":4,\"G\":9,\"H\":9,\"I\":3,\"i\":3,\"J\":5,\"j\":3,\"K\":8,\"k\":6,\n    \"l\":3,\"M\":11,\"m\":11,\"N\":9,\"O\":9,\"P\":8,\"Q\":9,\"R\":8,\"r\":4,\"S\":8,\"s\":6,\"t\":4,\"U\":9,\"v\":6,\n    \"W\":11,\"w\":9,\"x\":6,\"y\":6,\"z\":5,\".\":2,\",\":2,\":\":2,\";\":2\n  };\n  function measureWidth(text) { return  d3.sum(text, char =&gt; CHAR_W[char] || CHAR_W[\"a\"]) * 0.8; };\n\n  const words = text.split(\" \");\n  let line;\n  let lineWidth0 = Infinity;\n  const lines = [];\n  for (let i = 0, n = words.length; i &lt; n; ++i) {\n    let lineText1 = (line ? line.text + \" \" : \"\") + words[i];\n    let lineWidth1 = measureWidth(lineText1);\n    if ((lineWidth0 + lineWidth1) / 2 &lt; targetWidth) {\n      line.width = lineWidth0 = lineWidth1;\n      line.text = lineText1;\n    } else {\n      lineWidth0 = measureWidth(words[i]);\n      line = {width: lineWidth0, text: words[i]};\n      lines.push(line);\n    }\n  }\n  return lines;\n}\n\nxmlns = \"http://www.w3.org/2000/xmlns/\"\n\nxlinkns = \"http://www.w3.org/1999/xlink\"\n\nsvgns = \"http://www.w3.org/2000/svg\"\nfunction Legend(color, {\n  title,\n  tickSize = 6,\n  width = 320, \n  height = 44 + tickSize,\n  marginTop = 18,\n  marginRight = 0,\n  marginBottom = 16 + tickSize,\n  marginLeft = 0,\n  ticks = width / 64,\n  tickFormat,\n  tickValues\n} = {}) {\n\n  function ramp(color, n = 256) {\n    const canvas = document.createElement(\"canvas\");\n    canvas.width = n;\n    canvas.height = 1;\n    const context = canvas.getContext(\"2d\");\n    for (let i = 0; i &lt; n; ++i) {\n      context.fillStyle = color(i / (n - 1));\n      context.fillRect(i, 0, 1, 1);\n    }\n    return canvas;\n  }\n\n  const svg = d3.create(\"svg\")\n      .attr(\"width\", width)\n      .attr(\"height\", height)\n      .attr(\"viewBox\", [0, 0, width, height])\n      .style(\"overflow\", \"visible\")\n      .style(\"display\", \"block\");\n\n  let tickAdjust = g =&gt; g.selectAll(\".tick line\").attr(\"y1\", marginTop + marginBottom - height);\n  let x;\n\n  // Continuous\n  if (color.interpolate) {\n    const n = Math.min(color.domain().length, color.range().length);\n\n    x = color.copy().rangeRound(d3.quantize(d3.interpolate(marginLeft, width - marginRight), n));\n\n    svg.append(\"image\")\n        .attr(\"x\", marginLeft)\n        .attr(\"y\", marginTop)\n        .attr(\"width\", width - marginLeft - marginRight)\n        .attr(\"height\", height - marginTop - marginBottom)\n        .attr(\"preserveAspectRatio\", \"none\")\n        .attr(\"xlink:href\", ramp(color.copy().domain(d3.quantize(d3.interpolate(0, 1), n))).toDataURL());\n  }\n\n  // Sequential\n  else if (color.interpolator) {\n    x = Object.assign(color.copy()\n        .interpolator(d3.interpolateRound(marginLeft, width - marginRight)),\n        {range() { return [marginLeft, width - marginRight]; }});\n\n    svg.append(\"image\")\n        .attr(\"x\", marginLeft)\n        .attr(\"y\", marginTop)\n        .attr(\"width\", width - marginLeft - marginRight)\n        .attr(\"height\", height - marginTop - marginBottom)\n        .attr(\"preserveAspectRatio\", \"none\")\n        .attr(\"xlink:href\", ramp(color.interpolator()).toDataURL());\n\n    // scaleSequentialQuantile doesn’t implement ticks or tickFormat.\n    if (!x.ticks) {\n      if (tickValues === undefined) {\n        const n = Math.round(ticks + 1);\n        tickValues = d3.range(n).map(i =&gt; d3.quantile(color.domain(), i / (n - 1)));\n      }\n      if (typeof tickFormat !== \"function\") {\n        tickFormat = d3.format(tickFormat === undefined ? \",f\" : tickFormat);\n      }\n    }\n  }\n\n  // Threshold\n  else if (color.invertExtent) {\n    const thresholds\n        = color.thresholds ? color.thresholds() // scaleQuantize\n        : color.quantiles ? color.quantiles() // scaleQuantile\n        : color.domain(); // scaleThreshold\n\n    const thresholdFormat\n        = tickFormat === undefined ? d =&gt; d\n        : typeof tickFormat === \"string\" ? d3.format(tickFormat)\n        : tickFormat;\n\n    x = d3.scaleLinear()\n        .domain([-1, color.range().length - 1])\n        .rangeRound([marginLeft, width - marginRight]);\n\n    svg.append(\"g\")\n      .selectAll(\"rect\")\n      .data(color.range())\n      .join(\"rect\")\n        .attr(\"x\", (d, i) =&gt; x(i - 1))\n        .attr(\"y\", marginTop)\n        .attr(\"width\", (d, i) =&gt; x(i) - x(i - 1))\n        .attr(\"height\", height - marginTop - marginBottom)\n        .attr(\"fill\", d =&gt; d);\n\n    tickValues = d3.range(thresholds.length);\n    tickFormat = i =&gt; thresholdFormat(thresholds[i], i);\n  }\n\n  // Ordinal\n  else {\n    x = d3.scaleBand()\n        .domain(color.domain())\n        .rangeRound([marginLeft, width - marginRight]);\n\n    svg.append(\"g\")\n      .selectAll(\"rect\")\n      .data(color.domain())\n      .join(\"rect\")\n        .attr(\"x\", x)\n        .attr(\"y\", marginTop)\n        .attr(\"width\", Math.max(0, x.bandwidth() - 1))\n        .attr(\"height\", height - marginTop - marginBottom)\n        .attr(\"fill\", color);\n\n    tickAdjust = () =&gt; {};\n  }\n\n  svg.append(\"g\")\n      .attr(\"transform\", `translate(0,${height - marginBottom})`)\n      .call(d3.axisBottom(x)\n        .ticks(ticks, typeof tickFormat === \"string\" ? tickFormat : undefined)\n        .tickFormat(typeof tickFormat === \"function\" ? tickFormat : undefined)\n        .tickSize(tickSize)\n        .tickValues(tickValues))\n      .call(tickAdjust)\n      .call(g =&gt; g.select(\".domain\").remove())\n      .call(g =&gt; g.append(\"text\")\n        .attr(\"x\", marginLeft)\n        .attr(\"y\", marginTop + marginBottom - height - 6)\n        .attr(\"fill\", \"currentColor\")\n        .attr(\"text-anchor\", \"start\")\n        .attr(\"font-weight\", \"bold\")\n        .style(\"font-size\", \"12px\")\n        .attr(\"class\", \"title\")\n        .text(title));\n\n  return svg.node();\n}\n\n\nfunction legend({color, ...options}) {\n  return Legend(color, options);\n}\n\n\n// Copyright 2021, Observable Inc.\n// Released under the ISC license.\n// https://observablehq.com/@d3/color-legend\nfunction Swatches(color, {\n  columns = null,\n  format,\n  unknown: formatUnknown,\n  swatchSize = 15,\n  swatchWidth = swatchSize,\n  swatchHeight = swatchSize,\n  marginLeft = 0\n} = {}) {\n  const id = `-swatches-${Math.random().toString(16).slice(2)}`;\n  const unknown = formatUnknown == null ? undefined : color.unknown();\n  const unknowns = unknown == null || unknown === d3.scaleImplicit ? [] : [unknown];\n  const domain = color.domain().concat(unknowns);\n  if (format === undefined) format = x =&gt; x === unknown ? formatUnknown : x;\n\n  function entity(character) {\n    return `&#${character.charCodeAt(0).toString()};`;\n  }\n\n  if (columns !== null) return htl.html`&lt;div style=\"display: flex; align-items: center; margin-left: ${+marginLeft}px; min-height: 33px; font: 12px sans-serif;\"&gt;\n  &lt;style&gt;\n\n.${id}-item {\n  break-inside: avoid;\n  display: flex;\n  align-items: center;\n  padding-bottom: 1px;\n}\n\n.${id}-label {\n  white-space: nowrap;\n  overflow: hidden;\n  text-overflow: ellipsis;\n  max-width: calc(100% - ${+swatchWidth}px - 0.5em);\n}\n\n.${id}-swatch {\n  width: ${+swatchWidth}px;\n  height: ${+swatchHeight}px;\n  margin: 0 0.5em 0 0;\n}\n\n  &lt;/style&gt;\n  &lt;div style=${{width: \"100%\", columns}}&gt;${domain.map(value =&gt; {\n    const label = `${format(value)}`;\n    return htl.html`&lt;div class=${id}-item&gt;\n      &lt;div class=${id}-swatch style=${{background: color(value)}}&gt;&lt;/div&gt;\n      &lt;div class=${id}-label title=${label}&gt;${label}&lt;/div&gt;\n    &lt;/div&gt;`;\n  })}\n  &lt;/div&gt;\n&lt;/div&gt;`;\n\n  return htl.html`&lt;div style=\"display: flex; align-items: center; min-height: 33px; margin-left: ${+marginLeft}px; font: 12px sans-serif;\"&gt;\n  &lt;style&gt;\n\n.${id} {\n  display: inline-flex;\n  align-items: center;\n  margin-right: 1em;\n}\n\n.${id}::before {\n  content: \"\";\n  width: ${+swatchWidth}px;\n  height: ${+swatchHeight}px;\n  margin-right: 0.5em;\n  background: var(--color);\n}\n\n  &lt;/style&gt;\n  &lt;div&gt;${domain.map(value =&gt; htl.html`&lt;span class=\"${id}\" style=\"--color: ${color(value)}\"&gt;${format(value)}&lt;/span&gt;`)}&lt;/div&gt;`;\n}\n\nfunction swatches({color, ...options}) {\n  return Swatches(color, options);\n}\nchart_map_d3 = function(data, mapTopoJSON, color, colorBorder, txtTitle, chart_width, chart_height) {\n\n  const projection = d3.geoMercator()\n  .scale(1200)\n  //.center([40, 67.5])\n  .center([40, 67.3])\n  .translate([400, 220])\n  const path = d3.geoPath().projection(projection);\n  const format = d =&gt; `${d}%`;\n  \n  //Määritellään tähän muuttujat CSV:stä!!!!!!\n  const valuemap = new Map(data.map(d =&gt; [d.id, d.muutos]));\n  \n  //Määritellään maakunnat\n  const maakuntamesh = topojson.mesh(maakunnat_2024_topo, maakunnat_2024_topo.objects.maakunnat_2024, (a, b) =&gt; a !== b);\n  \n  const zoom = d3.zoom()\n      .scaleExtent([1, 8])\n      .on(\"zoom\", zoomed);\n\n  const svg = d3.create(\"svg\")\n      .attr(\"width\", 900)\n      .attr(\"height\", 650)\n      .attr(\"viewBox\", [0, 0, 900, 650])\n      .on(\"click\", reset);\n      \n  const g = svg.append(\"g\")\n      .attr(\"transform\", \"translate(20,35)\")\n      .append(() =&gt; Legend(color, {title: txtTitle, width: 260}));\n\n  g.append(\"g\")\n    .selectAll(\"path\")\n    .data(mapTopoJSON)\n    .join(\"path\")\n      .attr(\"fill\", d =&gt; color(valuemap.get(d.properties.kunta))) \n      .attr(\"d\", path)\n    .append(\"title\")\n      .text(d =&gt; `${d.properties.name},\\n(${d.properties.nimi_2}),\\n${valuemap.get(d.properties.kunta)}`);\n      \n  g.append(\"path\")\n      .datum(maakuntamesh)\n      .attr(\"fill\", \"none\")\n      .attr(\"stroke\", colorBorder)\n      .attr(\"stroke-linejoin\", \"round\")\n      .attr(\"d\", path);\n      \n   svg.call(zoom);\n   \n\n  function reset() {\n    // states.transition().style(\"fill\", null);\n    svg.transition().duration(750).call(\n      zoom.transform,\n      d3.zoomIdentity,\n      d3.zoomTransform(svg.node()).invert([chart_width / 2, chart_height / 2])\n    );\n  }\n\n  function zoomed(event) {\n    const {transform} = event;\n    g.attr(\"transform\", transform);\n    g.attr(\"stroke-width\", 1 / transform.k);\n  }     \n      \n  return svg.node();\n}\nchart_chord_d3 = function(data, title_txt_chord, chart_width, chart_height) {\n\n  var sum_target;\n  var sum_source;\n  let vari;\n  var sum_yht;\n  \n  const margin = ({top: 20, right: 20, bottom: 0, left: 50});\n  const width = 300;\n  const height = width;\n  const innerRadius = Math.min(width, height) * .3 - 40;\n  const outerRadius = innerRadius + 15;\n  \n  \n  const chord = d3.chordDirected()\n    .padAngle(0.5 / innerRadius)\n    .sortSubgroups(d3.ascending)\n    .sortChords(d3.ascending);\n    \n  const ribbon = d3.ribbon()\n    .radius(innerRadius - 1)\n    .padAngle(0.5 / innerRadius);\n    \n  const rename = name =&gt; name.substring(name.indexOf(\".\") + 1, name.lastIndexOf(\".\"))\n  const names = Array.from(new Set(data.flatMap(d =&gt; [d.source, d.target]))).sort(d3.ascending);\n  \n  function matriisi(names) {\n    const index = new Map(names.map((name, i) =&gt; [name, i]));\n    const matrix = Array.from(index, () =&gt; new Array(names.length).fill(0));\n    for (const {source, target, value} of data) matrix[index.get(source)][index.get(target)] += value;\n    return matrix;\n  }\n\n const matrix = matriisi(names)\n  \n const arc = d3.arc()\n    .innerRadius(innerRadius)\n    .outerRadius(outerRadius)\n\n  //TÄSTÄ ALKAA PIIRROS\n  \n  const zoom = d3.zoom()\n      .scaleExtent([1, 8])\n      .on(\"zoom\", zoomed);\n  \n  const svg = d3.create(\"svg\")\n      .attr(\"viewBox\", [-width / 2, -height / 2.5, width, height]);\n\n  const chords = chord(matrix);\n  \n  const group = svg.append(\"g\")\n      .attr(\"font-size\", 3)\n      .attr(\"font-family\", \"Century Gothic\")\n    .selectAll(\"g\")\n    .data(chords.groups)\n    .join(\"g\");\n\n  group.append(\"path\")\n      .attr(\"fill\", d =&gt; {\n           sum_target = d3.sum(chords, c =&gt; (c.target.index === d.index) * c.target.value);\n           sum_source = d3.sum(chords, c =&gt; (c.source.index === d.index) * c.source.value);\n           sum_yht = sum_target-sum_source;\n            if (sum_yht &gt; 0) { \n              vari = \"#009651\"\n              return vari \n            }\n            else if (sum_yht == 0) { \n              vari = \"#28336C\"\n              return vari \n            }\n            else    { \n              vari = \"#DE232F\" \n              return vari \n            }\n        })\n      .attr(\"d\", arc);\n\n  group.append(\"text\")\n      .each(d =&gt; (d.angle = (d.startAngle + d.endAngle) / 2))\n      .attr(\"dy\", \"0.35em\")\n      .attr(\"transform\", d =&gt; `\n        rotate(${(d.angle * 180 / Math.PI - 90)})\n        translate(${outerRadius + 6})\n        ${d.angle &gt; Math.PI ? \"rotate(180)\" : \"\"}\n      `)\n      .attr(\"text-anchor\", d =&gt; d.angle &gt; Math.PI ? \"end\" : null)\n      //.text(d =&gt; names[d.index])\n      .text(d =&gt; (d.index &gt;= 3) ? names[d.index] : \"\")\n      .attr(\"fill\", d =&gt; {\n           sum_target = d3.sum(chords, c =&gt; (c.target.index === d.index) * c.target.value);\n           sum_source = d3.sum(chords, c =&gt; (c.source.index === d.index) * c.source.value);\n           sum_yht = sum_target-sum_source;\n            if (sum_yht &gt; 0) { \n              vari = \"#009651\"\n              return vari\n            }\n            else if (sum_yht == 0) { \n              vari = \"#28336C\"\n              return vari \n            }\n            else    { \n              vari = \"#DE232F\" \n              return vari \n            }\n        });\n\n  group.append(\"title\")\n      .text(d =&gt; `${names[d.index]} \n\n${d3.sum(chords, c =&gt; (c.source.index === d.index) * c.source.value)} lähtee →\n${d3.sum(chords, c =&gt; (c.target.index === d.index) * c.source.value)} tulee ←\n${d3.sum(chords, c =&gt; (c.target.index === d.index) * c.target.value)- d3.sum(chords, c =&gt; (c.source.index === d.index) * c.source.value)} netto =`);  \n\n  svg.append(\"g\")\n      .attr(\"fill-opacity\", 0.75)\n    .selectAll(\"path\")\n    .data(chords)\n    .join(\"path\")\n      .style(\"mix-blend-mode\", \"multiply\")\n          .attr(\"fill\", d =&gt; {\n           sum_target = d3.sum(chords, c =&gt; (c.target.index === d.index) * c.target.value);\n           sum_source = d3.sum(chords, c =&gt; (c.source.index === d.index) * c.source.value);\n           sum_yht = sum_target-sum_source;\n            if (sum_yht &gt; 0) { \n              vari = \"#009651\"\n              return vari \n            }\n            else if (sum_yht == 0) { \n              vari = \"#28336C\"\n              return vari \n            }\n            else    { \n              vari = \"#DE232F\" \n              return vari \n            }\n        })\n      .attr(\"d\", ribbon)\n    .append(\"title\")\n      .text(d =&gt; `${names[d.source.index]} --&gt; ${names[d.target.index]} ${d.source.value}`);\n      \n      \n  svg.call(zoom);\n   \n\n  function reset() {\n    // states.transition().style(\"fill\", null);\n    svg.transition().duration(750).call(\n      zoom.transform,\n      d3.zoomIdentity,\n      d3.zoomTransform(svg.node()).invert([chart_width / 2, chart_height / 2])\n    );\n  }\n\n  function zoomed(event) {\n    const {transform} = event;\n    svg.attr(\"transform\", transform);\n    svg.attr(\"stroke-width\", 1 / transform.k);\n  }    \n\n  return svg.node();\n\n\n}"
  },
  {
    "objectID": "asuminen.html#asuminen---asuntokunnat-talotyypeittäin",
    "href": "asuminen.html#asuminen---asuntokunnat-talotyypeittäin",
    "title": "Asuminen",
    "section": "Asuminen - Asuntokunnat talotyypeittäin",
    "text": "Asuminen - Asuntokunnat talotyypeittäin\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nVuosineljännes\nYhteensä\nOmakoti- ja paritalot\nRivitalot\nKerrostalot\nMuut rakennukset\n\n\n\n\n2023Q4\n1988\n1600\n191\n165\n32\n\n\n2024Q1*\n1976\n1591\n187\n166\n32\n\n\n2024Q2*\n1971\n1588\n191\n161\n31\n\n\n\n\n\n\n\n\nTalotyyppien %-osuudet asuntokunnissa\nAsuntokunnista 2024Q2* omakoti- ja paritaloissa asui 80.6 % (edell. 80.5). Rivitaloissa asuvien osuus oli 9.7% (edell. 9.5) ja kerrostaloissa 8.2% (edell. 8.4)."
  },
  {
    "objectID": "asuminen.html#asuminen---asuntokunnat-talotyypin-ja-koon-mukaan",
    "href": "asuminen.html#asuminen---asuntokunnat-talotyypin-ja-koon-mukaan",
    "title": "Asuminen",
    "section": "Asuminen - Asuntokunnat talotyypin ja koon mukaan",
    "text": "Asuminen - Asuntokunnat talotyypin ja koon mukaan\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nVuosineljännes\nAsuntokunnan koko\nYhteensä\nOmakoti- ja paritalot\nRivitalot\nKerrostalot\nMuut rakennukset\n\n\n\n\n2023Q4\n1 henkilö\n571\n349\n107\n99\n16\n\n\n2023Q4\n2 henkilöä\n779\n677\n54\n38\n10\n\n\n2023Q4\n3 henkilöä\n263\n222\n19\n21\n1\n\n\n2023Q4\n4 henkilöä tai enemmän\n375\n352\n11\n7\n5\n\n\n2024Q1*\n1 henkilö\n570\n351\n104\n99\n16\n\n\n2024Q1*\n2 henkilöä\n777\n675\n54\n38\n10\n\n\n2024Q1*\n3 henkilöä\n265\n223\n18\n23\n1\n\n\n2024Q1*\n4 henkilöä tai enemmän\n364\n342\n11\n6\n5\n\n\n2024Q2*\n1 henkilö\n566\n347\n105\n98\n16\n\n\n2024Q2*\n2 henkilöä\n781\n678\n55\n38\n10\n\n\n2024Q2*\n3 henkilöä\n256\n218\n19\n19\n0\n\n\n2024Q2*\n4 henkilöä tai enemmän\n368\n345\n12\n6\n5"
  },
  {
    "objectID": "aluetalous.html",
    "href": "aluetalous.html",
    "title": "Aluetalous ja yritystoiminta",
    "section": "",
    "text": "d3 = require(\"d3@7\")\n//import {Legend} from \"@d3/color-legend\"\n\nfolderKunnat24TopoJSON = \"./maps/Kunnat2024Topo.json\"\nkunnat2024topo = FileAttachmentDynamic(folderKunnat24TopoJSON).json()\nmapTopoJSON = topojson.feature(kunnat2024topo, kunnat2024topo.objects.Kunnat2024_geo).features\n\n\nfolderMaakunnat24TopoJSON = \"./maps/Maakunnat2024Topo.json\"\nmaakunnat_2024_topo =  FileAttachmentDynamic(folderMaakunnat24TopoJSON).json()\nFileAttachmentDynamic = function(filename) {\n  return new Function(\"FileAttachment\", `return FileAttachment(\"${filename}\")`)(FileAttachment)\n}\n\n// Vaihdetaan tekstin väri\ncolor = function(vari) {\n  if(vari &gt; 0){\n      return \"green\"\n    }else{\n      return \"red\"\n    }\n}\n// Pyöristys\npyoristys = function(n, places) {\n  if (!places) return Math.round(n);\n  const d = 10 ** places;\n  return Math.round(n * d) / d;\n}\n//Euromerkintä\neurot = function(number) {\n  return number.toLocaleString('fi-FI', { style: 'currency', currency: 'EUR',minimumFractionDigits: 0 });\n}\n// Euromuutoksen laskeminen kertoimella\nmuutoskerroin = function(x, y) {\n  return (1+x/100)*y;\n}\n// Muutosprosentti\nmuutosprosentti = function(x, y) {\n  return pyoristys(((x-y)/y)*100,1);\n}\n// Tuhatjakaja\ntuhatjakaja = function(x) {\n  return x/1000;\n}\n// Euromuutoksen laskeminen kertoimella\npalkkakerroin = function(x, y) {\n  return 100*((1+x/100)*(1+y/100)-1);\n}\n// Jako-osuuden asukaskerroin\nasukaskerroin = function(x, y) {\n  return (x/y);\n}\n// Jako-osuuden veroprosenttikerroin miinus1/miinus3 vuotta miinus 1 vuoden kerroin\nveroprosenttikerroin = function(x, y) {\n  return (x/y);\n}\n// Kunnan muok. kunnallisvero, alkuvuosi ja loppuvuosi \nkunnallisvero_muokkaus = function(kunnallisvero,asukaskerroin,veroprosentti) {\n  return kunnallisvero*asukaskerroin*veroprosentti;\n}\n\n//Tekstimuutokset\nfn_nousu_lasku_txt = function(arvo){\n  if(arvo &gt; 0) {\n  return \"kasvanut\" \n  }\n  else { \n  return \"laskenut\";\n  }\n}\n\n//TARVITAAN KARTOISSA\nserialize = {\n  const xmlns = \"http://www.w3.org/2000/xmlns/\";\n  const xlinkns = \"http://www.w3.org/1999/xlink\";\n  const svgns = \"http://www.w3.org/2000/svg\";\n  return function serialize(svg) {\n    svg = svg.cloneNode(true);\n    const fragment = window.location.href + \"#\";\n    const walker = document.createTreeWalker(svg, NodeFilter.SHOW_ELEMENT);\n    while (walker.nextNode()) {\n      for (const attr of walker.currentNode.attributes) {\n        if (attr.value.includes(fragment)) {\n          attr.value = attr.value.replace(fragment, \"#\");\n        }\n      }\n    }\n    svg.setAttributeNS(xmlns, \"xmlns\", svgns);\n    svg.setAttributeNS(xmlns, \"xmlns:xlink\", xlinkns);\n    const serializer = new window.XMLSerializer;\n    const string = serializer.serializeToString(svg);\n    return new Blob([string], {type: \"image/svg+xml\"});\n  };\n}\n\n\nfunction toSVG(chart) {\n  if (chart.nodeName !== \"FIGURE\") {\n    return chart;\n  }\n\n  // the chart needs to be in the body if we want to read values, positions, sizes…\n  document.body.appendChild(chart);\n  const [x0, y0, width, height] = getBounds([chart]);\n\n  const nodes = [];\n\n  for (const node of d3\n    .select(chart)\n    .selectChildren(\"h1,h2,h3,div,figcaption,svg\")) {\n    switch (node.nodeName.toLowerCase()) {\n      case \"div\":\n        {\n          const children = d3.select(node).selectChildren(\"div,span\");\n          const height = getBounds([node, ...children])[3] + 2;\n          const svg = d3\n            .select(chart)\n            .append(\"svg\")\n            .attr(\"width\", width)\n            .attr(\"height\", height);\n          nodes.push(svg.node());\n\n          const swatches = svg\n            .selectAll()\n            .data(\n              Array.from(children, (d) =&gt; {\n                const svg = d3.select(d).select(\"svg\").node();\n                const bbox = svg.getBBox();\n                return {\n                  style: window.getComputedStyle(d),\n                  svg,\n                  width: bbox.width,\n                  height: bbox.height,\n                  text: d.textContent,\n                  bounds: getBounds([d])\n                };\n              })\n            )\n            .join(\"g\")\n            .attr(\n              \"transform\",\n              (d) =&gt; `translate(${d.bounds[0] - x0},${10 + d.bounds[1] - y0})`\n            );\n\n          swatches\n            .append((d) =&gt; d.svg) // \"rect\")\n            .attr(\"width\", (d) =&gt; d.width)\n            .attr(\"height\", (d) =&gt; d.height)\n            .attr(\"y\", (d) =&gt; `${-parseFloat(d.height) / 2}px`);\n          swatches\n            .append(\"text\")\n            .text((d) =&gt; d.text)\n            .attr(\"x\", (d) =&gt; d.width)\n            .attr(\"dx\", 5)\n            .attr(\"dy\", \"0.38em\")\n            .attr(\"font-family\", (d) =&gt; d.style.fontFamily)\n            .attr(\"font-size\", (d) =&gt; d.style.fontSize)\n            .attr(\"fill\", (d) =&gt; d.style.color);\n        }\n        break;\n      case \"figcaption\":\n      case \"h1\":\n      case \"h2\":\n      case \"h3\":\n        {\n          const svg = d3\n            .select(chart)\n            .append(\"svg\")\n            .attr(\"width\", width)\n            .attr(\"overflow\", \"visible\");\n          nodes.push(svg.node());\n\n          const children = d3.select(node).selectChildren();\n\n          let h = 0;\n          for (const d of children.size() &gt; 0\n            ? children.selectChildren()\n            : [node]) {\n            const style = window.getComputedStyle(d);\n            const t = svg\n              .append(\"g\")\n              .attr(\"transform\", `translate(0,${h})`)\n              .append(() =&gt;\n                d3\n                  .select(\n                    Plot.text([d.textContent], {\n                      text: (d) =&gt; d,\n                      lineWidth:\n                        (1.06 * parseFloat(style.width)) /\n                        parseFloat(style.fontSize),\n                      lineHeight: 1.2,\n                      frameAnchor: \"top-left\"\n                    }).plot()\n                  )\n                  .select(\"text\")\n                  .attr(\"font-family\", style.fontFamily)\n                  .attr(\"font-size\", 1.08 * parseFloat(style.fontSize))\n                  .attr(\"font-weight\", style.fontWeight)\n                  .attr(\"fill\", style.color)\n                  .node()\n              );\n            h += getBounds([t.node()])[3] + 4;\n          }\n          svg.attr(\"height\", h);\n        }\n        break;\n      case \"svg\":\n        d3.select(chart).append(() =&gt; node);\n        nodes.push(node);\n        break;\n    }\n  }\n\n  return serializeAll(nodes)\n    .then((blob) =&gt; blob.text())\n    .then((c) =&gt; {\n      document.body.removeChild(chart);\n      return Object.assign(svg`${c}`, chart);\n    });\n}\n\n\n// Given an array of SVG elements, composites them into a single SVG element,\n// and then serializes the result to a blob.\nasync function serializeAll(elements, {padding = 10} = {}) {\n  const fragment = location.href + \"#\";\n  let root;\n  if (elements.length === 1) {\n    root = elements[0].cloneNode(true); // optimize common case\n  } else {\n    const [ox, oy, dx, dy] = getBounds(elements);\n    root = document.createElementNS(svgns, \"svg\");\n    root.setAttribute(\"width\", dx + 2 * padding);\n    root.setAttribute(\"height\", dy + 2 * padding);\n    root.setAttribute(\"viewBox\", [-padding, -padding, dx + 2 * padding, dy + 2 * padding]);\n    for (const element of elements) {\n      const svg = root.appendChild(element.cloneNode(true));\n      const { x, y, width, height } = element.getBoundingClientRect();\n      svg.setAttribute(\"x\", x - ox);\n      svg.setAttribute(\"y\", y - oy);\n      svg.setAttribute(\"width\", width);\n      svg.setAttribute(\"height\", height);\n    }\n  }\n  const walker = document.createTreeWalker(root, NodeFilter.SHOW_ELEMENT);\n  while (walker.nextNode()) {\n    const node = walker.currentNode;\n    for (const attr of node.attributes) {\n      if (attr.value.includes(fragment)) {\n        attr.value = attr.value.replace(fragment, \"#\");\n      }\n    }\n  }\n  root.setAttributeNS(xmlns, \"xmlns\", svgns);\n  root.setAttributeNS(xmlns, \"xmlns:xlink\", xlinkns);\n  const serializer = new XMLSerializer();\n  const string = serializer.serializeToString(root);\n  return new Blob([string], { type: \"image/svg+xml\" });\n}\n\n\nfunction getBounds(elements) {\n  let x1 = Infinity;\n  let y1 = x1;\n  let x2 = -x1;\n  let y2 = x2;\n  for (const element of elements) {\n    const { x, y, width, height } = element.getBoundingClientRect();\n    if (x &lt; x1) x1 = x;\n    if (x + width &gt; x2) x2 = x + width;\n    if (y &lt; y1) y1 = y;\n    if (y + height &gt; y2) y2 = y + height;\n  }\n  return [x1, y1, x2 - x1, y2 - y1];\n}\n\n// based on https://observablehq.com/@gka/cheap-fit-text-to-circle\nfunction lines(text, targetWidth) {\n  const CHAR_W = {\n    \"a\":7,\"B\":8,\"C\":8,\"c\":6,\"D\":9,\"f\":4,\"G\":9,\"H\":9,\"I\":3,\"i\":3,\"J\":5,\"j\":3,\"K\":8,\"k\":6,\n    \"l\":3,\"M\":11,\"m\":11,\"N\":9,\"O\":9,\"P\":8,\"Q\":9,\"R\":8,\"r\":4,\"S\":8,\"s\":6,\"t\":4,\"U\":9,\"v\":6,\n    \"W\":11,\"w\":9,\"x\":6,\"y\":6,\"z\":5,\".\":2,\",\":2,\":\":2,\";\":2\n  };\n  function measureWidth(text) { return  d3.sum(text, char =&gt; CHAR_W[char] || CHAR_W[\"a\"]) * 0.8; };\n\n  const words = text.split(\" \");\n  let line;\n  let lineWidth0 = Infinity;\n  const lines = [];\n  for (let i = 0, n = words.length; i &lt; n; ++i) {\n    let lineText1 = (line ? line.text + \" \" : \"\") + words[i];\n    let lineWidth1 = measureWidth(lineText1);\n    if ((lineWidth0 + lineWidth1) / 2 &lt; targetWidth) {\n      line.width = lineWidth0 = lineWidth1;\n      line.text = lineText1;\n    } else {\n      lineWidth0 = measureWidth(words[i]);\n      line = {width: lineWidth0, text: words[i]};\n      lines.push(line);\n    }\n  }\n  return lines;\n}\n\nxmlns = \"http://www.w3.org/2000/xmlns/\"\n\nxlinkns = \"http://www.w3.org/1999/xlink\"\n\nsvgns = \"http://www.w3.org/2000/svg\"\nfunction Legend(color, {\n  title,\n  tickSize = 6,\n  width = 320, \n  height = 44 + tickSize,\n  marginTop = 18,\n  marginRight = 0,\n  marginBottom = 16 + tickSize,\n  marginLeft = 0,\n  ticks = width / 64,\n  tickFormat,\n  tickValues\n} = {}) {\n\n  function ramp(color, n = 256) {\n    const canvas = document.createElement(\"canvas\");\n    canvas.width = n;\n    canvas.height = 1;\n    const context = canvas.getContext(\"2d\");\n    for (let i = 0; i &lt; n; ++i) {\n      context.fillStyle = color(i / (n - 1));\n      context.fillRect(i, 0, 1, 1);\n    }\n    return canvas;\n  }\n\n  const svg = d3.create(\"svg\")\n      .attr(\"width\", width)\n      .attr(\"height\", height)\n      .attr(\"viewBox\", [0, 0, width, height])\n      .style(\"overflow\", \"visible\")\n      .style(\"display\", \"block\");\n\n  let tickAdjust = g =&gt; g.selectAll(\".tick line\").attr(\"y1\", marginTop + marginBottom - height);\n  let x;\n\n  // Continuous\n  if (color.interpolate) {\n    const n = Math.min(color.domain().length, color.range().length);\n\n    x = color.copy().rangeRound(d3.quantize(d3.interpolate(marginLeft, width - marginRight), n));\n\n    svg.append(\"image\")\n        .attr(\"x\", marginLeft)\n        .attr(\"y\", marginTop)\n        .attr(\"width\", width - marginLeft - marginRight)\n        .attr(\"height\", height - marginTop - marginBottom)\n        .attr(\"preserveAspectRatio\", \"none\")\n        .attr(\"xlink:href\", ramp(color.copy().domain(d3.quantize(d3.interpolate(0, 1), n))).toDataURL());\n  }\n\n  // Sequential\n  else if (color.interpolator) {\n    x = Object.assign(color.copy()\n        .interpolator(d3.interpolateRound(marginLeft, width - marginRight)),\n        {range() { return [marginLeft, width - marginRight]; }});\n\n    svg.append(\"image\")\n        .attr(\"x\", marginLeft)\n        .attr(\"y\", marginTop)\n        .attr(\"width\", width - marginLeft - marginRight)\n        .attr(\"height\", height - marginTop - marginBottom)\n        .attr(\"preserveAspectRatio\", \"none\")\n        .attr(\"xlink:href\", ramp(color.interpolator()).toDataURL());\n\n    // scaleSequentialQuantile doesn’t implement ticks or tickFormat.\n    if (!x.ticks) {\n      if (tickValues === undefined) {\n        const n = Math.round(ticks + 1);\n        tickValues = d3.range(n).map(i =&gt; d3.quantile(color.domain(), i / (n - 1)));\n      }\n      if (typeof tickFormat !== \"function\") {\n        tickFormat = d3.format(tickFormat === undefined ? \",f\" : tickFormat);\n      }\n    }\n  }\n\n  // Threshold\n  else if (color.invertExtent) {\n    const thresholds\n        = color.thresholds ? color.thresholds() // scaleQuantize\n        : color.quantiles ? color.quantiles() // scaleQuantile\n        : color.domain(); // scaleThreshold\n\n    const thresholdFormat\n        = tickFormat === undefined ? d =&gt; d\n        : typeof tickFormat === \"string\" ? d3.format(tickFormat)\n        : tickFormat;\n\n    x = d3.scaleLinear()\n        .domain([-1, color.range().length - 1])\n        .rangeRound([marginLeft, width - marginRight]);\n\n    svg.append(\"g\")\n      .selectAll(\"rect\")\n      .data(color.range())\n      .join(\"rect\")\n        .attr(\"x\", (d, i) =&gt; x(i - 1))\n        .attr(\"y\", marginTop)\n        .attr(\"width\", (d, i) =&gt; x(i) - x(i - 1))\n        .attr(\"height\", height - marginTop - marginBottom)\n        .attr(\"fill\", d =&gt; d);\n\n    tickValues = d3.range(thresholds.length);\n    tickFormat = i =&gt; thresholdFormat(thresholds[i], i);\n  }\n\n  // Ordinal\n  else {\n    x = d3.scaleBand()\n        .domain(color.domain())\n        .rangeRound([marginLeft, width - marginRight]);\n\n    svg.append(\"g\")\n      .selectAll(\"rect\")\n      .data(color.domain())\n      .join(\"rect\")\n        .attr(\"x\", x)\n        .attr(\"y\", marginTop)\n        .attr(\"width\", Math.max(0, x.bandwidth() - 1))\n        .attr(\"height\", height - marginTop - marginBottom)\n        .attr(\"fill\", color);\n\n    tickAdjust = () =&gt; {};\n  }\n\n  svg.append(\"g\")\n      .attr(\"transform\", `translate(0,${height - marginBottom})`)\n      .call(d3.axisBottom(x)\n        .ticks(ticks, typeof tickFormat === \"string\" ? tickFormat : undefined)\n        .tickFormat(typeof tickFormat === \"function\" ? tickFormat : undefined)\n        .tickSize(tickSize)\n        .tickValues(tickValues))\n      .call(tickAdjust)\n      .call(g =&gt; g.select(\".domain\").remove())\n      .call(g =&gt; g.append(\"text\")\n        .attr(\"x\", marginLeft)\n        .attr(\"y\", marginTop + marginBottom - height - 6)\n        .attr(\"fill\", \"currentColor\")\n        .attr(\"text-anchor\", \"start\")\n        .attr(\"font-weight\", \"bold\")\n        .style(\"font-size\", \"12px\")\n        .attr(\"class\", \"title\")\n        .text(title));\n\n  return svg.node();\n}\n\n\nfunction legend({color, ...options}) {\n  return Legend(color, options);\n}\n\n\n// Copyright 2021, Observable Inc.\n// Released under the ISC license.\n// https://observablehq.com/@d3/color-legend\nfunction Swatches(color, {\n  columns = null,\n  format,\n  unknown: formatUnknown,\n  swatchSize = 15,\n  swatchWidth = swatchSize,\n  swatchHeight = swatchSize,\n  marginLeft = 0\n} = {}) {\n  const id = `-swatches-${Math.random().toString(16).slice(2)}`;\n  const unknown = formatUnknown == null ? undefined : color.unknown();\n  const unknowns = unknown == null || unknown === d3.scaleImplicit ? [] : [unknown];\n  const domain = color.domain().concat(unknowns);\n  if (format === undefined) format = x =&gt; x === unknown ? formatUnknown : x;\n\n  function entity(character) {\n    return `&#${character.charCodeAt(0).toString()};`;\n  }\n\n  if (columns !== null) return htl.html`&lt;div style=\"display: flex; align-items: center; margin-left: ${+marginLeft}px; min-height: 33px; font: 12px sans-serif;\"&gt;\n  &lt;style&gt;\n\n.${id}-item {\n  break-inside: avoid;\n  display: flex;\n  align-items: center;\n  padding-bottom: 1px;\n}\n\n.${id}-label {\n  white-space: nowrap;\n  overflow: hidden;\n  text-overflow: ellipsis;\n  max-width: calc(100% - ${+swatchWidth}px - 0.5em);\n}\n\n.${id}-swatch {\n  width: ${+swatchWidth}px;\n  height: ${+swatchHeight}px;\n  margin: 0 0.5em 0 0;\n}\n\n  &lt;/style&gt;\n  &lt;div style=${{width: \"100%\", columns}}&gt;${domain.map(value =&gt; {\n    const label = `${format(value)}`;\n    return htl.html`&lt;div class=${id}-item&gt;\n      &lt;div class=${id}-swatch style=${{background: color(value)}}&gt;&lt;/div&gt;\n      &lt;div class=${id}-label title=${label}&gt;${label}&lt;/div&gt;\n    &lt;/div&gt;`;\n  })}\n  &lt;/div&gt;\n&lt;/div&gt;`;\n\n  return htl.html`&lt;div style=\"display: flex; align-items: center; min-height: 33px; margin-left: ${+marginLeft}px; font: 12px sans-serif;\"&gt;\n  &lt;style&gt;\n\n.${id} {\n  display: inline-flex;\n  align-items: center;\n  margin-right: 1em;\n}\n\n.${id}::before {\n  content: \"\";\n  width: ${+swatchWidth}px;\n  height: ${+swatchHeight}px;\n  margin-right: 0.5em;\n  background: var(--color);\n}\n\n  &lt;/style&gt;\n  &lt;div&gt;${domain.map(value =&gt; htl.html`&lt;span class=\"${id}\" style=\"--color: ${color(value)}\"&gt;${format(value)}&lt;/span&gt;`)}&lt;/div&gt;`;\n}\n\nfunction swatches({color, ...options}) {\n  return Swatches(color, options);\n}\nchart_map_d3 = function(data, mapTopoJSON, color, colorBorder, txtTitle, chart_width, chart_height) {\n\n  const projection = d3.geoMercator()\n  .scale(1200)\n  //.center([40, 67.5])\n  .center([40, 67.3])\n  .translate([400, 220])\n  const path = d3.geoPath().projection(projection);\n  const format = d =&gt; `${d}%`;\n  \n  //Määritellään tähän muuttujat CSV:stä!!!!!!\n  const valuemap = new Map(data.map(d =&gt; [d.id, d.muutos]));\n  \n  //Määritellään maakunnat\n  const maakuntamesh = topojson.mesh(maakunnat_2024_topo, maakunnat_2024_topo.objects.maakunnat_2024, (a, b) =&gt; a !== b);\n  \n  const zoom = d3.zoom()\n      .scaleExtent([1, 8])\n      .on(\"zoom\", zoomed);\n\n  const svg = d3.create(\"svg\")\n      .attr(\"width\", 900)\n      .attr(\"height\", 650)\n      .attr(\"viewBox\", [0, 0, 900, 650])\n      .on(\"click\", reset);\n      \n  const g = svg.append(\"g\")\n      .attr(\"transform\", \"translate(20,35)\")\n      .append(() =&gt; Legend(color, {title: txtTitle, width: 260}));\n\n  g.append(\"g\")\n    .selectAll(\"path\")\n    .data(mapTopoJSON)\n    .join(\"path\")\n      .attr(\"fill\", d =&gt; color(valuemap.get(d.properties.kunta))) \n      .attr(\"d\", path)\n    .append(\"title\")\n      .text(d =&gt; `${d.properties.name},\\n(${d.properties.nimi_2}),\\n${valuemap.get(d.properties.kunta)}`);\n      \n  g.append(\"path\")\n      .datum(maakuntamesh)\n      .attr(\"fill\", \"none\")\n      .attr(\"stroke\", colorBorder)\n      .attr(\"stroke-linejoin\", \"round\")\n      .attr(\"d\", path);\n      \n   svg.call(zoom);\n   \n\n  function reset() {\n    // states.transition().style(\"fill\", null);\n    svg.transition().duration(750).call(\n      zoom.transform,\n      d3.zoomIdentity,\n      d3.zoomTransform(svg.node()).invert([chart_width / 2, chart_height / 2])\n    );\n  }\n\n  function zoomed(event) {\n    const {transform} = event;\n    g.attr(\"transform\", transform);\n    g.attr(\"stroke-width\", 1 / transform.k);\n  }     \n      \n  return svg.node();\n}\nchart_chord_d3 = function(data, title_txt_chord, chart_width, chart_height) {\n\n  var sum_target;\n  var sum_source;\n  let vari;\n  var sum_yht;\n  \n  const margin = ({top: 20, right: 20, bottom: 0, left: 50});\n  const width = 300;\n  const height = width;\n  const innerRadius = Math.min(width, height) * .3 - 40;\n  const outerRadius = innerRadius + 15;\n  \n  \n  const chord = d3.chordDirected()\n    .padAngle(0.5 / innerRadius)\n    .sortSubgroups(d3.ascending)\n    .sortChords(d3.ascending);\n    \n  const ribbon = d3.ribbon()\n    .radius(innerRadius - 1)\n    .padAngle(0.5 / innerRadius);\n    \n  const rename = name =&gt; name.substring(name.indexOf(\".\") + 1, name.lastIndexOf(\".\"))\n  const names = Array.from(new Set(data.flatMap(d =&gt; [d.source, d.target]))).sort(d3.ascending);\n  \n  function matriisi(names) {\n    const index = new Map(names.map((name, i) =&gt; [name, i]));\n    const matrix = Array.from(index, () =&gt; new Array(names.length).fill(0));\n    for (const {source, target, value} of data) matrix[index.get(source)][index.get(target)] += value;\n    return matrix;\n  }\n\n const matrix = matriisi(names)\n  \n const arc = d3.arc()\n    .innerRadius(innerRadius)\n    .outerRadius(outerRadius)\n\n  //TÄSTÄ ALKAA PIIRROS\n  \n  const zoom = d3.zoom()\n      .scaleExtent([1, 8])\n      .on(\"zoom\", zoomed);\n  \n  const svg = d3.create(\"svg\")\n      .attr(\"viewBox\", [-width / 2, -height / 2.5, width, height]);\n\n  const chords = chord(matrix);\n  \n  const group = svg.append(\"g\")\n      .attr(\"font-size\", 3)\n      .attr(\"font-family\", \"Century Gothic\")\n    .selectAll(\"g\")\n    .data(chords.groups)\n    .join(\"g\");\n\n  group.append(\"path\")\n      .attr(\"fill\", d =&gt; {\n           sum_target = d3.sum(chords, c =&gt; (c.target.index === d.index) * c.target.value);\n           sum_source = d3.sum(chords, c =&gt; (c.source.index === d.index) * c.source.value);\n           sum_yht = sum_target-sum_source;\n            if (sum_yht &gt; 0) { \n              vari = \"#009651\"\n              return vari \n            }\n            else if (sum_yht == 0) { \n              vari = \"#28336C\"\n              return vari \n            }\n            else    { \n              vari = \"#DE232F\" \n              return vari \n            }\n        })\n      .attr(\"d\", arc);\n\n  group.append(\"text\")\n      .each(d =&gt; (d.angle = (d.startAngle + d.endAngle) / 2))\n      .attr(\"dy\", \"0.35em\")\n      .attr(\"transform\", d =&gt; `\n        rotate(${(d.angle * 180 / Math.PI - 90)})\n        translate(${outerRadius + 6})\n        ${d.angle &gt; Math.PI ? \"rotate(180)\" : \"\"}\n      `)\n      .attr(\"text-anchor\", d =&gt; d.angle &gt; Math.PI ? \"end\" : null)\n      //.text(d =&gt; names[d.index])\n      .text(d =&gt; (d.index &gt;= 3) ? names[d.index] : \"\")\n      .attr(\"fill\", d =&gt; {\n           sum_target = d3.sum(chords, c =&gt; (c.target.index === d.index) * c.target.value);\n           sum_source = d3.sum(chords, c =&gt; (c.source.index === d.index) * c.source.value);\n           sum_yht = sum_target-sum_source;\n            if (sum_yht &gt; 0) { \n              vari = \"#009651\"\n              return vari\n            }\n            else if (sum_yht == 0) { \n              vari = \"#28336C\"\n              return vari \n            }\n            else    { \n              vari = \"#DE232F\" \n              return vari \n            }\n        });\n\n  group.append(\"title\")\n      .text(d =&gt; `${names[d.index]} \n\n${d3.sum(chords, c =&gt; (c.source.index === d.index) * c.source.value)} lähtee →\n${d3.sum(chords, c =&gt; (c.target.index === d.index) * c.source.value)} tulee ←\n${d3.sum(chords, c =&gt; (c.target.index === d.index) * c.target.value)- d3.sum(chords, c =&gt; (c.source.index === d.index) * c.source.value)} netto =`);  \n\n  svg.append(\"g\")\n      .attr(\"fill-opacity\", 0.75)\n    .selectAll(\"path\")\n    .data(chords)\n    .join(\"path\")\n      .style(\"mix-blend-mode\", \"multiply\")\n          .attr(\"fill\", d =&gt; {\n           sum_target = d3.sum(chords, c =&gt; (c.target.index === d.index) * c.target.value);\n           sum_source = d3.sum(chords, c =&gt; (c.source.index === d.index) * c.source.value);\n           sum_yht = sum_target-sum_source;\n            if (sum_yht &gt; 0) { \n              vari = \"#009651\"\n              return vari \n            }\n            else if (sum_yht == 0) { \n              vari = \"#28336C\"\n              return vari \n            }\n            else    { \n              vari = \"#DE232F\" \n              return vari \n            }\n        })\n      .attr(\"d\", ribbon)\n    .append(\"title\")\n      .text(d =&gt; `${names[d.source.index]} --&gt; ${names[d.target.index]} ${d.source.value}`);\n      \n      \n  svg.call(zoom);\n   \n\n  function reset() {\n    // states.transition().style(\"fill\", null);\n    svg.transition().duration(750).call(\n      zoom.transform,\n      d3.zoomIdentity,\n      d3.zoomTransform(svg.node()).invert([chart_width / 2, chart_height / 2])\n    );\n  }\n\n  function zoomed(event) {\n    const {transform} = event;\n    svg.attr(\"transform\", transform);\n    svg.attr(\"stroke-width\", 1 / transform.k);\n  }    \n\n  return svg.node();\n\n\n}"
  },
  {
    "objectID": "aluetalous.html#aloittaneet-ja-lopettaneet-yritykset",
    "href": "aluetalous.html#aloittaneet-ja-lopettaneet-yritykset",
    "title": "Aluetalous ja yritystoiminta",
    "section": "Aloittaneet ja lopettaneet yritykset",
    "text": "Aloittaneet ja lopettaneet yritykset\n\n\n\n\n\n\n\nAloittaneet ja lopettaneet yritykset\nAloittaneita yrityksiä ajanjaksolla 2024Q1 oli yhteensä 7 (lukema 2023Q4: 9). . Lopettaneiden yritysten määrä oli samalla ajanjaksolla yhteensä 9 (lukema 2023Q4: 4)..\n\n\n\n\n\n\n\n\nVuosineljännes\nAloittaneet yritykset (lkm)\nLopettaneet yritykset (lkm)\n\n\n\n\n2018Q2\n9\n5\n\n\n2018Q3\n7\n3\n\n\n2018Q4\n9\n6\n\n\n2019Q1\n10\n1\n\n\n2019Q2\n9\n3\n\n\n2019Q3\n5\n2\n\n\n2019Q4\n7\n7\n\n\n2020Q1\n7\n7\n\n\n2020Q2\n7\n2\n\n\n2020Q3\n4\n4\n\n\n2020Q4\n7\n8\n\n\n2021Q1\n11\n11\n\n\n2021Q2\n6\n4\n\n\n2021Q3\n7\n6\n\n\n2021Q4\n4\n4\n\n\n2022Q1\n7\n4\n\n\n2022Q2\n4\n3\n\n\n2022Q3\n5\n3\n\n\n2022Q4\n8\n3\n\n\n2023Q1\n8\n5\n\n\n2023Q2\n8\n2\n\n\n2023Q3\n5\n4\n\n\n2023Q4\n9\n4\n\n\n2024Q1\n7\n9"
  },
  {
    "objectID": "aluetalous.html#avoimet-työpaikat-kuukauden-laskentapäivänä-lkm.",
    "href": "aluetalous.html#avoimet-työpaikat-kuukauden-laskentapäivänä-lkm.",
    "title": "Aluetalous ja yritystoiminta",
    "section": "Avoimet työpaikat kuukauden laskentapäivänä (lkm.)",
    "text": "Avoimet työpaikat kuukauden laskentapäivänä (lkm.)\n\n\n\n\n\n\n\nAvoimet työpaikat kuukauden laskentapäivänä (lkm.)\nAvoimia työpaikkoja oli 2024M08 yhteensä 11 (lukema 2024M07: 13).\n\n\n\n\n\n\n\n\nKuukausi\nAvoimet työpaikat kuukauden laskentapäivänä (lkm.)\n\n\n\n\n2022M09\n27\n\n\n2022M10\n40\n\n\n2022M11\n23\n\n\n2022M12\n17\n\n\n2023M01\n11\n\n\n2023M02\n15\n\n\n2023M03\n44\n\n\n2023M04\n25\n\n\n2023M05\n18\n\n\n2023M06\n15\n\n\n2023M07\n19\n\n\n2023M08\n20\n\n\n2023M09\n25\n\n\n2023M10\n5\n\n\n2023M11\nNA\n\n\n2023M12\n5\n\n\n2024M01\nNA\n\n\n2024M02\n5\n\n\n2024M03\n6\n\n\n2024M04\nNA\n\n\n2024M05\n10\n\n\n2024M06\n17\n\n\n2024M07\n13\n\n\n2024M08\n11"
  },
  {
    "objectID": "aluetalous.html#uudet-avoimet-työpaikat",
    "href": "aluetalous.html#uudet-avoimet-työpaikat",
    "title": "Aluetalous ja yritystoiminta",
    "section": "Uudet avoimet työpaikat",
    "text": "Uudet avoimet työpaikat\n\n\n\n\n\n\n\nAvoimet työpaikat kuukauden laskentapäivänä (lkm.)\nAvoimia työpaikkoja oli 2024M08 yhteensä 7 (lukema 2024M07: 10).\n\n\n\n\n\n\n\n\nKuukausi\nUudet avoimet työpaikat kuukauden aikana (lkm.)\n\n\n\n\n2022M09\n23\n\n\n2022M10\n24\n\n\n2022M11\n8\n\n\n2022M12\n22\n\n\n2023M01\n11\n\n\n2023M02\n14\n\n\n2023M03\n44\n\n\n2023M04\n12\n\n\n2023M05\n28\n\n\n2023M06\n7\n\n\n2023M07\n19\n\n\n2023M08\n7\n\n\n2023M09\n17\n\n\n2023M10\n6\n\n\n2023M11\n6\n\n\n2023M12\n6\n\n\n2024M01\n11\n\n\n2024M02\n7\n\n\n2024M03\n10\n\n\n2024M04\n6\n\n\n2024M05\n15\n\n\n2024M06\n19\n\n\n2024M07\n10\n\n\n2024M08\n7"
  },
  {
    "objectID": "data/kunta_center.html",
    "href": "data/kunta_center.html",
    "title": "",
    "section": "",
    "text": "&lt;!DOCTYPE qgis PUBLIC ‘http://mrcc.com/qgis.dtd’ ‘SYSTEM’&gt;     \n\n\n                 0 0     false"
  },
  {
    "objectID": "kansainvalisyys.html",
    "href": "kansainvalisyys.html",
    "title": "Kansainvälisyys",
    "section": "",
    "text": "d3 = require(\"d3@7\")\n//import {Legend} from \"@d3/color-legend\"\n\nfolderKunnat24TopoJSON = \"./maps/Kunnat2024Topo.json\"\nkunnat2024topo = FileAttachmentDynamic(folderKunnat24TopoJSON).json()\nmapTopoJSON = topojson.feature(kunnat2024topo, kunnat2024topo.objects.Kunnat2024_geo).features\n\n\nfolderMaakunnat24TopoJSON = \"./maps/Maakunnat2024Topo.json\"\nmaakunnat_2024_topo =  FileAttachmentDynamic(folderMaakunnat24TopoJSON).json()\nFileAttachmentDynamic = function(filename) {\n  return new Function(\"FileAttachment\", `return FileAttachment(\"${filename}\")`)(FileAttachment)\n}\n\n// Vaihdetaan tekstin väri\ncolor = function(vari) {\n  if(vari &gt; 0){\n      return \"green\"\n    }else{\n      return \"red\"\n    }\n}\n// Pyöristys\npyoristys = function(n, places) {\n  if (!places) return Math.round(n);\n  const d = 10 ** places;\n  return Math.round(n * d) / d;\n}\n//Euromerkintä\neurot = function(number) {\n  return number.toLocaleString('fi-FI', { style: 'currency', currency: 'EUR',minimumFractionDigits: 0 });\n}\n// Euromuutoksen laskeminen kertoimella\nmuutoskerroin = function(x, y) {\n  return (1+x/100)*y;\n}\n// Muutosprosentti\nmuutosprosentti = function(x, y) {\n  return pyoristys(((x-y)/y)*100,1);\n}\n// Tuhatjakaja\ntuhatjakaja = function(x) {\n  return x/1000;\n}\n// Euromuutoksen laskeminen kertoimella\npalkkakerroin = function(x, y) {\n  return 100*((1+x/100)*(1+y/100)-1);\n}\n// Jako-osuuden asukaskerroin\nasukaskerroin = function(x, y) {\n  return (x/y);\n}\n// Jako-osuuden veroprosenttikerroin miinus1/miinus3 vuotta miinus 1 vuoden kerroin\nveroprosenttikerroin = function(x, y) {\n  return (x/y);\n}\n// Kunnan muok. kunnallisvero, alkuvuosi ja loppuvuosi \nkunnallisvero_muokkaus = function(kunnallisvero,asukaskerroin,veroprosentti) {\n  return kunnallisvero*asukaskerroin*veroprosentti;\n}\n\n//Tekstimuutokset\nfn_nousu_lasku_txt = function(arvo){\n  if(arvo &gt; 0) {\n  return \"kasvanut\" \n  }\n  else { \n  return \"laskenut\";\n  }\n}\n\n//TARVITAAN KARTOISSA\nserialize = {\n  const xmlns = \"http://www.w3.org/2000/xmlns/\";\n  const xlinkns = \"http://www.w3.org/1999/xlink\";\n  const svgns = \"http://www.w3.org/2000/svg\";\n  return function serialize(svg) {\n    svg = svg.cloneNode(true);\n    const fragment = window.location.href + \"#\";\n    const walker = document.createTreeWalker(svg, NodeFilter.SHOW_ELEMENT);\n    while (walker.nextNode()) {\n      for (const attr of walker.currentNode.attributes) {\n        if (attr.value.includes(fragment)) {\n          attr.value = attr.value.replace(fragment, \"#\");\n        }\n      }\n    }\n    svg.setAttributeNS(xmlns, \"xmlns\", svgns);\n    svg.setAttributeNS(xmlns, \"xmlns:xlink\", xlinkns);\n    const serializer = new window.XMLSerializer;\n    const string = serializer.serializeToString(svg);\n    return new Blob([string], {type: \"image/svg+xml\"});\n  };\n}\n\n\nfunction toSVG(chart) {\n  if (chart.nodeName !== \"FIGURE\") {\n    return chart;\n  }\n\n  // the chart needs to be in the body if we want to read values, positions, sizes…\n  document.body.appendChild(chart);\n  const [x0, y0, width, height] = getBounds([chart]);\n\n  const nodes = [];\n\n  for (const node of d3\n    .select(chart)\n    .selectChildren(\"h1,h2,h3,div,figcaption,svg\")) {\n    switch (node.nodeName.toLowerCase()) {\n      case \"div\":\n        {\n          const children = d3.select(node).selectChildren(\"div,span\");\n          const height = getBounds([node, ...children])[3] + 2;\n          const svg = d3\n            .select(chart)\n            .append(\"svg\")\n            .attr(\"width\", width)\n            .attr(\"height\", height);\n          nodes.push(svg.node());\n\n          const swatches = svg\n            .selectAll()\n            .data(\n              Array.from(children, (d) =&gt; {\n                const svg = d3.select(d).select(\"svg\").node();\n                const bbox = svg.getBBox();\n                return {\n                  style: window.getComputedStyle(d),\n                  svg,\n                  width: bbox.width,\n                  height: bbox.height,\n                  text: d.textContent,\n                  bounds: getBounds([d])\n                };\n              })\n            )\n            .join(\"g\")\n            .attr(\n              \"transform\",\n              (d) =&gt; `translate(${d.bounds[0] - x0},${10 + d.bounds[1] - y0})`\n            );\n\n          swatches\n            .append((d) =&gt; d.svg) // \"rect\")\n            .attr(\"width\", (d) =&gt; d.width)\n            .attr(\"height\", (d) =&gt; d.height)\n            .attr(\"y\", (d) =&gt; `${-parseFloat(d.height) / 2}px`);\n          swatches\n            .append(\"text\")\n            .text((d) =&gt; d.text)\n            .attr(\"x\", (d) =&gt; d.width)\n            .attr(\"dx\", 5)\n            .attr(\"dy\", \"0.38em\")\n            .attr(\"font-family\", (d) =&gt; d.style.fontFamily)\n            .attr(\"font-size\", (d) =&gt; d.style.fontSize)\n            .attr(\"fill\", (d) =&gt; d.style.color);\n        }\n        break;\n      case \"figcaption\":\n      case \"h1\":\n      case \"h2\":\n      case \"h3\":\n        {\n          const svg = d3\n            .select(chart)\n            .append(\"svg\")\n            .attr(\"width\", width)\n            .attr(\"overflow\", \"visible\");\n          nodes.push(svg.node());\n\n          const children = d3.select(node).selectChildren();\n\n          let h = 0;\n          for (const d of children.size() &gt; 0\n            ? children.selectChildren()\n            : [node]) {\n            const style = window.getComputedStyle(d);\n            const t = svg\n              .append(\"g\")\n              .attr(\"transform\", `translate(0,${h})`)\n              .append(() =&gt;\n                d3\n                  .select(\n                    Plot.text([d.textContent], {\n                      text: (d) =&gt; d,\n                      lineWidth:\n                        (1.06 * parseFloat(style.width)) /\n                        parseFloat(style.fontSize),\n                      lineHeight: 1.2,\n                      frameAnchor: \"top-left\"\n                    }).plot()\n                  )\n                  .select(\"text\")\n                  .attr(\"font-family\", style.fontFamily)\n                  .attr(\"font-size\", 1.08 * parseFloat(style.fontSize))\n                  .attr(\"font-weight\", style.fontWeight)\n                  .attr(\"fill\", style.color)\n                  .node()\n              );\n            h += getBounds([t.node()])[3] + 4;\n          }\n          svg.attr(\"height\", h);\n        }\n        break;\n      case \"svg\":\n        d3.select(chart).append(() =&gt; node);\n        nodes.push(node);\n        break;\n    }\n  }\n\n  return serializeAll(nodes)\n    .then((blob) =&gt; blob.text())\n    .then((c) =&gt; {\n      document.body.removeChild(chart);\n      return Object.assign(svg`${c}`, chart);\n    });\n}\n\n\n// Given an array of SVG elements, composites them into a single SVG element,\n// and then serializes the result to a blob.\nasync function serializeAll(elements, {padding = 10} = {}) {\n  const fragment = location.href + \"#\";\n  let root;\n  if (elements.length === 1) {\n    root = elements[0].cloneNode(true); // optimize common case\n  } else {\n    const [ox, oy, dx, dy] = getBounds(elements);\n    root = document.createElementNS(svgns, \"svg\");\n    root.setAttribute(\"width\", dx + 2 * padding);\n    root.setAttribute(\"height\", dy + 2 * padding);\n    root.setAttribute(\"viewBox\", [-padding, -padding, dx + 2 * padding, dy + 2 * padding]);\n    for (const element of elements) {\n      const svg = root.appendChild(element.cloneNode(true));\n      const { x, y, width, height } = element.getBoundingClientRect();\n      svg.setAttribute(\"x\", x - ox);\n      svg.setAttribute(\"y\", y - oy);\n      svg.setAttribute(\"width\", width);\n      svg.setAttribute(\"height\", height);\n    }\n  }\n  const walker = document.createTreeWalker(root, NodeFilter.SHOW_ELEMENT);\n  while (walker.nextNode()) {\n    const node = walker.currentNode;\n    for (const attr of node.attributes) {\n      if (attr.value.includes(fragment)) {\n        attr.value = attr.value.replace(fragment, \"#\");\n      }\n    }\n  }\n  root.setAttributeNS(xmlns, \"xmlns\", svgns);\n  root.setAttributeNS(xmlns, \"xmlns:xlink\", xlinkns);\n  const serializer = new XMLSerializer();\n  const string = serializer.serializeToString(root);\n  return new Blob([string], { type: \"image/svg+xml\" });\n}\n\n\nfunction getBounds(elements) {\n  let x1 = Infinity;\n  let y1 = x1;\n  let x2 = -x1;\n  let y2 = x2;\n  for (const element of elements) {\n    const { x, y, width, height } = element.getBoundingClientRect();\n    if (x &lt; x1) x1 = x;\n    if (x + width &gt; x2) x2 = x + width;\n    if (y &lt; y1) y1 = y;\n    if (y + height &gt; y2) y2 = y + height;\n  }\n  return [x1, y1, x2 - x1, y2 - y1];\n}\n\n// based on https://observablehq.com/@gka/cheap-fit-text-to-circle\nfunction lines(text, targetWidth) {\n  const CHAR_W = {\n    \"a\":7,\"B\":8,\"C\":8,\"c\":6,\"D\":9,\"f\":4,\"G\":9,\"H\":9,\"I\":3,\"i\":3,\"J\":5,\"j\":3,\"K\":8,\"k\":6,\n    \"l\":3,\"M\":11,\"m\":11,\"N\":9,\"O\":9,\"P\":8,\"Q\":9,\"R\":8,\"r\":4,\"S\":8,\"s\":6,\"t\":4,\"U\":9,\"v\":6,\n    \"W\":11,\"w\":9,\"x\":6,\"y\":6,\"z\":5,\".\":2,\",\":2,\":\":2,\";\":2\n  };\n  function measureWidth(text) { return  d3.sum(text, char =&gt; CHAR_W[char] || CHAR_W[\"a\"]) * 0.8; };\n\n  const words = text.split(\" \");\n  let line;\n  let lineWidth0 = Infinity;\n  const lines = [];\n  for (let i = 0, n = words.length; i &lt; n; ++i) {\n    let lineText1 = (line ? line.text + \" \" : \"\") + words[i];\n    let lineWidth1 = measureWidth(lineText1);\n    if ((lineWidth0 + lineWidth1) / 2 &lt; targetWidth) {\n      line.width = lineWidth0 = lineWidth1;\n      line.text = lineText1;\n    } else {\n      lineWidth0 = measureWidth(words[i]);\n      line = {width: lineWidth0, text: words[i]};\n      lines.push(line);\n    }\n  }\n  return lines;\n}\n\nxmlns = \"http://www.w3.org/2000/xmlns/\"\n\nxlinkns = \"http://www.w3.org/1999/xlink\"\n\nsvgns = \"http://www.w3.org/2000/svg\"\nfunction Legend(color, {\n  title,\n  tickSize = 6,\n  width = 320, \n  height = 44 + tickSize,\n  marginTop = 18,\n  marginRight = 0,\n  marginBottom = 16 + tickSize,\n  marginLeft = 0,\n  ticks = width / 64,\n  tickFormat,\n  tickValues\n} = {}) {\n\n  function ramp(color, n = 256) {\n    const canvas = document.createElement(\"canvas\");\n    canvas.width = n;\n    canvas.height = 1;\n    const context = canvas.getContext(\"2d\");\n    for (let i = 0; i &lt; n; ++i) {\n      context.fillStyle = color(i / (n - 1));\n      context.fillRect(i, 0, 1, 1);\n    }\n    return canvas;\n  }\n\n  const svg = d3.create(\"svg\")\n      .attr(\"width\", width)\n      .attr(\"height\", height)\n      .attr(\"viewBox\", [0, 0, width, height])\n      .style(\"overflow\", \"visible\")\n      .style(\"display\", \"block\");\n\n  let tickAdjust = g =&gt; g.selectAll(\".tick line\").attr(\"y1\", marginTop + marginBottom - height);\n  let x;\n\n  // Continuous\n  if (color.interpolate) {\n    const n = Math.min(color.domain().length, color.range().length);\n\n    x = color.copy().rangeRound(d3.quantize(d3.interpolate(marginLeft, width - marginRight), n));\n\n    svg.append(\"image\")\n        .attr(\"x\", marginLeft)\n        .attr(\"y\", marginTop)\n        .attr(\"width\", width - marginLeft - marginRight)\n        .attr(\"height\", height - marginTop - marginBottom)\n        .attr(\"preserveAspectRatio\", \"none\")\n        .attr(\"xlink:href\", ramp(color.copy().domain(d3.quantize(d3.interpolate(0, 1), n))).toDataURL());\n  }\n\n  // Sequential\n  else if (color.interpolator) {\n    x = Object.assign(color.copy()\n        .interpolator(d3.interpolateRound(marginLeft, width - marginRight)),\n        {range() { return [marginLeft, width - marginRight]; }});\n\n    svg.append(\"image\")\n        .attr(\"x\", marginLeft)\n        .attr(\"y\", marginTop)\n        .attr(\"width\", width - marginLeft - marginRight)\n        .attr(\"height\", height - marginTop - marginBottom)\n        .attr(\"preserveAspectRatio\", \"none\")\n        .attr(\"xlink:href\", ramp(color.interpolator()).toDataURL());\n\n    // scaleSequentialQuantile doesn’t implement ticks or tickFormat.\n    if (!x.ticks) {\n      if (tickValues === undefined) {\n        const n = Math.round(ticks + 1);\n        tickValues = d3.range(n).map(i =&gt; d3.quantile(color.domain(), i / (n - 1)));\n      }\n      if (typeof tickFormat !== \"function\") {\n        tickFormat = d3.format(tickFormat === undefined ? \",f\" : tickFormat);\n      }\n    }\n  }\n\n  // Threshold\n  else if (color.invertExtent) {\n    const thresholds\n        = color.thresholds ? color.thresholds() // scaleQuantize\n        : color.quantiles ? color.quantiles() // scaleQuantile\n        : color.domain(); // scaleThreshold\n\n    const thresholdFormat\n        = tickFormat === undefined ? d =&gt; d\n        : typeof tickFormat === \"string\" ? d3.format(tickFormat)\n        : tickFormat;\n\n    x = d3.scaleLinear()\n        .domain([-1, color.range().length - 1])\n        .rangeRound([marginLeft, width - marginRight]);\n\n    svg.append(\"g\")\n      .selectAll(\"rect\")\n      .data(color.range())\n      .join(\"rect\")\n        .attr(\"x\", (d, i) =&gt; x(i - 1))\n        .attr(\"y\", marginTop)\n        .attr(\"width\", (d, i) =&gt; x(i) - x(i - 1))\n        .attr(\"height\", height - marginTop - marginBottom)\n        .attr(\"fill\", d =&gt; d);\n\n    tickValues = d3.range(thresholds.length);\n    tickFormat = i =&gt; thresholdFormat(thresholds[i], i);\n  }\n\n  // Ordinal\n  else {\n    x = d3.scaleBand()\n        .domain(color.domain())\n        .rangeRound([marginLeft, width - marginRight]);\n\n    svg.append(\"g\")\n      .selectAll(\"rect\")\n      .data(color.domain())\n      .join(\"rect\")\n        .attr(\"x\", x)\n        .attr(\"y\", marginTop)\n        .attr(\"width\", Math.max(0, x.bandwidth() - 1))\n        .attr(\"height\", height - marginTop - marginBottom)\n        .attr(\"fill\", color);\n\n    tickAdjust = () =&gt; {};\n  }\n\n  svg.append(\"g\")\n      .attr(\"transform\", `translate(0,${height - marginBottom})`)\n      .call(d3.axisBottom(x)\n        .ticks(ticks, typeof tickFormat === \"string\" ? tickFormat : undefined)\n        .tickFormat(typeof tickFormat === \"function\" ? tickFormat : undefined)\n        .tickSize(tickSize)\n        .tickValues(tickValues))\n      .call(tickAdjust)\n      .call(g =&gt; g.select(\".domain\").remove())\n      .call(g =&gt; g.append(\"text\")\n        .attr(\"x\", marginLeft)\n        .attr(\"y\", marginTop + marginBottom - height - 6)\n        .attr(\"fill\", \"currentColor\")\n        .attr(\"text-anchor\", \"start\")\n        .attr(\"font-weight\", \"bold\")\n        .style(\"font-size\", \"12px\")\n        .attr(\"class\", \"title\")\n        .text(title));\n\n  return svg.node();\n}\n\n\nfunction legend({color, ...options}) {\n  return Legend(color, options);\n}\n\n\n// Copyright 2021, Observable Inc.\n// Released under the ISC license.\n// https://observablehq.com/@d3/color-legend\nfunction Swatches(color, {\n  columns = null,\n  format,\n  unknown: formatUnknown,\n  swatchSize = 15,\n  swatchWidth = swatchSize,\n  swatchHeight = swatchSize,\n  marginLeft = 0\n} = {}) {\n  const id = `-swatches-${Math.random().toString(16).slice(2)}`;\n  const unknown = formatUnknown == null ? undefined : color.unknown();\n  const unknowns = unknown == null || unknown === d3.scaleImplicit ? [] : [unknown];\n  const domain = color.domain().concat(unknowns);\n  if (format === undefined) format = x =&gt; x === unknown ? formatUnknown : x;\n\n  function entity(character) {\n    return `&#${character.charCodeAt(0).toString()};`;\n  }\n\n  if (columns !== null) return htl.html`&lt;div style=\"display: flex; align-items: center; margin-left: ${+marginLeft}px; min-height: 33px; font: 12px sans-serif;\"&gt;\n  &lt;style&gt;\n\n.${id}-item {\n  break-inside: avoid;\n  display: flex;\n  align-items: center;\n  padding-bottom: 1px;\n}\n\n.${id}-label {\n  white-space: nowrap;\n  overflow: hidden;\n  text-overflow: ellipsis;\n  max-width: calc(100% - ${+swatchWidth}px - 0.5em);\n}\n\n.${id}-swatch {\n  width: ${+swatchWidth}px;\n  height: ${+swatchHeight}px;\n  margin: 0 0.5em 0 0;\n}\n\n  &lt;/style&gt;\n  &lt;div style=${{width: \"100%\", columns}}&gt;${domain.map(value =&gt; {\n    const label = `${format(value)}`;\n    return htl.html`&lt;div class=${id}-item&gt;\n      &lt;div class=${id}-swatch style=${{background: color(value)}}&gt;&lt;/div&gt;\n      &lt;div class=${id}-label title=${label}&gt;${label}&lt;/div&gt;\n    &lt;/div&gt;`;\n  })}\n  &lt;/div&gt;\n&lt;/div&gt;`;\n\n  return htl.html`&lt;div style=\"display: flex; align-items: center; min-height: 33px; margin-left: ${+marginLeft}px; font: 12px sans-serif;\"&gt;\n  &lt;style&gt;\n\n.${id} {\n  display: inline-flex;\n  align-items: center;\n  margin-right: 1em;\n}\n\n.${id}::before {\n  content: \"\";\n  width: ${+swatchWidth}px;\n  height: ${+swatchHeight}px;\n  margin-right: 0.5em;\n  background: var(--color);\n}\n\n  &lt;/style&gt;\n  &lt;div&gt;${domain.map(value =&gt; htl.html`&lt;span class=\"${id}\" style=\"--color: ${color(value)}\"&gt;${format(value)}&lt;/span&gt;`)}&lt;/div&gt;`;\n}\n\nfunction swatches({color, ...options}) {\n  return Swatches(color, options);\n}\nchart_map_d3 = function(data, mapTopoJSON, color, colorBorder, txtTitle, chart_width, chart_height) {\n\n  const projection = d3.geoMercator()\n  .scale(1200)\n  //.center([40, 67.5])\n  .center([40, 67.3])\n  .translate([400, 220])\n  const path = d3.geoPath().projection(projection);\n  const format = d =&gt; `${d}%`;\n  \n  //Määritellään tähän muuttujat CSV:stä!!!!!!\n  const valuemap = new Map(data.map(d =&gt; [d.id, d.muutos]));\n  \n  //Määritellään maakunnat\n  const maakuntamesh = topojson.mesh(maakunnat_2024_topo, maakunnat_2024_topo.objects.maakunnat_2024, (a, b) =&gt; a !== b);\n  \n  const zoom = d3.zoom()\n      .scaleExtent([1, 8])\n      .on(\"zoom\", zoomed);\n\n  const svg = d3.create(\"svg\")\n      .attr(\"width\", 900)\n      .attr(\"height\", 650)\n      .attr(\"viewBox\", [0, 0, 900, 650])\n      .on(\"click\", reset);\n      \n  const g = svg.append(\"g\")\n      .attr(\"transform\", \"translate(20,35)\")\n      .append(() =&gt; Legend(color, {title: txtTitle, width: 260}));\n\n  g.append(\"g\")\n    .selectAll(\"path\")\n    .data(mapTopoJSON)\n    .join(\"path\")\n      .attr(\"fill\", d =&gt; color(valuemap.get(d.properties.kunta))) \n      .attr(\"d\", path)\n    .append(\"title\")\n      .text(d =&gt; `${d.properties.name},\\n(${d.properties.nimi_2}),\\n${valuemap.get(d.properties.kunta)}`);\n      \n  g.append(\"path\")\n      .datum(maakuntamesh)\n      .attr(\"fill\", \"none\")\n      .attr(\"stroke\", colorBorder)\n      .attr(\"stroke-linejoin\", \"round\")\n      .attr(\"d\", path);\n      \n   svg.call(zoom);\n   \n\n  function reset() {\n    // states.transition().style(\"fill\", null);\n    svg.transition().duration(750).call(\n      zoom.transform,\n      d3.zoomIdentity,\n      d3.zoomTransform(svg.node()).invert([chart_width / 2, chart_height / 2])\n    );\n  }\n\n  function zoomed(event) {\n    const {transform} = event;\n    g.attr(\"transform\", transform);\n    g.attr(\"stroke-width\", 1 / transform.k);\n  }     \n      \n  return svg.node();\n}\nchart_chord_d3 = function(data, title_txt_chord, chart_width, chart_height) {\n\n  var sum_target;\n  var sum_source;\n  let vari;\n  var sum_yht;\n  \n  const margin = ({top: 20, right: 20, bottom: 0, left: 50});\n  const width = 300;\n  const height = width;\n  const innerRadius = Math.min(width, height) * .3 - 40;\n  const outerRadius = innerRadius + 15;\n  \n  \n  const chord = d3.chordDirected()\n    .padAngle(0.5 / innerRadius)\n    .sortSubgroups(d3.ascending)\n    .sortChords(d3.ascending);\n    \n  const ribbon = d3.ribbon()\n    .radius(innerRadius - 1)\n    .padAngle(0.5 / innerRadius);\n    \n  const rename = name =&gt; name.substring(name.indexOf(\".\") + 1, name.lastIndexOf(\".\"))\n  const names = Array.from(new Set(data.flatMap(d =&gt; [d.source, d.target]))).sort(d3.ascending);\n  \n  function matriisi(names) {\n    const index = new Map(names.map((name, i) =&gt; [name, i]));\n    const matrix = Array.from(index, () =&gt; new Array(names.length).fill(0));\n    for (const {source, target, value} of data) matrix[index.get(source)][index.get(target)] += value;\n    return matrix;\n  }\n\n const matrix = matriisi(names)\n  \n const arc = d3.arc()\n    .innerRadius(innerRadius)\n    .outerRadius(outerRadius)\n\n  //TÄSTÄ ALKAA PIIRROS\n  \n  const zoom = d3.zoom()\n      .scaleExtent([1, 8])\n      .on(\"zoom\", zoomed);\n  \n  const svg = d3.create(\"svg\")\n      .attr(\"viewBox\", [-width / 2, -height / 2.5, width, height]);\n\n  const chords = chord(matrix);\n  \n  const group = svg.append(\"g\")\n      .attr(\"font-size\", 3)\n      .attr(\"font-family\", \"Century Gothic\")\n    .selectAll(\"g\")\n    .data(chords.groups)\n    .join(\"g\");\n\n  group.append(\"path\")\n      .attr(\"fill\", d =&gt; {\n           sum_target = d3.sum(chords, c =&gt; (c.target.index === d.index) * c.target.value);\n           sum_source = d3.sum(chords, c =&gt; (c.source.index === d.index) * c.source.value);\n           sum_yht = sum_target-sum_source;\n            if (sum_yht &gt; 0) { \n              vari = \"#009651\"\n              return vari \n            }\n            else if (sum_yht == 0) { \n              vari = \"#28336C\"\n              return vari \n            }\n            else    { \n              vari = \"#DE232F\" \n              return vari \n            }\n        })\n      .attr(\"d\", arc);\n\n  group.append(\"text\")\n      .each(d =&gt; (d.angle = (d.startAngle + d.endAngle) / 2))\n      .attr(\"dy\", \"0.35em\")\n      .attr(\"transform\", d =&gt; `\n        rotate(${(d.angle * 180 / Math.PI - 90)})\n        translate(${outerRadius + 6})\n        ${d.angle &gt; Math.PI ? \"rotate(180)\" : \"\"}\n      `)\n      .attr(\"text-anchor\", d =&gt; d.angle &gt; Math.PI ? \"end\" : null)\n      //.text(d =&gt; names[d.index])\n      .text(d =&gt; (d.index &gt;= 3) ? names[d.index] : \"\")\n      .attr(\"fill\", d =&gt; {\n           sum_target = d3.sum(chords, c =&gt; (c.target.index === d.index) * c.target.value);\n           sum_source = d3.sum(chords, c =&gt; (c.source.index === d.index) * c.source.value);\n           sum_yht = sum_target-sum_source;\n            if (sum_yht &gt; 0) { \n              vari = \"#009651\"\n              return vari\n            }\n            else if (sum_yht == 0) { \n              vari = \"#28336C\"\n              return vari \n            }\n            else    { \n              vari = \"#DE232F\" \n              return vari \n            }\n        });\n\n  group.append(\"title\")\n      .text(d =&gt; `${names[d.index]} \n\n${d3.sum(chords, c =&gt; (c.source.index === d.index) * c.source.value)} lähtee →\n${d3.sum(chords, c =&gt; (c.target.index === d.index) * c.source.value)} tulee ←\n${d3.sum(chords, c =&gt; (c.target.index === d.index) * c.target.value)- d3.sum(chords, c =&gt; (c.source.index === d.index) * c.source.value)} netto =`);  \n\n  svg.append(\"g\")\n      .attr(\"fill-opacity\", 0.75)\n    .selectAll(\"path\")\n    .data(chords)\n    .join(\"path\")\n      .style(\"mix-blend-mode\", \"multiply\")\n          .attr(\"fill\", d =&gt; {\n           sum_target = d3.sum(chords, c =&gt; (c.target.index === d.index) * c.target.value);\n           sum_source = d3.sum(chords, c =&gt; (c.source.index === d.index) * c.source.value);\n           sum_yht = sum_target-sum_source;\n            if (sum_yht &gt; 0) { \n              vari = \"#009651\"\n              return vari \n            }\n            else if (sum_yht == 0) { \n              vari = \"#28336C\"\n              return vari \n            }\n            else    { \n              vari = \"#DE232F\" \n              return vari \n            }\n        })\n      .attr(\"d\", ribbon)\n    .append(\"title\")\n      .text(d =&gt; `${names[d.source.index]} --&gt; ${names[d.target.index]} ${d.source.value}`);\n      \n      \n  svg.call(zoom);\n   \n\n  function reset() {\n    // states.transition().style(\"fill\", null);\n    svg.transition().duration(750).call(\n      zoom.transform,\n      d3.zoomIdentity,\n      d3.zoomTransform(svg.node()).invert([chart_width / 2, chart_height / 2])\n    );\n  }\n\n  function zoomed(event) {\n    const {transform} = event;\n    svg.attr(\"transform\", transform);\n    svg.attr(\"stroke-width\", 1 / transform.k);\n  }    \n\n  return svg.node();\n\n\n}"
  },
  {
    "objectID": "kansainvalisyys.html#kansainvälisyys---maahanmuutto-ja-nettomaahanmuutto",
    "href": "kansainvalisyys.html#kansainvälisyys---maahanmuutto-ja-nettomaahanmuutto",
    "title": "Kansainvälisyys",
    "section": "Kansainvälisyys - Maahanmuutto ja nettomaahanmuutto",
    "text": "Kansainvälisyys - Maahanmuutto ja nettomaahanmuutto\n\n\n\n\n\n\n\nMaahanmuutto ja nettomaahanmuutto\nKumulatiivinen nettomaahanmuutto oli vuoden alusta tähän hetkeen 2024M08* yhteensä 11. Edellisvuoden lukema nettomaahanmuutossa oli 56. Erotusta nettomaahanmuutossa viime vuoteen on yhteensä -45 henkilöä. Pohjoismaista oli muuttanut yhteensä yhteensä 0 henkilöä ja muista EU-maista 1 henkilöä. Kokonaisuudessaan maahanmuuttajia oli yhteensä 16.\nNettomaahanmuutto (tai nettosiirtolaisuus) on maahanmuuton ja maastamuuton erotus. Lähde: Tilastokeskus\n\n\n\n\n\n\n\n\nVuosi\nMaahanmuutto Suomeen\nMaahanmuutto Suomeen Pohjoismaista\nMaahanmuutto Suomeen EU-maista\nNettomaahanmuutto\n\n\n\n\n2015\n15\n5\n4\n2\n\n\n2016\n2\n1\n1\n-1\n\n\n2017\n11\n1\n2\n9\n\n\n2018\n9\n0\n1\n5\n\n\n2019\n4\n0\n1\n4\n\n\n2020\n11\n1\n1\n8\n\n\n2021\n17\n0\n0\n15\n\n\n2022\n7\n0\n0\n6\n\n\n2023\n57\n0\n0\n56\n\n\n2024M08*\n16\n0\n1\n11"
  },
  {
    "objectID": "maps/pienalue2024.html",
    "href": "maps/pienalue2024.html",
    "title": "",
    "section": "",
    "text": "&lt;!DOCTYPE qgis PUBLIC ‘http://mrcc.com/qgis.dtd’ ‘SYSTEM’&gt;  Tilastollinen_aluejako_2021_alkaen  FIN dataset\n\nTilastollinen_aluejako_2021_alkaen\n\n               PROJCRS[“ETRS89 / GK24FIN”,BASEGEOGCRS[“ETRS89”,ENSEMBLE[“European Terrestrial Reference System 1989 ensemble”,MEMBER[“European Terrestrial Reference Frame 1989”],MEMBER[“European Terrestrial Reference Frame 1990”],MEMBER[“European Terrestrial Reference Frame 1991”],MEMBER[“European Terrestrial Reference Frame 1992”],MEMBER[“European Terrestrial Reference Frame 1993”],MEMBER[“European Terrestrial Reference Frame 1994”],MEMBER[“European Terrestrial Reference Frame 1996”],MEMBER[“European Terrestrial Reference Frame 1997”],MEMBER[“European Terrestrial Reference Frame 2000”],MEMBER[“European Terrestrial Reference Frame 2005”],MEMBER[“European Terrestrial Reference Frame 2014”],ELLIPSOID[“GRS 1980”,6378137,298.257222101,LENGTHUNIT[“metre”,1]],ENSEMBLEACCURACY[0.1]],PRIMEM[“Greenwich”,0,ANGLEUNIT[“degree”,0.0174532925199433]],ID[“EPSG”,4258]],CONVERSION[“Finland Gauss-Kruger zone 24”,METHOD[“Transverse Mercator”,ID[“EPSG”,9807]],PARAMETER[“Latitude of natural origin”,0,ANGLEUNIT[“degree”,0.0174532925199433],ID[“EPSG”,8801]],PARAMETER[“Longitude of natural origin”,24,ANGLEUNIT[“degree”,0.0174532925199433],ID[“EPSG”,8802]],PARAMETER[“Scale factor at natural origin”,1,SCALEUNIT[“unity”,1],ID[“EPSG”,8805]],PARAMETER[“False easting”,24500000,LENGTHUNIT[“metre”,1],ID[“EPSG”,8806]],PARAMETER[“False northing”,0,LENGTHUNIT[“metre”,1],ID[“EPSG”,8807]]],CS[Cartesian,2],AXIS[“northing (N)”,north,ORDER[1],LENGTHUNIT[“metre”,1]],AXIS[“easting (E)”,east,ORDER[2],LENGTHUNIT[“metre”,1]],USAGE[SCOPE[“Cadastre, engineering survey, topographic mapping (large scale).”],AREA[“Finland - nominally onshore between 23�30’E and 24�30’E but may be used in adjacent areas if a municipality chooses to use one zone over its whole extent.”],BBOX[59.86,23.5,68.84,24.5]],ID[“EPSG”,3878]] +proj=tmerc +lat_0=0 +lon_0=24 +k=1 +x_0=24500000 +y_0=0 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs 27312 3878 EPSG:3878 ETRS89 / GK24FIN tmerc EPSG:7019 false"
  },
  {
    "objectID": "syntyvyys.html",
    "href": "syntyvyys.html",
    "title": "Syntyvyys",
    "section": "",
    "text": "d3 = require(\"d3@7\")\n//import {Legend} from \"@d3/color-legend\"\n\nfolderKunnat24TopoJSON = \"./maps/Kunnat2024Topo.json\"\nkunnat2024topo = FileAttachmentDynamic(folderKunnat24TopoJSON).json()\nmapTopoJSON = topojson.feature(kunnat2024topo, kunnat2024topo.objects.Kunnat2024_geo).features\n\n\nfolderMaakunnat24TopoJSON = \"./maps/Maakunnat2024Topo.json\"\nmaakunnat_2024_topo =  FileAttachmentDynamic(folderMaakunnat24TopoJSON).json()\nFileAttachmentDynamic = function(filename) {\n  return new Function(\"FileAttachment\", `return FileAttachment(\"${filename}\")`)(FileAttachment)\n}\n\n// Vaihdetaan tekstin väri\ncolor = function(vari) {\n  if(vari &gt; 0){\n      return \"green\"\n    }else{\n      return \"red\"\n    }\n}\n// Pyöristys\npyoristys = function(n, places) {\n  if (!places) return Math.round(n);\n  const d = 10 ** places;\n  return Math.round(n * d) / d;\n}\n//Euromerkintä\neurot = function(number) {\n  return number.toLocaleString('fi-FI', { style: 'currency', currency: 'EUR',minimumFractionDigits: 0 });\n}\n// Euromuutoksen laskeminen kertoimella\nmuutoskerroin = function(x, y) {\n  return (1+x/100)*y;\n}\n// Muutosprosentti\nmuutosprosentti = function(x, y) {\n  return pyoristys(((x-y)/y)*100,1);\n}\n// Tuhatjakaja\ntuhatjakaja = function(x) {\n  return x/1000;\n}\n// Euromuutoksen laskeminen kertoimella\npalkkakerroin = function(x, y) {\n  return 100*((1+x/100)*(1+y/100)-1);\n}\n// Jako-osuuden asukaskerroin\nasukaskerroin = function(x, y) {\n  return (x/y);\n}\n// Jako-osuuden veroprosenttikerroin miinus1/miinus3 vuotta miinus 1 vuoden kerroin\nveroprosenttikerroin = function(x, y) {\n  return (x/y);\n}\n// Kunnan muok. kunnallisvero, alkuvuosi ja loppuvuosi \nkunnallisvero_muokkaus = function(kunnallisvero,asukaskerroin,veroprosentti) {\n  return kunnallisvero*asukaskerroin*veroprosentti;\n}\n\n//Tekstimuutokset\nfn_nousu_lasku_txt = function(arvo){\n  if(arvo &gt; 0) {\n  return \"kasvanut\" \n  }\n  else { \n  return \"laskenut\";\n  }\n}\n\n//TARVITAAN KARTOISSA\nserialize = {\n  const xmlns = \"http://www.w3.org/2000/xmlns/\";\n  const xlinkns = \"http://www.w3.org/1999/xlink\";\n  const svgns = \"http://www.w3.org/2000/svg\";\n  return function serialize(svg) {\n    svg = svg.cloneNode(true);\n    const fragment = window.location.href + \"#\";\n    const walker = document.createTreeWalker(svg, NodeFilter.SHOW_ELEMENT);\n    while (walker.nextNode()) {\n      for (const attr of walker.currentNode.attributes) {\n        if (attr.value.includes(fragment)) {\n          attr.value = attr.value.replace(fragment, \"#\");\n        }\n      }\n    }\n    svg.setAttributeNS(xmlns, \"xmlns\", svgns);\n    svg.setAttributeNS(xmlns, \"xmlns:xlink\", xlinkns);\n    const serializer = new window.XMLSerializer;\n    const string = serializer.serializeToString(svg);\n    return new Blob([string], {type: \"image/svg+xml\"});\n  };\n}\n\n\nfunction toSVG(chart) {\n  if (chart.nodeName !== \"FIGURE\") {\n    return chart;\n  }\n\n  // the chart needs to be in the body if we want to read values, positions, sizes…\n  document.body.appendChild(chart);\n  const [x0, y0, width, height] = getBounds([chart]);\n\n  const nodes = [];\n\n  for (const node of d3\n    .select(chart)\n    .selectChildren(\"h1,h2,h3,div,figcaption,svg\")) {\n    switch (node.nodeName.toLowerCase()) {\n      case \"div\":\n        {\n          const children = d3.select(node).selectChildren(\"div,span\");\n          const height = getBounds([node, ...children])[3] + 2;\n          const svg = d3\n            .select(chart)\n            .append(\"svg\")\n            .attr(\"width\", width)\n            .attr(\"height\", height);\n          nodes.push(svg.node());\n\n          const swatches = svg\n            .selectAll()\n            .data(\n              Array.from(children, (d) =&gt; {\n                const svg = d3.select(d).select(\"svg\").node();\n                const bbox = svg.getBBox();\n                return {\n                  style: window.getComputedStyle(d),\n                  svg,\n                  width: bbox.width,\n                  height: bbox.height,\n                  text: d.textContent,\n                  bounds: getBounds([d])\n                };\n              })\n            )\n            .join(\"g\")\n            .attr(\n              \"transform\",\n              (d) =&gt; `translate(${d.bounds[0] - x0},${10 + d.bounds[1] - y0})`\n            );\n\n          swatches\n            .append((d) =&gt; d.svg) // \"rect\")\n            .attr(\"width\", (d) =&gt; d.width)\n            .attr(\"height\", (d) =&gt; d.height)\n            .attr(\"y\", (d) =&gt; `${-parseFloat(d.height) / 2}px`);\n          swatches\n            .append(\"text\")\n            .text((d) =&gt; d.text)\n            .attr(\"x\", (d) =&gt; d.width)\n            .attr(\"dx\", 5)\n            .attr(\"dy\", \"0.38em\")\n            .attr(\"font-family\", (d) =&gt; d.style.fontFamily)\n            .attr(\"font-size\", (d) =&gt; d.style.fontSize)\n            .attr(\"fill\", (d) =&gt; d.style.color);\n        }\n        break;\n      case \"figcaption\":\n      case \"h1\":\n      case \"h2\":\n      case \"h3\":\n        {\n          const svg = d3\n            .select(chart)\n            .append(\"svg\")\n            .attr(\"width\", width)\n            .attr(\"overflow\", \"visible\");\n          nodes.push(svg.node());\n\n          const children = d3.select(node).selectChildren();\n\n          let h = 0;\n          for (const d of children.size() &gt; 0\n            ? children.selectChildren()\n            : [node]) {\n            const style = window.getComputedStyle(d);\n            const t = svg\n              .append(\"g\")\n              .attr(\"transform\", `translate(0,${h})`)\n              .append(() =&gt;\n                d3\n                  .select(\n                    Plot.text([d.textContent], {\n                      text: (d) =&gt; d,\n                      lineWidth:\n                        (1.06 * parseFloat(style.width)) /\n                        parseFloat(style.fontSize),\n                      lineHeight: 1.2,\n                      frameAnchor: \"top-left\"\n                    }).plot()\n                  )\n                  .select(\"text\")\n                  .attr(\"font-family\", style.fontFamily)\n                  .attr(\"font-size\", 1.08 * parseFloat(style.fontSize))\n                  .attr(\"font-weight\", style.fontWeight)\n                  .attr(\"fill\", style.color)\n                  .node()\n              );\n            h += getBounds([t.node()])[3] + 4;\n          }\n          svg.attr(\"height\", h);\n        }\n        break;\n      case \"svg\":\n        d3.select(chart).append(() =&gt; node);\n        nodes.push(node);\n        break;\n    }\n  }\n\n  return serializeAll(nodes)\n    .then((blob) =&gt; blob.text())\n    .then((c) =&gt; {\n      document.body.removeChild(chart);\n      return Object.assign(svg`${c}`, chart);\n    });\n}\n\n\n// Given an array of SVG elements, composites them into a single SVG element,\n// and then serializes the result to a blob.\nasync function serializeAll(elements, {padding = 10} = {}) {\n  const fragment = location.href + \"#\";\n  let root;\n  if (elements.length === 1) {\n    root = elements[0].cloneNode(true); // optimize common case\n  } else {\n    const [ox, oy, dx, dy] = getBounds(elements);\n    root = document.createElementNS(svgns, \"svg\");\n    root.setAttribute(\"width\", dx + 2 * padding);\n    root.setAttribute(\"height\", dy + 2 * padding);\n    root.setAttribute(\"viewBox\", [-padding, -padding, dx + 2 * padding, dy + 2 * padding]);\n    for (const element of elements) {\n      const svg = root.appendChild(element.cloneNode(true));\n      const { x, y, width, height } = element.getBoundingClientRect();\n      svg.setAttribute(\"x\", x - ox);\n      svg.setAttribute(\"y\", y - oy);\n      svg.setAttribute(\"width\", width);\n      svg.setAttribute(\"height\", height);\n    }\n  }\n  const walker = document.createTreeWalker(root, NodeFilter.SHOW_ELEMENT);\n  while (walker.nextNode()) {\n    const node = walker.currentNode;\n    for (const attr of node.attributes) {\n      if (attr.value.includes(fragment)) {\n        attr.value = attr.value.replace(fragment, \"#\");\n      }\n    }\n  }\n  root.setAttributeNS(xmlns, \"xmlns\", svgns);\n  root.setAttributeNS(xmlns, \"xmlns:xlink\", xlinkns);\n  const serializer = new XMLSerializer();\n  const string = serializer.serializeToString(root);\n  return new Blob([string], { type: \"image/svg+xml\" });\n}\n\n\nfunction getBounds(elements) {\n  let x1 = Infinity;\n  let y1 = x1;\n  let x2 = -x1;\n  let y2 = x2;\n  for (const element of elements) {\n    const { x, y, width, height } = element.getBoundingClientRect();\n    if (x &lt; x1) x1 = x;\n    if (x + width &gt; x2) x2 = x + width;\n    if (y &lt; y1) y1 = y;\n    if (y + height &gt; y2) y2 = y + height;\n  }\n  return [x1, y1, x2 - x1, y2 - y1];\n}\n\n// based on https://observablehq.com/@gka/cheap-fit-text-to-circle\nfunction lines(text, targetWidth) {\n  const CHAR_W = {\n    \"a\":7,\"B\":8,\"C\":8,\"c\":6,\"D\":9,\"f\":4,\"G\":9,\"H\":9,\"I\":3,\"i\":3,\"J\":5,\"j\":3,\"K\":8,\"k\":6,\n    \"l\":3,\"M\":11,\"m\":11,\"N\":9,\"O\":9,\"P\":8,\"Q\":9,\"R\":8,\"r\":4,\"S\":8,\"s\":6,\"t\":4,\"U\":9,\"v\":6,\n    \"W\":11,\"w\":9,\"x\":6,\"y\":6,\"z\":5,\".\":2,\",\":2,\":\":2,\";\":2\n  };\n  function measureWidth(text) { return  d3.sum(text, char =&gt; CHAR_W[char] || CHAR_W[\"a\"]) * 0.8; };\n\n  const words = text.split(\" \");\n  let line;\n  let lineWidth0 = Infinity;\n  const lines = [];\n  for (let i = 0, n = words.length; i &lt; n; ++i) {\n    let lineText1 = (line ? line.text + \" \" : \"\") + words[i];\n    let lineWidth1 = measureWidth(lineText1);\n    if ((lineWidth0 + lineWidth1) / 2 &lt; targetWidth) {\n      line.width = lineWidth0 = lineWidth1;\n      line.text = lineText1;\n    } else {\n      lineWidth0 = measureWidth(words[i]);\n      line = {width: lineWidth0, text: words[i]};\n      lines.push(line);\n    }\n  }\n  return lines;\n}\n\nxmlns = \"http://www.w3.org/2000/xmlns/\"\n\nxlinkns = \"http://www.w3.org/1999/xlink\"\n\nsvgns = \"http://www.w3.org/2000/svg\"\nfunction Legend(color, {\n  title,\n  tickSize = 6,\n  width = 320, \n  height = 44 + tickSize,\n  marginTop = 18,\n  marginRight = 0,\n  marginBottom = 16 + tickSize,\n  marginLeft = 0,\n  ticks = width / 64,\n  tickFormat,\n  tickValues\n} = {}) {\n\n  function ramp(color, n = 256) {\n    const canvas = document.createElement(\"canvas\");\n    canvas.width = n;\n    canvas.height = 1;\n    const context = canvas.getContext(\"2d\");\n    for (let i = 0; i &lt; n; ++i) {\n      context.fillStyle = color(i / (n - 1));\n      context.fillRect(i, 0, 1, 1);\n    }\n    return canvas;\n  }\n\n  const svg = d3.create(\"svg\")\n      .attr(\"width\", width)\n      .attr(\"height\", height)\n      .attr(\"viewBox\", [0, 0, width, height])\n      .style(\"overflow\", \"visible\")\n      .style(\"display\", \"block\");\n\n  let tickAdjust = g =&gt; g.selectAll(\".tick line\").attr(\"y1\", marginTop + marginBottom - height);\n  let x;\n\n  // Continuous\n  if (color.interpolate) {\n    const n = Math.min(color.domain().length, color.range().length);\n\n    x = color.copy().rangeRound(d3.quantize(d3.interpolate(marginLeft, width - marginRight), n));\n\n    svg.append(\"image\")\n        .attr(\"x\", marginLeft)\n        .attr(\"y\", marginTop)\n        .attr(\"width\", width - marginLeft - marginRight)\n        .attr(\"height\", height - marginTop - marginBottom)\n        .attr(\"preserveAspectRatio\", \"none\")\n        .attr(\"xlink:href\", ramp(color.copy().domain(d3.quantize(d3.interpolate(0, 1), n))).toDataURL());\n  }\n\n  // Sequential\n  else if (color.interpolator) {\n    x = Object.assign(color.copy()\n        .interpolator(d3.interpolateRound(marginLeft, width - marginRight)),\n        {range() { return [marginLeft, width - marginRight]; }});\n\n    svg.append(\"image\")\n        .attr(\"x\", marginLeft)\n        .attr(\"y\", marginTop)\n        .attr(\"width\", width - marginLeft - marginRight)\n        .attr(\"height\", height - marginTop - marginBottom)\n        .attr(\"preserveAspectRatio\", \"none\")\n        .attr(\"xlink:href\", ramp(color.interpolator()).toDataURL());\n\n    // scaleSequentialQuantile doesn’t implement ticks or tickFormat.\n    if (!x.ticks) {\n      if (tickValues === undefined) {\n        const n = Math.round(ticks + 1);\n        tickValues = d3.range(n).map(i =&gt; d3.quantile(color.domain(), i / (n - 1)));\n      }\n      if (typeof tickFormat !== \"function\") {\n        tickFormat = d3.format(tickFormat === undefined ? \",f\" : tickFormat);\n      }\n    }\n  }\n\n  // Threshold\n  else if (color.invertExtent) {\n    const thresholds\n        = color.thresholds ? color.thresholds() // scaleQuantize\n        : color.quantiles ? color.quantiles() // scaleQuantile\n        : color.domain(); // scaleThreshold\n\n    const thresholdFormat\n        = tickFormat === undefined ? d =&gt; d\n        : typeof tickFormat === \"string\" ? d3.format(tickFormat)\n        : tickFormat;\n\n    x = d3.scaleLinear()\n        .domain([-1, color.range().length - 1])\n        .rangeRound([marginLeft, width - marginRight]);\n\n    svg.append(\"g\")\n      .selectAll(\"rect\")\n      .data(color.range())\n      .join(\"rect\")\n        .attr(\"x\", (d, i) =&gt; x(i - 1))\n        .attr(\"y\", marginTop)\n        .attr(\"width\", (d, i) =&gt; x(i) - x(i - 1))\n        .attr(\"height\", height - marginTop - marginBottom)\n        .attr(\"fill\", d =&gt; d);\n\n    tickValues = d3.range(thresholds.length);\n    tickFormat = i =&gt; thresholdFormat(thresholds[i], i);\n  }\n\n  // Ordinal\n  else {\n    x = d3.scaleBand()\n        .domain(color.domain())\n        .rangeRound([marginLeft, width - marginRight]);\n\n    svg.append(\"g\")\n      .selectAll(\"rect\")\n      .data(color.domain())\n      .join(\"rect\")\n        .attr(\"x\", x)\n        .attr(\"y\", marginTop)\n        .attr(\"width\", Math.max(0, x.bandwidth() - 1))\n        .attr(\"height\", height - marginTop - marginBottom)\n        .attr(\"fill\", color);\n\n    tickAdjust = () =&gt; {};\n  }\n\n  svg.append(\"g\")\n      .attr(\"transform\", `translate(0,${height - marginBottom})`)\n      .call(d3.axisBottom(x)\n        .ticks(ticks, typeof tickFormat === \"string\" ? tickFormat : undefined)\n        .tickFormat(typeof tickFormat === \"function\" ? tickFormat : undefined)\n        .tickSize(tickSize)\n        .tickValues(tickValues))\n      .call(tickAdjust)\n      .call(g =&gt; g.select(\".domain\").remove())\n      .call(g =&gt; g.append(\"text\")\n        .attr(\"x\", marginLeft)\n        .attr(\"y\", marginTop + marginBottom - height - 6)\n        .attr(\"fill\", \"currentColor\")\n        .attr(\"text-anchor\", \"start\")\n        .attr(\"font-weight\", \"bold\")\n        .style(\"font-size\", \"12px\")\n        .attr(\"class\", \"title\")\n        .text(title));\n\n  return svg.node();\n}\n\n\nfunction legend({color, ...options}) {\n  return Legend(color, options);\n}\n\n\n// Copyright 2021, Observable Inc.\n// Released under the ISC license.\n// https://observablehq.com/@d3/color-legend\nfunction Swatches(color, {\n  columns = null,\n  format,\n  unknown: formatUnknown,\n  swatchSize = 15,\n  swatchWidth = swatchSize,\n  swatchHeight = swatchSize,\n  marginLeft = 0\n} = {}) {\n  const id = `-swatches-${Math.random().toString(16).slice(2)}`;\n  const unknown = formatUnknown == null ? undefined : color.unknown();\n  const unknowns = unknown == null || unknown === d3.scaleImplicit ? [] : [unknown];\n  const domain = color.domain().concat(unknowns);\n  if (format === undefined) format = x =&gt; x === unknown ? formatUnknown : x;\n\n  function entity(character) {\n    return `&#${character.charCodeAt(0).toString()};`;\n  }\n\n  if (columns !== null) return htl.html`&lt;div style=\"display: flex; align-items: center; margin-left: ${+marginLeft}px; min-height: 33px; font: 12px sans-serif;\"&gt;\n  &lt;style&gt;\n\n.${id}-item {\n  break-inside: avoid;\n  display: flex;\n  align-items: center;\n  padding-bottom: 1px;\n}\n\n.${id}-label {\n  white-space: nowrap;\n  overflow: hidden;\n  text-overflow: ellipsis;\n  max-width: calc(100% - ${+swatchWidth}px - 0.5em);\n}\n\n.${id}-swatch {\n  width: ${+swatchWidth}px;\n  height: ${+swatchHeight}px;\n  margin: 0 0.5em 0 0;\n}\n\n  &lt;/style&gt;\n  &lt;div style=${{width: \"100%\", columns}}&gt;${domain.map(value =&gt; {\n    const label = `${format(value)}`;\n    return htl.html`&lt;div class=${id}-item&gt;\n      &lt;div class=${id}-swatch style=${{background: color(value)}}&gt;&lt;/div&gt;\n      &lt;div class=${id}-label title=${label}&gt;${label}&lt;/div&gt;\n    &lt;/div&gt;`;\n  })}\n  &lt;/div&gt;\n&lt;/div&gt;`;\n\n  return htl.html`&lt;div style=\"display: flex; align-items: center; min-height: 33px; margin-left: ${+marginLeft}px; font: 12px sans-serif;\"&gt;\n  &lt;style&gt;\n\n.${id} {\n  display: inline-flex;\n  align-items: center;\n  margin-right: 1em;\n}\n\n.${id}::before {\n  content: \"\";\n  width: ${+swatchWidth}px;\n  height: ${+swatchHeight}px;\n  margin-right: 0.5em;\n  background: var(--color);\n}\n\n  &lt;/style&gt;\n  &lt;div&gt;${domain.map(value =&gt; htl.html`&lt;span class=\"${id}\" style=\"--color: ${color(value)}\"&gt;${format(value)}&lt;/span&gt;`)}&lt;/div&gt;`;\n}\n\nfunction swatches({color, ...options}) {\n  return Swatches(color, options);\n}\nchart_map_d3 = function(data, mapTopoJSON, color, colorBorder, txtTitle, chart_width, chart_height) {\n\n  const projection = d3.geoMercator()\n  .scale(1200)\n  //.center([40, 67.5])\n  .center([40, 67.3])\n  .translate([400, 220])\n  const path = d3.geoPath().projection(projection);\n  const format = d =&gt; `${d}%`;\n  \n  //Määritellään tähän muuttujat CSV:stä!!!!!!\n  const valuemap = new Map(data.map(d =&gt; [d.id, d.muutos]));\n  \n  //Määritellään maakunnat\n  const maakuntamesh = topojson.mesh(maakunnat_2024_topo, maakunnat_2024_topo.objects.maakunnat_2024, (a, b) =&gt; a !== b);\n  \n  const zoom = d3.zoom()\n      .scaleExtent([1, 8])\n      .on(\"zoom\", zoomed);\n\n  const svg = d3.create(\"svg\")\n      .attr(\"width\", 900)\n      .attr(\"height\", 650)\n      .attr(\"viewBox\", [0, 0, 900, 650])\n      .on(\"click\", reset);\n      \n  const g = svg.append(\"g\")\n      .attr(\"transform\", \"translate(20,35)\")\n      .append(() =&gt; Legend(color, {title: txtTitle, width: 260}));\n\n  g.append(\"g\")\n    .selectAll(\"path\")\n    .data(mapTopoJSON)\n    .join(\"path\")\n      .attr(\"fill\", d =&gt; color(valuemap.get(d.properties.kunta))) \n      .attr(\"d\", path)\n    .append(\"title\")\n      .text(d =&gt; `${d.properties.name},\\n(${d.properties.nimi_2}),\\n${valuemap.get(d.properties.kunta)}`);\n      \n  g.append(\"path\")\n      .datum(maakuntamesh)\n      .attr(\"fill\", \"none\")\n      .attr(\"stroke\", colorBorder)\n      .attr(\"stroke-linejoin\", \"round\")\n      .attr(\"d\", path);\n      \n   svg.call(zoom);\n   \n\n  function reset() {\n    // states.transition().style(\"fill\", null);\n    svg.transition().duration(750).call(\n      zoom.transform,\n      d3.zoomIdentity,\n      d3.zoomTransform(svg.node()).invert([chart_width / 2, chart_height / 2])\n    );\n  }\n\n  function zoomed(event) {\n    const {transform} = event;\n    g.attr(\"transform\", transform);\n    g.attr(\"stroke-width\", 1 / transform.k);\n  }     \n      \n  return svg.node();\n}\nchart_chord_d3 = function(data, title_txt_chord, chart_width, chart_height) {\n\n  var sum_target;\n  var sum_source;\n  let vari;\n  var sum_yht;\n  \n  const margin = ({top: 20, right: 20, bottom: 0, left: 50});\n  const width = 300;\n  const height = width;\n  const innerRadius = Math.min(width, height) * .3 - 40;\n  const outerRadius = innerRadius + 15;\n  \n  \n  const chord = d3.chordDirected()\n    .padAngle(0.5 / innerRadius)\n    .sortSubgroups(d3.ascending)\n    .sortChords(d3.ascending);\n    \n  const ribbon = d3.ribbon()\n    .radius(innerRadius - 1)\n    .padAngle(0.5 / innerRadius);\n    \n  const rename = name =&gt; name.substring(name.indexOf(\".\") + 1, name.lastIndexOf(\".\"))\n  const names = Array.from(new Set(data.flatMap(d =&gt; [d.source, d.target]))).sort(d3.ascending);\n  \n  function matriisi(names) {\n    const index = new Map(names.map((name, i) =&gt; [name, i]));\n    const matrix = Array.from(index, () =&gt; new Array(names.length).fill(0));\n    for (const {source, target, value} of data) matrix[index.get(source)][index.get(target)] += value;\n    return matrix;\n  }\n\n const matrix = matriisi(names)\n  \n const arc = d3.arc()\n    .innerRadius(innerRadius)\n    .outerRadius(outerRadius)\n\n  //TÄSTÄ ALKAA PIIRROS\n  \n  const zoom = d3.zoom()\n      .scaleExtent([1, 8])\n      .on(\"zoom\", zoomed);\n  \n  const svg = d3.create(\"svg\")\n      .attr(\"viewBox\", [-width / 2, -height / 2.5, width, height]);\n\n  const chords = chord(matrix);\n  \n  const group = svg.append(\"g\")\n      .attr(\"font-size\", 3)\n      .attr(\"font-family\", \"Century Gothic\")\n    .selectAll(\"g\")\n    .data(chords.groups)\n    .join(\"g\");\n\n  group.append(\"path\")\n      .attr(\"fill\", d =&gt; {\n           sum_target = d3.sum(chords, c =&gt; (c.target.index === d.index) * c.target.value);\n           sum_source = d3.sum(chords, c =&gt; (c.source.index === d.index) * c.source.value);\n           sum_yht = sum_target-sum_source;\n            if (sum_yht &gt; 0) { \n              vari = \"#009651\"\n              return vari \n            }\n            else if (sum_yht == 0) { \n              vari = \"#28336C\"\n              return vari \n            }\n            else    { \n              vari = \"#DE232F\" \n              return vari \n            }\n        })\n      .attr(\"d\", arc);\n\n  group.append(\"text\")\n      .each(d =&gt; (d.angle = (d.startAngle + d.endAngle) / 2))\n      .attr(\"dy\", \"0.35em\")\n      .attr(\"transform\", d =&gt; `\n        rotate(${(d.angle * 180 / Math.PI - 90)})\n        translate(${outerRadius + 6})\n        ${d.angle &gt; Math.PI ? \"rotate(180)\" : \"\"}\n      `)\n      .attr(\"text-anchor\", d =&gt; d.angle &gt; Math.PI ? \"end\" : null)\n      //.text(d =&gt; names[d.index])\n      .text(d =&gt; (d.index &gt;= 3) ? names[d.index] : \"\")\n      .attr(\"fill\", d =&gt; {\n           sum_target = d3.sum(chords, c =&gt; (c.target.index === d.index) * c.target.value);\n           sum_source = d3.sum(chords, c =&gt; (c.source.index === d.index) * c.source.value);\n           sum_yht = sum_target-sum_source;\n            if (sum_yht &gt; 0) { \n              vari = \"#009651\"\n              return vari\n            }\n            else if (sum_yht == 0) { \n              vari = \"#28336C\"\n              return vari \n            }\n            else    { \n              vari = \"#DE232F\" \n              return vari \n            }\n        });\n\n  group.append(\"title\")\n      .text(d =&gt; `${names[d.index]} \n\n${d3.sum(chords, c =&gt; (c.source.index === d.index) * c.source.value)} lähtee →\n${d3.sum(chords, c =&gt; (c.target.index === d.index) * c.source.value)} tulee ←\n${d3.sum(chords, c =&gt; (c.target.index === d.index) * c.target.value)- d3.sum(chords, c =&gt; (c.source.index === d.index) * c.source.value)} netto =`);  \n\n  svg.append(\"g\")\n      .attr(\"fill-opacity\", 0.75)\n    .selectAll(\"path\")\n    .data(chords)\n    .join(\"path\")\n      .style(\"mix-blend-mode\", \"multiply\")\n          .attr(\"fill\", d =&gt; {\n           sum_target = d3.sum(chords, c =&gt; (c.target.index === d.index) * c.target.value);\n           sum_source = d3.sum(chords, c =&gt; (c.source.index === d.index) * c.source.value);\n           sum_yht = sum_target-sum_source;\n            if (sum_yht &gt; 0) { \n              vari = \"#009651\"\n              return vari \n            }\n            else if (sum_yht == 0) { \n              vari = \"#28336C\"\n              return vari \n            }\n            else    { \n              vari = \"#DE232F\" \n              return vari \n            }\n        })\n      .attr(\"d\", ribbon)\n    .append(\"title\")\n      .text(d =&gt; `${names[d.source.index]} --&gt; ${names[d.target.index]} ${d.source.value}`);\n      \n      \n  svg.call(zoom);\n   \n\n  function reset() {\n    // states.transition().style(\"fill\", null);\n    svg.transition().duration(750).call(\n      zoom.transform,\n      d3.zoomIdentity,\n      d3.zoomTransform(svg.node()).invert([chart_width / 2, chart_height / 2])\n    );\n  }\n\n  function zoomed(event) {\n    const {transform} = event;\n    svg.attr(\"transform\", transform);\n    svg.attr(\"stroke-width\", 1 / transform.k);\n  }    \n\n  return svg.node();\n\n\n}"
  },
  {
    "objectID": "syntyvyys.html#luonnollinen-väestönkasvu",
    "href": "syntyvyys.html#luonnollinen-väestönkasvu",
    "title": "Syntyvyys",
    "section": "Luonnollinen väestönkasvu",
    "text": "Luonnollinen väestönkasvu\n\nLuonnollinen väestönlisäys\n\n\n\n\n\n\nSyntyneiden enemmyys eli luonnollinen väestönlisäys tarkoittaa elävänä syntyneiden ja kuolleiden erotusta.\nLuonnollinen väestönlisäys ajanjaksolla 2024Q1* - 2024Q2* oli yhteensä 0 (2024Q1*: -5). Vuosina 2022 ja 2023 luonnollinen väestönlisäys oli 2022: -11 ja 2023: -19\n\n\n\n\n\n\n\n\nVuosi\nEnnakkotieto\n\n\n\n\n2011\nNA\n\n\n2012\nNA\n\n\n2013\nNA\n\n\n2014\nNA\n\n\n2015\nNA\n\n\n2016\nNA\n\n\n2017\nNA\n\n\n2018\nNA\n\n\n2019\nNA\n\n\n2020\nNA\n\n\n2021\nNA\n\n\n2022\nNA\n\n\n2023\nNA\n\n\n2024Q1*\n-5\n\n\n2024Q2*\n5"
  },
  {
    "objectID": "syntyvyys.html#syntyneet",
    "href": "syntyvyys.html#syntyneet",
    "title": "Syntyvyys",
    "section": "Syntyneet",
    "text": "Syntyneet\n\nSyntyvyys\n\n\n\n\n\n\n\n\nSyntyvyys\nSyntyvyys ajanjaksolla 2024Q1* - 2024Q2* oli yhteensä 18 (lukema 2024Q1* oli 5). Vuosina 2022 ja 2023 syntyvyys oli lukemissa (2022) 37 ja (2023) 29.\n\n\n\n\n\n\n\n\nVuosi\nEnnakkotieto\n\n\n\n\n2011\nNA\n\n\n2012\nNA\n\n\n2013\nNA\n\n\n2014\nNA\n\n\n2015\nNA\n\n\n2016\nNA\n\n\n2017\nNA\n\n\n2018\nNA\n\n\n2019\nNA\n\n\n2020\nNA\n\n\n2021\nNA\n\n\n2022\nNA\n\n\n2023\nNA\n\n\n2024Q1*\n5\n\n\n2024Q2*\n13"
  },
  {
    "objectID": "syntyvyys.html#väestönmuutokset---väestöpyramidi",
    "href": "syntyvyys.html#väestönmuutokset---väestöpyramidi",
    "title": "Syntyvyys",
    "section": "Väestönmuutokset - Väestöpyramidi",
    "text": "Väestönmuutokset - Väestöpyramidi\n\nDOM.download(() =&gt; serialize(pyramid), \"Väestöpyramidi\", \"Save as SVG\")\n\n\n\n\n\n\n\npyramid_pop_data = FileAttachmentDynamic(pyramid_pop_csv).csv({typed: true})\n\ntranslations = ({\n  v1990: \"1990\",\n  v2010: \"2010\",\n  v2024: valitut_kk_tahti\n  })\n\npyramid = toSVG(Plot.plot({\n  width: 600,\n  height: 600,\n  marginTop: 20,\n  marginRight: 20,\n  marginBottom: 30,\n  marginLeft: 40,\n  x: {\n    label: \"← mies · väestö · nainen →\",\n    labelAnchor: \"center\",\n    tickFormat: Math.abs,\n    //domain: [-300, 300]\n  },\n  y: {grid: true},\n  color: {\n    width: 300,\n    domain: [\"v1990\", \"v2010\", \"v2024\"],\n    range: [\"#e41a1c\", \"#377eb8\", \"#4daf4a\"],\n    legend: true,\n    className: 'large-font',\n    tickFormat: (d) =&gt; translations[d]\n  },\n  style: {\n    fontSize: 14\n  },\n  marks: [\n    Plot.lineX(pyramid_pop_data, {\n      x: (d) =&gt; d.population * (d.sex === \"Miehet\" ? -1 : 1),\n      y: \"age\",\n      z: (d) =&gt; [d.sex, d.category].join(\",\"),\n      stroke: \"category\",\n      strokeWidth: 4,\n      fill: \"category\",\n      fillOpacity: 0\n    }),\n    Plot.ruleX([0]),\n    Plot.ruleY([0])\n  ]\n}))"
  },
  {
    "objectID": "vaesto.html",
    "href": "vaesto.html",
    "title": "Väestönmuutokset",
    "section": "",
    "text": "d3 = require(\"d3@7\")\n//import {Legend} from \"@d3/color-legend\"\n\nfolderKunnat24TopoJSON = \"./maps/Kunnat2024Topo.json\"\nkunnat2024topo = FileAttachmentDynamic(folderKunnat24TopoJSON).json()\nmapTopoJSON = topojson.feature(kunnat2024topo, kunnat2024topo.objects.Kunnat2024_geo).features\n\n\nfolderMaakunnat24TopoJSON = \"./maps/Maakunnat2024Topo.json\"\nmaakunnat_2024_topo =  FileAttachmentDynamic(folderMaakunnat24TopoJSON).json()\nFileAttachmentDynamic = function(filename) {\n  return new Function(\"FileAttachment\", `return FileAttachment(\"${filename}\")`)(FileAttachment)\n}\n\n// Vaihdetaan tekstin väri\ncolor = function(vari) {\n  if(vari &gt; 0){\n      return \"green\"\n    }else{\n      return \"red\"\n    }\n}\n// Pyöristys\npyoristys = function(n, places) {\n  if (!places) return Math.round(n);\n  const d = 10 ** places;\n  return Math.round(n * d) / d;\n}\n//Euromerkintä\neurot = function(number) {\n  return number.toLocaleString('fi-FI', { style: 'currency', currency: 'EUR',minimumFractionDigits: 0 });\n}\n// Euromuutoksen laskeminen kertoimella\nmuutoskerroin = function(x, y) {\n  return (1+x/100)*y;\n}\n// Muutosprosentti\nmuutosprosentti = function(x, y) {\n  return pyoristys(((x-y)/y)*100,1);\n}\n// Tuhatjakaja\ntuhatjakaja = function(x) {\n  return x/1000;\n}\n// Euromuutoksen laskeminen kertoimella\npalkkakerroin = function(x, y) {\n  return 100*((1+x/100)*(1+y/100)-1);\n}\n// Jako-osuuden asukaskerroin\nasukaskerroin = function(x, y) {\n  return (x/y);\n}\n// Jako-osuuden veroprosenttikerroin miinus1/miinus3 vuotta miinus 1 vuoden kerroin\nveroprosenttikerroin = function(x, y) {\n  return (x/y);\n}\n// Kunnan muok. kunnallisvero, alkuvuosi ja loppuvuosi \nkunnallisvero_muokkaus = function(kunnallisvero,asukaskerroin,veroprosentti) {\n  return kunnallisvero*asukaskerroin*veroprosentti;\n}\n\n//Tekstimuutokset\nfn_nousu_lasku_txt = function(arvo){\n  if(arvo &gt; 0) {\n  return \"kasvanut\" \n  }\n  else { \n  return \"laskenut\";\n  }\n}\n\n//TARVITAAN KARTOISSA\nserialize = {\n  const xmlns = \"http://www.w3.org/2000/xmlns/\";\n  const xlinkns = \"http://www.w3.org/1999/xlink\";\n  const svgns = \"http://www.w3.org/2000/svg\";\n  return function serialize(svg) {\n    svg = svg.cloneNode(true);\n    const fragment = window.location.href + \"#\";\n    const walker = document.createTreeWalker(svg, NodeFilter.SHOW_ELEMENT);\n    while (walker.nextNode()) {\n      for (const attr of walker.currentNode.attributes) {\n        if (attr.value.includes(fragment)) {\n          attr.value = attr.value.replace(fragment, \"#\");\n        }\n      }\n    }\n    svg.setAttributeNS(xmlns, \"xmlns\", svgns);\n    svg.setAttributeNS(xmlns, \"xmlns:xlink\", xlinkns);\n    const serializer = new window.XMLSerializer;\n    const string = serializer.serializeToString(svg);\n    return new Blob([string], {type: \"image/svg+xml\"});\n  };\n}\n\n\nfunction toSVG(chart) {\n  if (chart.nodeName !== \"FIGURE\") {\n    return chart;\n  }\n\n  // the chart needs to be in the body if we want to read values, positions, sizes…\n  document.body.appendChild(chart);\n  const [x0, y0, width, height] = getBounds([chart]);\n\n  const nodes = [];\n\n  for (const node of d3\n    .select(chart)\n    .selectChildren(\"h1,h2,h3,div,figcaption,svg\")) {\n    switch (node.nodeName.toLowerCase()) {\n      case \"div\":\n        {\n          const children = d3.select(node).selectChildren(\"div,span\");\n          const height = getBounds([node, ...children])[3] + 2;\n          const svg = d3\n            .select(chart)\n            .append(\"svg\")\n            .attr(\"width\", width)\n            .attr(\"height\", height);\n          nodes.push(svg.node());\n\n          const swatches = svg\n            .selectAll()\n            .data(\n              Array.from(children, (d) =&gt; {\n                const svg = d3.select(d).select(\"svg\").node();\n                const bbox = svg.getBBox();\n                return {\n                  style: window.getComputedStyle(d),\n                  svg,\n                  width: bbox.width,\n                  height: bbox.height,\n                  text: d.textContent,\n                  bounds: getBounds([d])\n                };\n              })\n            )\n            .join(\"g\")\n            .attr(\n              \"transform\",\n              (d) =&gt; `translate(${d.bounds[0] - x0},${10 + d.bounds[1] - y0})`\n            );\n\n          swatches\n            .append((d) =&gt; d.svg) // \"rect\")\n            .attr(\"width\", (d) =&gt; d.width)\n            .attr(\"height\", (d) =&gt; d.height)\n            .attr(\"y\", (d) =&gt; `${-parseFloat(d.height) / 2}px`);\n          swatches\n            .append(\"text\")\n            .text((d) =&gt; d.text)\n            .attr(\"x\", (d) =&gt; d.width)\n            .attr(\"dx\", 5)\n            .attr(\"dy\", \"0.38em\")\n            .attr(\"font-family\", (d) =&gt; d.style.fontFamily)\n            .attr(\"font-size\", (d) =&gt; d.style.fontSize)\n            .attr(\"fill\", (d) =&gt; d.style.color);\n        }\n        break;\n      case \"figcaption\":\n      case \"h1\":\n      case \"h2\":\n      case \"h3\":\n        {\n          const svg = d3\n            .select(chart)\n            .append(\"svg\")\n            .attr(\"width\", width)\n            .attr(\"overflow\", \"visible\");\n          nodes.push(svg.node());\n\n          const children = d3.select(node).selectChildren();\n\n          let h = 0;\n          for (const d of children.size() &gt; 0\n            ? children.selectChildren()\n            : [node]) {\n            const style = window.getComputedStyle(d);\n            const t = svg\n              .append(\"g\")\n              .attr(\"transform\", `translate(0,${h})`)\n              .append(() =&gt;\n                d3\n                  .select(\n                    Plot.text([d.textContent], {\n                      text: (d) =&gt; d,\n                      lineWidth:\n                        (1.06 * parseFloat(style.width)) /\n                        parseFloat(style.fontSize),\n                      lineHeight: 1.2,\n                      frameAnchor: \"top-left\"\n                    }).plot()\n                  )\n                  .select(\"text\")\n                  .attr(\"font-family\", style.fontFamily)\n                  .attr(\"font-size\", 1.08 * parseFloat(style.fontSize))\n                  .attr(\"font-weight\", style.fontWeight)\n                  .attr(\"fill\", style.color)\n                  .node()\n              );\n            h += getBounds([t.node()])[3] + 4;\n          }\n          svg.attr(\"height\", h);\n        }\n        break;\n      case \"svg\":\n        d3.select(chart).append(() =&gt; node);\n        nodes.push(node);\n        break;\n    }\n  }\n\n  return serializeAll(nodes)\n    .then((blob) =&gt; blob.text())\n    .then((c) =&gt; {\n      document.body.removeChild(chart);\n      return Object.assign(svg`${c}`, chart);\n    });\n}\n\n\n// Given an array of SVG elements, composites them into a single SVG element,\n// and then serializes the result to a blob.\nasync function serializeAll(elements, {padding = 10} = {}) {\n  const fragment = location.href + \"#\";\n  let root;\n  if (elements.length === 1) {\n    root = elements[0].cloneNode(true); // optimize common case\n  } else {\n    const [ox, oy, dx, dy] = getBounds(elements);\n    root = document.createElementNS(svgns, \"svg\");\n    root.setAttribute(\"width\", dx + 2 * padding);\n    root.setAttribute(\"height\", dy + 2 * padding);\n    root.setAttribute(\"viewBox\", [-padding, -padding, dx + 2 * padding, dy + 2 * padding]);\n    for (const element of elements) {\n      const svg = root.appendChild(element.cloneNode(true));\n      const { x, y, width, height } = element.getBoundingClientRect();\n      svg.setAttribute(\"x\", x - ox);\n      svg.setAttribute(\"y\", y - oy);\n      svg.setAttribute(\"width\", width);\n      svg.setAttribute(\"height\", height);\n    }\n  }\n  const walker = document.createTreeWalker(root, NodeFilter.SHOW_ELEMENT);\n  while (walker.nextNode()) {\n    const node = walker.currentNode;\n    for (const attr of node.attributes) {\n      if (attr.value.includes(fragment)) {\n        attr.value = attr.value.replace(fragment, \"#\");\n      }\n    }\n  }\n  root.setAttributeNS(xmlns, \"xmlns\", svgns);\n  root.setAttributeNS(xmlns, \"xmlns:xlink\", xlinkns);\n  const serializer = new XMLSerializer();\n  const string = serializer.serializeToString(root);\n  return new Blob([string], { type: \"image/svg+xml\" });\n}\n\n\nfunction getBounds(elements) {\n  let x1 = Infinity;\n  let y1 = x1;\n  let x2 = -x1;\n  let y2 = x2;\n  for (const element of elements) {\n    const { x, y, width, height } = element.getBoundingClientRect();\n    if (x &lt; x1) x1 = x;\n    if (x + width &gt; x2) x2 = x + width;\n    if (y &lt; y1) y1 = y;\n    if (y + height &gt; y2) y2 = y + height;\n  }\n  return [x1, y1, x2 - x1, y2 - y1];\n}\n\n// based on https://observablehq.com/@gka/cheap-fit-text-to-circle\nfunction lines(text, targetWidth) {\n  const CHAR_W = {\n    \"a\":7,\"B\":8,\"C\":8,\"c\":6,\"D\":9,\"f\":4,\"G\":9,\"H\":9,\"I\":3,\"i\":3,\"J\":5,\"j\":3,\"K\":8,\"k\":6,\n    \"l\":3,\"M\":11,\"m\":11,\"N\":9,\"O\":9,\"P\":8,\"Q\":9,\"R\":8,\"r\":4,\"S\":8,\"s\":6,\"t\":4,\"U\":9,\"v\":6,\n    \"W\":11,\"w\":9,\"x\":6,\"y\":6,\"z\":5,\".\":2,\",\":2,\":\":2,\";\":2\n  };\n  function measureWidth(text) { return  d3.sum(text, char =&gt; CHAR_W[char] || CHAR_W[\"a\"]) * 0.8; };\n\n  const words = text.split(\" \");\n  let line;\n  let lineWidth0 = Infinity;\n  const lines = [];\n  for (let i = 0, n = words.length; i &lt; n; ++i) {\n    let lineText1 = (line ? line.text + \" \" : \"\") + words[i];\n    let lineWidth1 = measureWidth(lineText1);\n    if ((lineWidth0 + lineWidth1) / 2 &lt; targetWidth) {\n      line.width = lineWidth0 = lineWidth1;\n      line.text = lineText1;\n    } else {\n      lineWidth0 = measureWidth(words[i]);\n      line = {width: lineWidth0, text: words[i]};\n      lines.push(line);\n    }\n  }\n  return lines;\n}\n\nxmlns = \"http://www.w3.org/2000/xmlns/\"\n\nxlinkns = \"http://www.w3.org/1999/xlink\"\n\nsvgns = \"http://www.w3.org/2000/svg\"\nfunction Legend(color, {\n  title,\n  tickSize = 6,\n  width = 320, \n  height = 44 + tickSize,\n  marginTop = 18,\n  marginRight = 0,\n  marginBottom = 16 + tickSize,\n  marginLeft = 0,\n  ticks = width / 64,\n  tickFormat,\n  tickValues\n} = {}) {\n\n  function ramp(color, n = 256) {\n    const canvas = document.createElement(\"canvas\");\n    canvas.width = n;\n    canvas.height = 1;\n    const context = canvas.getContext(\"2d\");\n    for (let i = 0; i &lt; n; ++i) {\n      context.fillStyle = color(i / (n - 1));\n      context.fillRect(i, 0, 1, 1);\n    }\n    return canvas;\n  }\n\n  const svg = d3.create(\"svg\")\n      .attr(\"width\", width)\n      .attr(\"height\", height)\n      .attr(\"viewBox\", [0, 0, width, height])\n      .style(\"overflow\", \"visible\")\n      .style(\"display\", \"block\");\n\n  let tickAdjust = g =&gt; g.selectAll(\".tick line\").attr(\"y1\", marginTop + marginBottom - height);\n  let x;\n\n  // Continuous\n  if (color.interpolate) {\n    const n = Math.min(color.domain().length, color.range().length);\n\n    x = color.copy().rangeRound(d3.quantize(d3.interpolate(marginLeft, width - marginRight), n));\n\n    svg.append(\"image\")\n        .attr(\"x\", marginLeft)\n        .attr(\"y\", marginTop)\n        .attr(\"width\", width - marginLeft - marginRight)\n        .attr(\"height\", height - marginTop - marginBottom)\n        .attr(\"preserveAspectRatio\", \"none\")\n        .attr(\"xlink:href\", ramp(color.copy().domain(d3.quantize(d3.interpolate(0, 1), n))).toDataURL());\n  }\n\n  // Sequential\n  else if (color.interpolator) {\n    x = Object.assign(color.copy()\n        .interpolator(d3.interpolateRound(marginLeft, width - marginRight)),\n        {range() { return [marginLeft, width - marginRight]; }});\n\n    svg.append(\"image\")\n        .attr(\"x\", marginLeft)\n        .attr(\"y\", marginTop)\n        .attr(\"width\", width - marginLeft - marginRight)\n        .attr(\"height\", height - marginTop - marginBottom)\n        .attr(\"preserveAspectRatio\", \"none\")\n        .attr(\"xlink:href\", ramp(color.interpolator()).toDataURL());\n\n    // scaleSequentialQuantile doesn’t implement ticks or tickFormat.\n    if (!x.ticks) {\n      if (tickValues === undefined) {\n        const n = Math.round(ticks + 1);\n        tickValues = d3.range(n).map(i =&gt; d3.quantile(color.domain(), i / (n - 1)));\n      }\n      if (typeof tickFormat !== \"function\") {\n        tickFormat = d3.format(tickFormat === undefined ? \",f\" : tickFormat);\n      }\n    }\n  }\n\n  // Threshold\n  else if (color.invertExtent) {\n    const thresholds\n        = color.thresholds ? color.thresholds() // scaleQuantize\n        : color.quantiles ? color.quantiles() // scaleQuantile\n        : color.domain(); // scaleThreshold\n\n    const thresholdFormat\n        = tickFormat === undefined ? d =&gt; d\n        : typeof tickFormat === \"string\" ? d3.format(tickFormat)\n        : tickFormat;\n\n    x = d3.scaleLinear()\n        .domain([-1, color.range().length - 1])\n        .rangeRound([marginLeft, width - marginRight]);\n\n    svg.append(\"g\")\n      .selectAll(\"rect\")\n      .data(color.range())\n      .join(\"rect\")\n        .attr(\"x\", (d, i) =&gt; x(i - 1))\n        .attr(\"y\", marginTop)\n        .attr(\"width\", (d, i) =&gt; x(i) - x(i - 1))\n        .attr(\"height\", height - marginTop - marginBottom)\n        .attr(\"fill\", d =&gt; d);\n\n    tickValues = d3.range(thresholds.length);\n    tickFormat = i =&gt; thresholdFormat(thresholds[i], i);\n  }\n\n  // Ordinal\n  else {\n    x = d3.scaleBand()\n        .domain(color.domain())\n        .rangeRound([marginLeft, width - marginRight]);\n\n    svg.append(\"g\")\n      .selectAll(\"rect\")\n      .data(color.domain())\n      .join(\"rect\")\n        .attr(\"x\", x)\n        .attr(\"y\", marginTop)\n        .attr(\"width\", Math.max(0, x.bandwidth() - 1))\n        .attr(\"height\", height - marginTop - marginBottom)\n        .attr(\"fill\", color);\n\n    tickAdjust = () =&gt; {};\n  }\n\n  svg.append(\"g\")\n      .attr(\"transform\", `translate(0,${height - marginBottom})`)\n      .call(d3.axisBottom(x)\n        .ticks(ticks, typeof tickFormat === \"string\" ? tickFormat : undefined)\n        .tickFormat(typeof tickFormat === \"function\" ? tickFormat : undefined)\n        .tickSize(tickSize)\n        .tickValues(tickValues))\n      .call(tickAdjust)\n      .call(g =&gt; g.select(\".domain\").remove())\n      .call(g =&gt; g.append(\"text\")\n        .attr(\"x\", marginLeft)\n        .attr(\"y\", marginTop + marginBottom - height - 6)\n        .attr(\"fill\", \"currentColor\")\n        .attr(\"text-anchor\", \"start\")\n        .attr(\"font-weight\", \"bold\")\n        .style(\"font-size\", \"12px\")\n        .attr(\"class\", \"title\")\n        .text(title));\n\n  return svg.node();\n}\n\n\nfunction legend({color, ...options}) {\n  return Legend(color, options);\n}\n\n\n// Copyright 2021, Observable Inc.\n// Released under the ISC license.\n// https://observablehq.com/@d3/color-legend\nfunction Swatches(color, {\n  columns = null,\n  format,\n  unknown: formatUnknown,\n  swatchSize = 15,\n  swatchWidth = swatchSize,\n  swatchHeight = swatchSize,\n  marginLeft = 0\n} = {}) {\n  const id = `-swatches-${Math.random().toString(16).slice(2)}`;\n  const unknown = formatUnknown == null ? undefined : color.unknown();\n  const unknowns = unknown == null || unknown === d3.scaleImplicit ? [] : [unknown];\n  const domain = color.domain().concat(unknowns);\n  if (format === undefined) format = x =&gt; x === unknown ? formatUnknown : x;\n\n  function entity(character) {\n    return `&#${character.charCodeAt(0).toString()};`;\n  }\n\n  if (columns !== null) return htl.html`&lt;div style=\"display: flex; align-items: center; margin-left: ${+marginLeft}px; min-height: 33px; font: 12px sans-serif;\"&gt;\n  &lt;style&gt;\n\n.${id}-item {\n  break-inside: avoid;\n  display: flex;\n  align-items: center;\n  padding-bottom: 1px;\n}\n\n.${id}-label {\n  white-space: nowrap;\n  overflow: hidden;\n  text-overflow: ellipsis;\n  max-width: calc(100% - ${+swatchWidth}px - 0.5em);\n}\n\n.${id}-swatch {\n  width: ${+swatchWidth}px;\n  height: ${+swatchHeight}px;\n  margin: 0 0.5em 0 0;\n}\n\n  &lt;/style&gt;\n  &lt;div style=${{width: \"100%\", columns}}&gt;${domain.map(value =&gt; {\n    const label = `${format(value)}`;\n    return htl.html`&lt;div class=${id}-item&gt;\n      &lt;div class=${id}-swatch style=${{background: color(value)}}&gt;&lt;/div&gt;\n      &lt;div class=${id}-label title=${label}&gt;${label}&lt;/div&gt;\n    &lt;/div&gt;`;\n  })}\n  &lt;/div&gt;\n&lt;/div&gt;`;\n\n  return htl.html`&lt;div style=\"display: flex; align-items: center; min-height: 33px; margin-left: ${+marginLeft}px; font: 12px sans-serif;\"&gt;\n  &lt;style&gt;\n\n.${id} {\n  display: inline-flex;\n  align-items: center;\n  margin-right: 1em;\n}\n\n.${id}::before {\n  content: \"\";\n  width: ${+swatchWidth}px;\n  height: ${+swatchHeight}px;\n  margin-right: 0.5em;\n  background: var(--color);\n}\n\n  &lt;/style&gt;\n  &lt;div&gt;${domain.map(value =&gt; htl.html`&lt;span class=\"${id}\" style=\"--color: ${color(value)}\"&gt;${format(value)}&lt;/span&gt;`)}&lt;/div&gt;`;\n}\n\nfunction swatches({color, ...options}) {\n  return Swatches(color, options);\n}\nchart_map_d3 = function(data, mapTopoJSON, color, colorBorder, txtTitle, chart_width, chart_height) {\n\n  const projection = d3.geoMercator()\n  .scale(1200)\n  //.center([40, 67.5])\n  .center([40, 67.3])\n  .translate([400, 220])\n  const path = d3.geoPath().projection(projection);\n  const format = d =&gt; `${d}%`;\n  \n  //Määritellään tähän muuttujat CSV:stä!!!!!!\n  const valuemap = new Map(data.map(d =&gt; [d.id, d.muutos]));\n  \n  //Määritellään maakunnat\n  const maakuntamesh = topojson.mesh(maakunnat_2024_topo, maakunnat_2024_topo.objects.maakunnat_2024, (a, b) =&gt; a !== b);\n  \n  const zoom = d3.zoom()\n      .scaleExtent([1, 8])\n      .on(\"zoom\", zoomed);\n\n  const svg = d3.create(\"svg\")\n      .attr(\"width\", 900)\n      .attr(\"height\", 650)\n      .attr(\"viewBox\", [0, 0, 900, 650])\n      .on(\"click\", reset);\n      \n  const g = svg.append(\"g\")\n      .attr(\"transform\", \"translate(20,35)\")\n      .append(() =&gt; Legend(color, {title: txtTitle, width: 260}));\n\n  g.append(\"g\")\n    .selectAll(\"path\")\n    .data(mapTopoJSON)\n    .join(\"path\")\n      .attr(\"fill\", d =&gt; color(valuemap.get(d.properties.kunta))) \n      .attr(\"d\", path)\n    .append(\"title\")\n      .text(d =&gt; `${d.properties.name},\\n(${d.properties.nimi_2}),\\n${valuemap.get(d.properties.kunta)}`);\n      \n  g.append(\"path\")\n      .datum(maakuntamesh)\n      .attr(\"fill\", \"none\")\n      .attr(\"stroke\", colorBorder)\n      .attr(\"stroke-linejoin\", \"round\")\n      .attr(\"d\", path);\n      \n   svg.call(zoom);\n   \n\n  function reset() {\n    // states.transition().style(\"fill\", null);\n    svg.transition().duration(750).call(\n      zoom.transform,\n      d3.zoomIdentity,\n      d3.zoomTransform(svg.node()).invert([chart_width / 2, chart_height / 2])\n    );\n  }\n\n  function zoomed(event) {\n    const {transform} = event;\n    g.attr(\"transform\", transform);\n    g.attr(\"stroke-width\", 1 / transform.k);\n  }     \n      \n  return svg.node();\n}\nchart_chord_d3 = function(data, title_txt_chord, chart_width, chart_height) {\n\n  var sum_target;\n  var sum_source;\n  let vari;\n  var sum_yht;\n  \n  const margin = ({top: 20, right: 20, bottom: 0, left: 50});\n  const width = 300;\n  const height = width;\n  const innerRadius = Math.min(width, height) * .3 - 40;\n  const outerRadius = innerRadius + 15;\n  \n  \n  const chord = d3.chordDirected()\n    .padAngle(0.5 / innerRadius)\n    .sortSubgroups(d3.ascending)\n    .sortChords(d3.ascending);\n    \n  const ribbon = d3.ribbon()\n    .radius(innerRadius - 1)\n    .padAngle(0.5 / innerRadius);\n    \n  const rename = name =&gt; name.substring(name.indexOf(\".\") + 1, name.lastIndexOf(\".\"))\n  const names = Array.from(new Set(data.flatMap(d =&gt; [d.source, d.target]))).sort(d3.ascending);\n  \n  function matriisi(names) {\n    const index = new Map(names.map((name, i) =&gt; [name, i]));\n    const matrix = Array.from(index, () =&gt; new Array(names.length).fill(0));\n    for (const {source, target, value} of data) matrix[index.get(source)][index.get(target)] += value;\n    return matrix;\n  }\n\n const matrix = matriisi(names)\n  \n const arc = d3.arc()\n    .innerRadius(innerRadius)\n    .outerRadius(outerRadius)\n\n  //TÄSTÄ ALKAA PIIRROS\n  \n  const zoom = d3.zoom()\n      .scaleExtent([1, 8])\n      .on(\"zoom\", zoomed);\n  \n  const svg = d3.create(\"svg\")\n      .attr(\"viewBox\", [-width / 2, -height / 2.5, width, height]);\n\n  const chords = chord(matrix);\n  \n  const group = svg.append(\"g\")\n      .attr(\"font-size\", 3)\n      .attr(\"font-family\", \"Century Gothic\")\n    .selectAll(\"g\")\n    .data(chords.groups)\n    .join(\"g\");\n\n  group.append(\"path\")\n      .attr(\"fill\", d =&gt; {\n           sum_target = d3.sum(chords, c =&gt; (c.target.index === d.index) * c.target.value);\n           sum_source = d3.sum(chords, c =&gt; (c.source.index === d.index) * c.source.value);\n           sum_yht = sum_target-sum_source;\n            if (sum_yht &gt; 0) { \n              vari = \"#009651\"\n              return vari \n            }\n            else if (sum_yht == 0) { \n              vari = \"#28336C\"\n              return vari \n            }\n            else    { \n              vari = \"#DE232F\" \n              return vari \n            }\n        })\n      .attr(\"d\", arc);\n\n  group.append(\"text\")\n      .each(d =&gt; (d.angle = (d.startAngle + d.endAngle) / 2))\n      .attr(\"dy\", \"0.35em\")\n      .attr(\"transform\", d =&gt; `\n        rotate(${(d.angle * 180 / Math.PI - 90)})\n        translate(${outerRadius + 6})\n        ${d.angle &gt; Math.PI ? \"rotate(180)\" : \"\"}\n      `)\n      .attr(\"text-anchor\", d =&gt; d.angle &gt; Math.PI ? \"end\" : null)\n      //.text(d =&gt; names[d.index])\n      .text(d =&gt; (d.index &gt;= 3) ? names[d.index] : \"\")\n      .attr(\"fill\", d =&gt; {\n           sum_target = d3.sum(chords, c =&gt; (c.target.index === d.index) * c.target.value);\n           sum_source = d3.sum(chords, c =&gt; (c.source.index === d.index) * c.source.value);\n           sum_yht = sum_target-sum_source;\n            if (sum_yht &gt; 0) { \n              vari = \"#009651\"\n              return vari\n            }\n            else if (sum_yht == 0) { \n              vari = \"#28336C\"\n              return vari \n            }\n            else    { \n              vari = \"#DE232F\" \n              return vari \n            }\n        });\n\n  group.append(\"title\")\n      .text(d =&gt; `${names[d.index]} \n\n${d3.sum(chords, c =&gt; (c.source.index === d.index) * c.source.value)} lähtee →\n${d3.sum(chords, c =&gt; (c.target.index === d.index) * c.source.value)} tulee ←\n${d3.sum(chords, c =&gt; (c.target.index === d.index) * c.target.value)- d3.sum(chords, c =&gt; (c.source.index === d.index) * c.source.value)} netto =`);  \n\n  svg.append(\"g\")\n      .attr(\"fill-opacity\", 0.75)\n    .selectAll(\"path\")\n    .data(chords)\n    .join(\"path\")\n      .style(\"mix-blend-mode\", \"multiply\")\n          .attr(\"fill\", d =&gt; {\n           sum_target = d3.sum(chords, c =&gt; (c.target.index === d.index) * c.target.value);\n           sum_source = d3.sum(chords, c =&gt; (c.source.index === d.index) * c.source.value);\n           sum_yht = sum_target-sum_source;\n            if (sum_yht &gt; 0) { \n              vari = \"#009651\"\n              return vari \n            }\n            else if (sum_yht == 0) { \n              vari = \"#28336C\"\n              return vari \n            }\n            else    { \n              vari = \"#DE232F\" \n              return vari \n            }\n        })\n      .attr(\"d\", ribbon)\n    .append(\"title\")\n      .text(d =&gt; `${names[d.source.index]} --&gt; ${names[d.target.index]} ${d.source.value}`);\n      \n      \n  svg.call(zoom);\n   \n\n  function reset() {\n    // states.transition().style(\"fill\", null);\n    svg.transition().duration(750).call(\n      zoom.transform,\n      d3.zoomIdentity,\n      d3.zoomTransform(svg.node()).invert([chart_width / 2, chart_height / 2])\n    );\n  }\n\n  function zoomed(event) {\n    const {transform} = event;\n    svg.attr(\"transform\", transform);\n    svg.attr(\"stroke-width\", 1 / transform.k);\n  }    \n\n  return svg.node();\n\n\n}"
  },
  {
    "objectID": "vaesto.html#kuntien-välinen-nettomuutto---viimeiset-12kk",
    "href": "vaesto.html#kuntien-välinen-nettomuutto---viimeiset-12kk",
    "title": "Väestönmuutokset",
    "section": "Kuntien välinen nettomuutto - viimeiset 12kk",
    "text": "Kuntien välinen nettomuutto - viimeiset 12kk\nVoit tarkistella karttaa tarkemmin pyörittämällä hiiren rullanäppäintä.\n\ndata_migr = (await FileAttachmentDynamic(migrBetwMuniMapCSV).csv()).map((d) =&gt; (d.muutos = +d.muutos, d))\n\n//Väritetään kartta\nmapInterpolateRdBu_migr = d3.scaleDiverging([-150, 0, 150], d3.interpolatePiYG);\n\nborderColorDark_migr = \"#525252\";\n\n//Piirretään kartta\nchart_map_d3(data_migr, mapTopoJSON, mapInterpolateRdBu_migr, borderColorDark_migr, title_txt_map_migr,chart_width_migr,chart_height_migr)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nDOM.download(() =&gt; serialize(chart_map_d3(data_migr, mapTopoJSON, mapInterpolateRdBu_migr, borderColorDark_migr, title_txt_map_migr,chart_width_migr,chart_height_migr)), title_txt_map_migr, \"Save as SVG\")\n\n\n\n\n\n\n\n\n\nKuntien välinen nettomuutto - viimeiset 12kk\n\n\n\n\n\n\n\n\nSija\nMaakunta\nKunta\nKuntien välinen nettomuutto\n\n\n\n\n1\nUusimaa\nHelsinki\n3013\n\n\n2\nPirkanmaa\nTampere\n2802\n\n\n3\nUusimaa\nEspoo\n1956\n\n\n4\nVarsinais-Suomi\nTurku\n1670\n\n\n5\nUusimaa\nTuusula\n898\n\n\n6\nPirkanmaa\nKangasala\n459\n\n\n7\nPirkanmaa\nNokia\n448\n\n\n8\nPohjois-Savo\nKuopio\n358\n\n\n9\nPohjois-Pohjanmaa\nOulu\n231\n\n\n10\nPirkanmaa\nPirkkala\n222\n\n\n11\nUusimaa\nSipoo\n189\n\n\n12\nVarsinais-Suomi\nKaarina\n159\n\n\n13\nUusimaa\nKirkkonummi\n136\n\n\n14\nVarsinais-Suomi\nNaantali\n115\n\n\n15\nEtelä-Pohjanmaa\nSeinäjoki\n106\n\n\n16\nUusimaa\nLohja\n103\n\n\n17\nPäijät-Häme\nHeinola\n78\n\n\n18\nVarsinais-Suomi\nLieto\n78\n\n\n19\nKeski-Suomi\nMuurame\n71\n\n\n20\nSatakunta\nPori\n66\n\n\n21\nAhvenanmaa\nJomala\n58\n\n\n22\nLappi\nInari\n55\n\n\n23\nKeski-Suomi\nJyväskylä\n47\n\n\n24\nUusimaa\nHyvinkää\n42\n\n\n25\nPirkanmaa\nLempäälä\n42\n\n\n26\nLappi\nSodankylä\n41\n\n\n27\nPirkanmaa\nHämeenkyrö\n40\n\n\n28\nPohjois-Pohjanmaa\nIi\n38\n\n\n29\nUusimaa\nHanko\n35\n\n\n30\nPirkanmaa\nAkaa\n33\n\n\n31\nEtelä-Savo\nPuumala\n31\n\n\n32\nPohjois-Karjala\nLiperi\n27\n\n\n33\nPäijät-Häme\nIitti\n26\n\n\n34\nPirkanmaa\nOrivesi\n26\n\n\n35\nPohjois-Pohjanmaa\nKempele\n25\n\n\n36\nEtelä-Savo\nSulkava\n24\n\n\n37\nVarsinais-Suomi\nAura\n21\n\n\n38\nAhvenanmaa\nFinström\n21\n\n\n39\nPäijät-Häme\nSysmä\n21\n\n\n40\nPohjois-Savo\nVesanto\n20\n\n\n41\nPohjois-Karjala\nIlomantsi\n19\n\n\n42\nPohjois-Savo\nTuusniemi\n19\n\n\n43\nEtelä-Savo\nHirvensalmi\n18\n\n\n44\nPohjois-Savo\nTervo\n17\n\n\n45\nKeski-Suomi\nLuhanka\n16\n\n\n46\nKeski-Suomi\nUurainen\n16\n\n\n47\nUusimaa\nKerava\n15\n\n\n48\nKeski-Pohjanmaa\nVeteli\n15\n\n\n49\nPirkanmaa\nVesilahti\n14\n\n\n50\nLappi\nKittilä\n13\n\n\n\n\n\n\n\n\n\nKuntien välinen nettomuutto - viimeiset 12kk, top20\nNousiainen on sijalla 198, tarkasteltaessa kuntien välistä nettomuuttoa viimeisen 12kk aikana. Kuntien välinen nettomuuttolukema on -37. Maakuntavertailussa (Varsinais-Suomi) Nousiainen on sijalla 18."
  },
  {
    "objectID": "vaesto.html#väestönmuutokset---väestöennakko",
    "href": "vaesto.html#väestönmuutokset---väestöennakko",
    "title": "Väestönmuutokset",
    "section": "Väestönmuutokset - Väestöennakko",
    "text": "Väestönmuutokset - Väestöennakko\n\n\n\n\n\n\n\nEnnakkotiedot\nEnnakkotietojen (2024M08) perusteella väkiluku on laskenut -0.36 % (2024M07: -0.09 %). Uusin väestön ennakkotieto on 4664 (edell. lukema 4681). Vuoden alusta (2023: 4695) väkiluku on laskenut -0.66 %.\n\n\n\n\n\n\n\n\nVuosi\nEnnakkotieto\n\n\n\n\n2017\nNA\n\n\n2018\nNA\n\n\n2019\nNA\n\n\n2020\nNA\n\n\n2021\nNA\n\n\n2022\nNA\n\n\n2023\nNA\n\n\n2024M01*\n4680\n\n\n2024M02*\n4676\n\n\n2024M03*\n4683\n\n\n2024M04*\n4681\n\n\n2024M05*\n4679\n\n\n2024M06*\n4685\n\n\n2024M07*\n4681\n\n\n2024M08*\n4664"
  },
  {
    "objectID": "vaesto.html#väkiluvun-muutos--vuoden-2023-lopusta",
    "href": "vaesto.html#väkiluvun-muutos--vuoden-2023-lopusta",
    "title": "Väestönmuutokset",
    "section": "Väkiluvun muutos-% vuoden 2023 lopusta",
    "text": "Väkiluvun muutos-% vuoden 2023 lopusta\nVoit tarkistella kartaa lähemmin pyörittämällä hiiren rullanäppäintä.\n\ndata = (await FileAttachmentDynamic(populationMapCSV).csv()).map((d) =&gt; (d.muutos = +d.muutos, d))\n\n//Väritetään kartta\n//mapInterpolateRdBu = d3.scaleDiverging([domain_min, 0, domain_max], d3.interpolateRdBu);\nmapInterpolateRdBu = d3.scaleDiverging([-1.5, 0, 1.5], d3.interpolatePiYG);\n\nborderColorDark = \"#525252\";\n\n//Piirretään kartta\nchart_map_d3(data, mapTopoJSON, mapInterpolateRdBu, borderColorDark, title_txt_map,chart_width,chart_height)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nDOM.download(() =&gt; serialize(chart_map_d3(data, mapTopoJSON, mapInterpolateRdBu, borderColorDark, title_txt_map,chart_width,chart_height)), title_txt_map, \"Save as SVG\")"
  },
  {
    "objectID": "vaesto.html#väkiluvun-muutos--edellisvuoden-lopusta",
    "href": "vaesto.html#väkiluvun-muutos--edellisvuoden-lopusta",
    "title": "Väestönmuutokset",
    "section": "Väkiluvun muutos-% edellisvuoden lopusta",
    "text": "Väkiluvun muutos-% edellisvuoden lopusta\n\n\n\n\n\n\n\n\nSija\nMaakunta\nKunta\nVäestö 31.12.\n2024M08*\nMuutos-%\n\n\n\n\n1\nPohjanmaa\nKaskinen\n1208\n1238\n2.48\n\n\n2\nAhvenanmaa\nSund\n995\n1017\n2.21\n\n\n3\nAhvenanmaa\nBrändö\n436\n444\n1.83\n\n\n4\nUusimaa\nTuusula\n41338\n42000\n1.60\n\n\n5\nPirkanmaa\nTampere\n255050\n258770\n1.46\n\n\n6\nUusimaa\nEspoo\n314024\n318507\n1.43\n\n\n7\nAhvenanmaa\nEckerö\n942\n955\n1.38\n\n\n8\nVarsinais-Suomi\nTurku\n201863\n204618\n1.36\n\n\n9\nAhvenanmaa\nLumparland\n366\n370\n1.09\n\n\n10\nUusimaa\nHelsinki\n674500\n681802\n1.08\n\n\n11\nUusimaa\nSipoo\n22595\n22840\n1.08\n\n\n12\nPirkanmaa\nNokia\n35647\n36030\n1.07\n\n\n13\nUusimaa\nVantaa\n247443\n250073\n1.06\n\n\n14\nAhvenanmaa\nJomala\n5697\n5757\n1.05\n\n\n15\nPirkanmaa\nKangasala\n33473\n33819\n1.03\n\n\n16\nVarsinais-Suomi\nVehmaa\n2245\n2268\n1.02\n\n\n17\nPohjois-Pohjanmaa\nPyhäntä\n1646\n1660\n0.85\n\n\n18\nPohjanmaa\nVaasa\n68956\n69542\n0.85\n\n\n19\nUusimaa\nKirkkonummi\n41154\n41498\n0.84\n\n\n20\nPirkanmaa\nPirkkala\n20763\n20938\n0.84\n\n\n21\nEtelä-Savo\nPieksämäki\n17050\n17192\n0.83\n\n\n22\nAhvenanmaa\nGeta\n509\n513\n0.79\n\n\n23\nPohjanmaa\nLuoto\n5843\n5889\n0.79\n\n\n24\nKeski-Suomi\nJoutsa\n4079\n4110\n0.76\n\n\n25\nVarsinais-Suomi\nRaisio\n25331\n25519\n0.74\n\n\n26\nUusimaa\nJärvenpää\n46490\n46804\n0.68\n\n\n27\nPohjois-Savo\nKuopio\n124021\n124825\n0.65\n\n\n28\nUusimaa\nPorvoo\n51289\n51621\n0.65\n\n\n29\nSatakunta\nKankaanpää\n12394\n12473\n0.64\n\n\n30\nKeski-Suomi\nUurainen\n3615\n3638\n0.64\n\n\n31\nAhvenanmaa\nLemland\n2127\n2140\n0.61\n\n\n32\nKeski-Suomi\nJyväskylä\n147746\n148622\n0.59\n\n\n33\nEtelä-Savo\nSulkava\n2368\n2382\n0.59\n\n\n34\nAhvenanmaa\nFinström\n2610\n2624\n0.54\n\n\n35\nKanta-Häme\nRiihimäki\n28483\n28638\n0.54\n\n\n36\nVarsinais-Suomi\nKaarina\n36339\n36531\n0.53\n\n\n37\nAhvenanmaa\nMaarianhamina - Mariehamn\n11812\n11875\n0.53\n\n\n38\nUusimaa\nHanko\n7721\n7761\n0.52\n\n\n39\nLappi\nEnontekiö\n1771\n1780\n0.51\n\n\n40\nPirkanmaa\nLempäälä\n24711\n24838\n0.51\n\n\n41\nVarsinais-Suomi\nSomero\n8410\n8450\n0.48\n\n\n42\nEtelä-Pohjanmaa\nSeinäjoki\n66160\n66474\n0.47\n\n\n43\nPirkanmaa\nValkeakoski\n20694\n20788\n0.45\n\n\n44\nPirkanmaa\nVesilahti\n4469\n4489\n0.45\n\n\n45\nPohjois-Pohjanmaa\nIi\n9766\n9807\n0.42\n\n\n46\nPäijät-Häme\nLahti\n120693\n121202\n0.42\n\n\n47\nPohjois-Pohjanmaa\nOulu\n214633\n215530\n0.42\n\n\n48\nUusimaa\nInkoo\n5379\n5401\n0.41\n\n\n49\nVarsinais-Suomi\nNaantali\n19999\n20081\n0.41\n\n\n50\nVarsinais-Suomi\nLaitila\n8441\n8475\n0.40\n\n\n\n\n\n\n\n\nVäkiluvun muutos-% edellisvuoden lopusta\nNousiainen on sijalla 204, tarkasteltaessa väkiluvun muutosta edellisvuoden lopusta kuntien kesken. Viimeisin ennakkotietolukema on 4664 (muutos-% edellisen vuoden loppuun: -0.66). Maakuntavertailussa (Varsinais-Suomi) Nousiainen on sijalla 25."
  },
  {
    "objectID": "vaesto.html#väestönmuutokset---väestöennakko-viisi-ikäluokkaa",
    "href": "vaesto.html#väestönmuutokset---väestöennakko-viisi-ikäluokkaa",
    "title": "Väestönmuutokset",
    "section": "Väestönmuutokset - Väestöennakko, viisi ikäluokkaa",
    "text": "Väestönmuutokset - Väestöennakko, viisi ikäluokkaa\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nVuosi\nYhteensä\n0-6\n0-6 %\n7-15\n7-15 %\n16-64\n16-64 %\n65-79\n65-79 %\n80+\n80+ %\n\n\n\n\n2000\n4189\n406\n9.69\n573\n13.68\n2640\n63.02\n455\n10.86\n115\n2.75\n\n\n2001\n4203\n396\n9.42\n564\n13.42\n2669\n63.50\n452\n10.75\n122\n2.90\n\n\n2002\n4269\n387\n9.07\n589\n13.80\n2721\n63.74\n446\n10.45\n126\n2.95\n\n\n2003\n4333\n402\n9.28\n610\n14.08\n2730\n63.00\n452\n10.43\n139\n3.21\n\n\n2004\n4425\n409\n9.24\n640\n14.46\n2770\n62.60\n458\n10.35\n148\n3.34\n\n\n2005\n4518\n436\n9.65\n642\n14.21\n2830\n62.64\n459\n10.16\n151\n3.34\n\n\n2006\n4633\n454\n9.80\n639\n13.79\n2901\n62.62\n476\n10.27\n163\n3.52\n\n\n2007\n4763\n494\n10.37\n628\n13.18\n2996\n62.90\n473\n9.93\n172\n3.61\n\n\n2008\n4809\n479\n9.96\n636\n13.23\n3034\n63.09\n478\n9.94\n182\n3.78\n\n\n2009\n4824\n483\n10.01\n618\n12.81\n3052\n63.27\n477\n9.89\n194\n4.02\n\n\n2010\n4865\n475\n9.76\n641\n13.18\n3066\n63.02\n478\n9.83\n205\n4.21\n\n\n2011\n4814\n482\n10.01\n608\n12.63\n3010\n62.53\n495\n10.28\n219\n4.55\n\n\n2012\n4846\n484\n9.99\n619\n12.77\n3008\n62.07\n512\n10.57\n223\n4.60\n\n\n2013\n4872\n488\n10.02\n620\n12.73\n3001\n61.60\n549\n11.27\n214\n4.39\n\n\n2014\n4844\n474\n9.79\n628\n12.96\n2952\n60.94\n580\n11.97\n210\n4.34\n\n\n2015\n4859\n469\n9.65\n628\n12.92\n2944\n60.59\n593\n12.20\n225\n4.63\n\n\n2016\n4815\n441\n9.16\n628\n13.04\n2906\n60.35\n615\n12.77\n225\n4.67\n\n\n2017\n4813\n423\n8.79\n612\n12.72\n2884\n59.92\n669\n13.90\n225\n4.67\n\n\n2018\n4733\n388\n8.20\n619\n13.08\n2809\n59.35\n695\n14.68\n222\n4.69\n\n\n2019\n4715\n366\n7.76\n608\n12.90\n2787\n59.11\n724\n15.36\n230\n4.88\n\n\n2020\n4693\n331\n7.05\n636\n13.55\n2757\n58.75\n746\n15.90\n223\n4.75\n\n\n2021\n4689\n345\n7.36\n616\n13.14\n2747\n58.58\n755\n16.10\n226\n4.82\n\n\n2022\n4644\n323\n6.96\n619\n13.33\n2719\n58.55\n761\n16.39\n222\n4.78\n\n\n2023\n4695\n329\n7.01\n602\n12.82\n2766\n58.91\n774\n16.49\n224\n4.77\n\n\n2024M08*\n4664\n321\n6.88\n572\n12.26\n2755\n59.07\n783\n16.79\n233\n5.00\n\n\n\n\n\n\n\n\nVäestökehityksen muutos - 5 ikäluokkaa\n\n0-6-vuotiaat\nIkäluokkien kehitystä aikaisempiin vuosiin vertailtaessa 0-6-vuotiaiden %-osuus oli 2024M08* yhteensä 6.88. Jos verrataan lukemaa kahteen edellisvuoteen 2022 ja 2023, muutosta on tullut -0.08 (2022) ja -0.13 (2023)\n\n\n7-15-vuotiaat\n7-15-vuotiaiden %-osuus oli 2024M08* yhteensä 12.26. Edellisvuosiin 2022 ja 2023 verrattuna, muutosta on tullut -1.07 (2022) ja -0.56 (2023)\n\n\n16-64-vuotiaat\nIkäluokka 16-64-vuotiaat on suurin kooltaan. Tämän ryhmän prosenttiosuus kokonaisuudesta oli 2024M08* yhteensä 59.07. Edellisvuosiin 2022 ja 2023 verrattuna, muutosta on tullut 0.52 (2022) ja 0.16 (2023)\n\n\n65-79-vuotiaat\nIkäluokka 65-79-vuotiaat oli kooltaan 2024M08* yhteensä 16.79. Edellisvuosiin 2022 ja 2023 verrattuna, muutosta on tullut 0.4 (2022) ja 0.3 (2023)\n\n\n80+-vuotiaat\n80+-vuotiaiden %-osuus oli 2024M08* yhteensä 5. Edellisvuosiin 2022 ja 2023 verrattuna, muutosta on tullut 0.22 (2022) ja 0.23 (2023)"
  },
  {
    "objectID": "vaesto.html#väestönmuutokset---väestöennakko-kuusi-ikäluokkaa",
    "href": "vaesto.html#väestönmuutokset---väestöennakko-kuusi-ikäluokkaa",
    "title": "Väestönmuutokset",
    "section": "Väestönmuutokset - Väestöennakko, kuusi ikäluokkaa",
    "text": "Väestönmuutokset - Väestöennakko, kuusi ikäluokkaa\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nVuosi\nYhteensä\n0-6\n0-6 %\n7-15\n7-15 %\n16-18\n16-18 %\n19-64\n19-64 %\n65-79\n65-79 %\n80+\n80+ %\n\n\n\n\n2000\n4189\n406\n9.69\n573\n13.68\n189\n4.51\n2451\n58.51\n455\n10.86\n115\n2.75\n\n\n2001\n4203\n396\n9.42\n564\n13.42\n200\n4.76\n2469\n58.74\n452\n10.75\n122\n2.90\n\n\n2002\n4269\n387\n9.07\n589\n13.80\n189\n4.43\n2532\n59.31\n446\n10.45\n126\n2.95\n\n\n2003\n4333\n402\n9.28\n610\n14.08\n168\n3.88\n2562\n59.13\n452\n10.43\n139\n3.21\n\n\n2004\n4425\n409\n9.24\n640\n14.46\n153\n3.46\n2617\n59.14\n458\n10.35\n148\n3.34\n\n\n2005\n4518\n436\n9.65\n642\n14.21\n161\n3.56\n2669\n59.07\n459\n10.16\n151\n3.34\n\n\n2006\n4633\n454\n9.80\n639\n13.79\n189\n4.08\n2712\n58.54\n476\n10.27\n163\n3.52\n\n\n2007\n4763\n494\n10.37\n628\n13.18\n208\n4.37\n2788\n58.53\n473\n9.93\n172\n3.61\n\n\n2008\n4809\n479\n9.96\n636\n13.23\n225\n4.68\n2809\n58.41\n478\n9.94\n182\n3.78\n\n\n2009\n4824\n483\n10.01\n618\n12.81\n233\n4.83\n2819\n58.44\n477\n9.89\n194\n4.02\n\n\n2010\n4865\n475\n9.76\n641\n13.18\n212\n4.36\n2854\n58.66\n478\n9.83\n205\n4.21\n\n\n2011\n4814\n482\n10.01\n608\n12.63\n202\n4.20\n2808\n58.33\n495\n10.28\n219\n4.55\n\n\n2012\n4846\n484\n9.99\n619\n12.77\n186\n3.84\n2822\n58.23\n512\n10.57\n223\n4.60\n\n\n2013\n4872\n488\n10.02\n620\n12.73\n194\n3.98\n2807\n57.61\n549\n11.27\n214\n4.39\n\n\n2014\n4844\n474\n9.79\n628\n12.96\n180\n3.72\n2772\n57.23\n580\n11.97\n210\n4.34\n\n\n2015\n4859\n469\n9.65\n628\n12.92\n193\n3.97\n2751\n56.62\n593\n12.20\n225\n4.63\n\n\n2016\n4815\n441\n9.16\n628\n13.04\n176\n3.66\n2730\n56.70\n615\n12.77\n225\n4.67\n\n\n2017\n4813\n423\n8.79\n612\n12.72\n205\n4.26\n2679\n55.66\n669\n13.90\n225\n4.67\n\n\n2018\n4733\n388\n8.20\n619\n13.08\n181\n3.82\n2628\n55.53\n695\n14.68\n222\n4.69\n\n\n2019\n4715\n366\n7.76\n608\n12.90\n193\n4.09\n2594\n55.02\n724\n15.36\n230\n4.88\n\n\n2020\n4693\n331\n7.05\n636\n13.55\n174\n3.71\n2583\n55.04\n746\n15.90\n223\n4.75\n\n\n2021\n4689\n345\n7.36\n616\n13.14\n189\n4.03\n2558\n54.55\n755\n16.10\n226\n4.82\n\n\n2022\n4644\n323\n6.96\n619\n13.33\n185\n3.98\n2534\n54.57\n761\n16.39\n222\n4.78\n\n\n2023\n4695\n329\n7.01\n602\n12.82\n199\n4.24\n2567\n54.68\n774\n16.49\n224\n4.77\n\n\n2024M08*\n4664\n321\n6.88\n572\n12.26\n198\n4.25\n2557\n54.82\n783\n16.79\n233\n5.00\n\n\n\n\n\n\n\n\nVäestökehityksen muutos - 6 ikäluokkaa\n\n0-6-vuotiaat\nIkäluokkien kehitystä aikaisempiin vuosiin vertailtaessa 0-6-vuotiaiden %-osuus oli 2024M08* yhteensä 6.88. Jos verrataan lukemaa kahteen edellisvuoteen 2022 ja 2023, muutosta on tullut -0.08 (2022) ja -0.13 (2023)\n\n\n7-15-vuotiaat\n7-15-vuotiaiden %-osuus oli 2024M08* yhteensä 12.26. Edellisvuosiin 2022 ja 2023 verrattuna, muutosta on tullut -1.07 (2022) ja -0.56 (2023)\n\n\n16-18-vuotiaat\n16-18-vuotiaiden prosenttiosuus kokonaisuudesta oli 2024M08* yhteensä 4.25. Edellisvuosiin 2022 ja 2023 verrattuna, muutosta on tullut 0.27 (2022) ja 0.01 (2023)\n\n\n18-64-vuotiaat\nIkäluokka 18-64-vuotiaat on suurin kooltaan. Tämän ryhmän prosenttiosuus kokonaisuudesta oli 2024M08* yhteensä 59.07. Edellisvuosiin 2022 ja 2023 verrattuna, muutosta on tullut **** (2022) ja **** (2023)\n\n\n65-79-vuotiaat\nIkäluokka 65-79-vuotiaat oli kooltaan 2024M08* yhteensä 16.79. Edellisvuosiin 2022 ja 2023 verrattuna, muutosta on tullut 0.4 (2022) ja 0.3 (2023)\n\n\n80+-vuotiaat\n80+-vuotiaiden %-osuus oli 2024M08* yhteensä 5. Edellisvuosiin 2022 ja 2023 verrattuna, muutosta on tullut 0.22 (2022) ja 0.23 (2023)"
  }
]